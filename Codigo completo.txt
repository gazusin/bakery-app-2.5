// --- data-base ---

"use client";

import { parseISO, isValid, differenceInDays, addDays, format as formatDateFns, compareDesc, isWithinInterval, startOfDay, endOfDay, startOfWeek, endOfWeek, isSameDay } from 'date-fns'; // Renombrado format a formatDateFns
import { es } from 'date-fns/locale';

// --- Event Dispatcher ---
export function dispatchDataUpdateEvent(key: string) {
  if (typeof window !== 'undefined') {
    window.dispatchEvent(new CustomEvent('data-updated', { detail: { key } }));
  }
}

// --- New Interface for Exchange Rate History ---
export interface ExchangeRateEntry {
  date: string; // "YYYY-MM-DD"
  rate: number;
}


// --- Storage Key Constants ---
export const KEYS = {
  USER_PROFILE: 'bakery_user_profile_data',
  COMPANY_ACCOUNTS: 'bakery_company_accounts_data', // Será por sede
  EXCHANGE_RATE: 'bakery_exchange_rate', // Legacy key for today's rate
  EXCHANGE_RATE_HISTORY: 'bakery_exchange_rate_history', // New key for history
  PRODUCTS: 'bakery_products_data', // Será por sede
  PRODUCTION_LOG: 'bakery_production_log_data', // Será por sede
  RECIPES: 'bakery_recipes_data', // Será por sede
  SUPPLIERS: 'bakery_suppliers_data', // Global - Los proveedores son globales
  RAW_MATERIAL_OPTIONS: 'bakery_raw_material_options', // Global - Lista de MP es global
  PURCHASE_ORDERS: 'bakery_purchase_orders_data', // Será por sede
  RAW_MATERIAL_INVENTORY: 'bakery_raw_material_inventory', // Será por sede
  WEEKLY_GOALS: 'bakery_weekly_goals_data', // Será por sede
  MONTHLY_GOALS: 'bakery_monthly_goals_data', // Será por sede
  SALES: 'bakery_sales_data', // Global
  CUSTOMERS: 'bakery_customers_data', // Global
  PAYMENTS: 'bakery_payments_data', // Global
  ACCOUNT_TRANSACTIONS: 'bakery_account_transactions_data', // Será por sede
  EMPLOYEES: 'bakery_employees_data', // Será por sede
  EXPENSES: 'bakery_expenses_data', // Será por sede
  INVENTORY_TRANSFERS: 'bakery_inventory_transfers_data', // Global
  EXPENSE_FIXED_CATEGORIES: 'bakery_expense_fixed_categories', // AHORA POR SEDE
  EXPENSE_VARIABLE_CATEGORIES: 'bakery_expense_variable_categories', // AHORA POR SEDE
  ACTIVE_BRANCH_ID: 'bakery_active_branch_id', // Global
  PENDING_FUND_TRANSFERS: 'bakery_pending_fund_transfers_data', // Global
  CUSTOM_CONVERSION_RULES: 'bakery_custom_conversion_rules_global',
  WEEKLY_LOSS_REPORTS: 'bakery_weekly_loss_reports_data',
  WEEKLY_PROFIT_REPORTS: 'bakery_weekly_profit_reports_data', // Nuevo
} as const;

export const COMPANY_ACCOUNTS_STORAGE_KEY_BASE = KEYS.COMPANY_ACCOUNTS;
export const RAW_MATERIAL_INVENTORY_STORAGE_KEY_BRANCH_BASE = KEYS.RAW_MATERIAL_INVENTORY;
export const ACCOUNT_TRANSACTIONS_STORAGE_KEY_BASE = KEYS.ACCOUNT_TRANSACTIONS;
export const EXPENSES_STORAGE_KEY_BASE = KEYS.EXPENSES;
export const WEEKS_IN_MONTH = 365.25 / 12 / 7;


// --- User Credentials (Simulated) ---
export const SIMULATED_ADMIN_USERNAME = "admin";
export const SIMULATED_USER_PASSWORD = "pan123";

// --- Branch Management ---
export interface Branch {
  id: string;
  name: string;
}
export const availableBranches: Branch[] = [
  { id: 'panaderia_principal', name: 'Panadería' },
  { id: 'productos_elaborados', name: 'Productos' },
];

// --- Branch LocalStorage ---
export function getActiveBranchId(): string | null {
  if (typeof window === 'undefined') return availableBranches[0]?.id || null;
  const activeId = localStorage.getItem(KEYS.ACTIVE_BRANCH_ID);
  const isValidBranch = availableBranches.some(b => b.id === activeId);
  if (isValidBranch) return activeId;
  if (availableBranches.length > 0) {
      // No establecer automáticamente aquí, dejar que SelectBranchPage lo maneje
      // localStorage.setItem(KEYS.ACTIVE_BRANCH_ID, availableBranches[0].id);
      // return availableBranches[0].id;
  }
  return null;
}
export function setActiveBranchId(branchId: string): void {
    if (typeof window !== 'undefined') {
      if (availableBranches.some(b => b.id === branchId)) {
        localStorage.setItem(KEYS.ACTIVE_BRANCH_ID, branchId);
        dispatchDataUpdateEvent(KEYS.ACTIVE_BRANCH_ID);
      } else {
        console.error(`Intento de establecer una sede inválida: ${branchId}`);
      }
    }
}

// --- Storage Key Generation ---
const GLOBAL_KEYS = [
  KEYS.EXCHANGE_RATE, KEYS.EXCHANGE_RATE_HISTORY, KEYS.USER_PROFILE, KEYS.INVENTORY_TRANSFERS,
  KEYS.CUSTOMERS, KEYS.SALES, KEYS.PAYMENTS, KEYS.PENDING_FUND_TRANSFERS,
  KEYS.SUPPLIERS, KEYS.RAW_MATERIAL_OPTIONS, KEYS.CUSTOM_CONVERSION_RULES,
  KEYS.WEEKLY_LOSS_REPORTS, KEYS.WEEKLY_PROFIT_REPORTS
];

function getStorageKey(baseKey: string): string {
  if (GLOBAL_KEYS.includes(baseKey as any)) return baseKey;
  const activeBranchId = getActiveBranchId();
  if (!activeBranchId) return `${baseKey}_default_branch_PLEASE_SELECT_BRANCH`;
  return `${baseKey}_${activeBranchId}`;
}

function getStorageKeyForBranch(baseKey: string, branchId: string): string {
  if (GLOBAL_KEYS.includes(baseKey as any)) return baseKey; // Global keys don't change
  if (!availableBranches.some(b => b.id === branchId)) {
    console.warn(`getStorageKeyForBranch: BranchId '${branchId}' no es válido. Usando 'default_branch_ERROR'.`);
    return `${baseKey}_default_branch_ERROR`;
  }
  return `${baseKey}_${branchId}`;
}


// --- Helper: Default Data ---
function getDefaultObjectStructure(key: string, baseKey?: string): any {
  const k = baseKey || key;
  if (k === KEYS.USER_PROFILE) {
    const defaultPermissions = allModules.reduce((acc, moduleKey) => {
      const permKey = normalizeModuleKey(moduleKey);
      acc[permKey] = true;
      return acc;
    }, {} as UserPermissions);
    return {
      fullName: "Administrador Principal",
      email: SIMULATED_ADMIN_USERNAME,
      phone: "",
      moduleAccess: defaultPermissions,
    };
  }
  if (k === KEYS.COMPANY_ACCOUNTS) { // This is for a specific branch now
    return {
      vesElectronic: { balance: 0, currency: 'VES', lastTransactionDate: undefined },
      usdCash: { balance: 0, currency: 'USD', lastTransactionDate: undefined },
      vesCash: { balance: 0, currency: 'VES', lastTransactionDate: undefined },
    };
  }
  if (k === KEYS.CUSTOMERS || k === KEYS.SALES || k === KEYS.PAYMENTS || k === KEYS.PENDING_FUND_TRANSFERS || k === KEYS.INVENTORY_TRANSFERS || k === KEYS.SUPPLIERS || k === KEYS.RAW_MATERIAL_OPTIONS || k === KEYS.CUSTOM_CONVERSION_RULES || k === KEYS.WEEKLY_LOSS_REPORTS || k === KEYS.WEEKLY_PROFIT_REPORTS || k === KEYS.EXCHANGE_RATE_HISTORY) {
    return []; // Global arrays default to empty
  }
  // For branch-specific arrays if key is not global
  if ([KEYS.PRODUCTS, KEYS.PRODUCTION_LOG, KEYS.RECIPES, KEYS.PURCHASE_ORDERS, KEYS.RAW_MATERIAL_INVENTORY, KEYS.WEEKLY_GOALS, KEYS.MONTHLY_GOALS, KEYS.ACCOUNT_TRANSACTIONS, KEYS.EMPLOYEES, KEYS.EXPENSES, KEYS.EXPENSE_FIXED_CATEGORIES, KEYS.EXPENSE_VARIABLE_CATEGORIES].includes(k as any)) {
    return [];
  }
  if (k === KEYS.EXCHANGE_RATE) return 0;
  return {}; // Default for other non-array, non-object global types
}

// --- Storage (Load/Save) ---
function safeParse<T>(value: string|null, fallback: T): T {
  if (!value) return fallback;
  try { return JSON.parse(value) as T; } catch { return fallback; }
}

export function loadFromLocalStorage<T>(baseKey: string, isObject = false): T {
  const key = getStorageKey(baseKey);
  if (typeof window === 'undefined')
    return (isObject ? getDefaultObjectStructure(key, baseKey) : []) as T;
  const raw = localStorage.getItem(key);
  if (raw === null)
    return (isObject ? getDefaultObjectStructure(key, baseKey) : []) as T;
  const parsed = safeParse<T>(raw, isObject ? getDefaultObjectStructure(key, baseKey) : [] as T);
  if (isObject && typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed)) return parsed as T;
  if (!isObject && Array.isArray(parsed)) return parsed as T;
  return (isObject ? getDefaultObjectStructure(key, baseKey) : []) as T;
}

function saveToLocalStorage<T>(baseKey: string, data: T): void {
  if (typeof window === 'undefined') return;
  const key = getStorageKey(baseKey);
  if (key.includes("_default_branch_PLEASE_SELECT_BRANCH") && !GLOBAL_KEYS.includes(baseKey as any)) {
    console.warn(`Intentando guardar datos para una clave de sede no seleccionada: ${key}. Operación omitida.`);
    return;
  }
  localStorage.setItem(key, JSON.stringify(data));
  dispatchDataUpdateEvent(baseKey);
}

export function loadFromLocalStorageForBranch<T>(baseKey: string, branchId: string, isObject = false): T {
  const key = getStorageKeyForBranch(baseKey, branchId);
  if (typeof window === 'undefined')
    return (isObject ? getDefaultObjectStructure(key, baseKey) : []) as T;
  const raw = localStorage.getItem(key);
  if (raw === null)
    return (isObject ? getDefaultObjectStructure(key, baseKey) : []) as T;
  const parsed = safeParse<T>(raw, isObject ? getDefaultObjectStructure(key, baseKey) : [] as T);
  if (isObject && typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed)) return parsed as T;
  if (!isObject && Array.isArray(parsed)) return parsed as T;
  return (isObject ? getDefaultObjectStructure(key, baseKey) : []) as T;
}
export function saveToLocalStorageForBranch<T>(baseKey: string, branchId: string, data: T): void {
  if (typeof window === 'undefined') return;
  const key = getStorageKeyForBranch(baseKey, branchId);
  localStorage.setItem(key, JSON.stringify(data));
  dispatchDataUpdateEvent(baseKey);
}

// --- Nueva Interface para Reglas de Conversión Personalizadas ---
export interface CustomConversionRule {
  id: string;
  purchaseUnit: string;
  materialNameMatcher?: string;
  baseUnit: 'kg' | 'g' | 'l' | 'ml' | 'unidad';
  factor: number;
}

// --- Funciones para Cargar y Guardar Reglas de Conversión Personalizadas (AHORA GLOBALES) ---
export function loadCustomConversionRules(): CustomConversionRule[] {
  const rules = loadFromLocalStorage<CustomConversionRule[]>(KEYS.CUSTOM_CONVERSION_RULES);
  return Array.isArray(rules) ? rules : [];
}

export function saveCustomConversionRules(rules: CustomConversionRule[]): void {
  const validRules = rules.filter(rule =>
    rule.id && rule.purchaseUnit && rule.baseUnit && typeof rule.factor === 'number' && rule.factor > 0 && VALID_BASE_UNITS.includes(rule.baseUnit)
  ).map(rule => ({
    ...rule,
    purchaseUnit: rule.purchaseUnit.trim(),
    materialNameMatcher: rule.materialNameMatcher?.trim().toLowerCase() || undefined,
  }));
  saveToLocalStorage<CustomConversionRule[]>(KEYS.CUSTOM_CONVERSION_RULES, validRules);
}


// --- Unit Conversion Utilities ---
const VALID_BASE_UNITS_UNSORTED = ['kg', 'g', 'l', 'ml', 'unidad'];
export const VALID_BASE_UNITS = [...VALID_BASE_UNITS_UNSORTED].sort();

export function normalizeUnit(unit: string|undefined): string {
  if (typeof unit !== 'string' || !unit) return 'unidad';
  let u = unit.toLowerCase().trim();
  const unitMap: Record<string, string> = {
    'kg': 'kg', 'kilo': 'kg', 'kilos': 'kg', 'kilogramo': 'kg', 'kilogramos': 'kg',
    'g': 'g', 'gramo': 'g', 'gramos': 'g', 'gr': 'g',
    'l': 'l', 'litro': 'l', 'litros': 'l', 'lt': 'l',
    'ml': 'ml', 'mililitro': 'ml', 'mililitros': 'ml',
    'galon': 'galon', 'galón': 'galon', 'galones': 'galon', 'gallon': 'galon', 'galones(es)': 'galon', 'gal': 'galon',
    'unidad': 'unidad', 'unidades': 'unidad', 'und': 'unidad', 'unit': 'unidad', 'unid': 'unidad', 'unidad(es)': 'unidad',
    'docena': 'docena', 'docenas': 'docena', 'docena(s)': 'docena',
    'paquete': 'paquete', 'paquetes': 'paq', 'paquete(s)': 'paquete',
    'caja': 'caja', 'cajas': 'caja', 'caja(s)': 'caja',
    'saco': 'saco', 'sacos': 'saco', 'saco(s)': 'saco',
    'bandeja': 'bandeja', 'bandejas': 'bandeja', 'bandeja(s)': 'bandeja'
  };
  return unitMap[u] || u;
}

export const unitConversionsTable = {
  'galon': { toBaseUnit: 'l', factor: 3.78541 },
  'docena': { toBaseUnit: 'unidad', factor: 12 },
  // Eliminadas las conversiones 'g' -> 'kg' y 'ml' -> 'l'
  // Ahora g y ml se tratarán como unidades base por sí mismas.
};

export const materialSpecificSackConversions: Record<string, { factor: number; baseUnit: string }> = {
  'harina de trigo': { factor: 45, baseUnit: 'kg' },
  'harina': { factor: 45, baseUnit: 'kg' },
  'azucar': { factor: 50, baseUnit: 'kg' },
  'azúcar': { factor: 50, baseUnit: 'kg' },
};

export const materialSpecificBoxConversions: Record<string, { factor: number; baseUnit: string }> = {
  'mantequilla': { factor: 15, baseUnit: 'kg' },
  'aceite': { factor: 20, baseUnit: 'l' },
  'papelón': { factor: 8.4, baseUnit: 'kg' },
  'papelon': { factor: 8.4, baseUnit: 'kg' },
};

export function convertMaterialToBaseUnit(
  quantityInput: number | string,
  unit: string,
  materialName?: string
): { quantity: number; unit: string } {
  const normalizedPurchaseUnit = normalizeUnit(unit);
  const numQuantity = Number(quantityInput);

  if (isNaN(numQuantity)) {
    return { quantity: 0, unit: normalizedPurchaseUnit || 'unidad' };
  }

  const lowerMaterialName = materialName?.toLowerCase().trim();

  const customRules = loadCustomConversionRules();
  for (const rule of customRules) {
    const rulePurchaseUnitNormalized = normalizeUnit(rule.purchaseUnit);
    const rulePurchaseUnitOriginal = rule.purchaseUnit.toLowerCase().trim();

    if (rulePurchaseUnitNormalized === normalizedPurchaseUnit || rulePurchaseUnitOriginal === unit.toLowerCase().trim()) {
      if (rule.materialNameMatcher && lowerMaterialName) {
        const matchers = rule.materialNameMatcher.split(',').map(m => m.trim().toLowerCase());
        if (matchers.some(matcher => lowerMaterialName.includes(matcher))) {
          return { quantity: numQuantity * rule.factor, unit: rule.baseUnit };
        }
      } else if (!rule.materialNameMatcher) {
        return { quantity: numQuantity * rule.factor, unit: rule.baseUnit };
      }
    }
  }

  if (lowerMaterialName && lowerMaterialName.includes('bolsa') && normalizedPurchaseUnit === 'paquete') {
    return { quantity: numQuantity * 1000, unit: 'unidad' };
  }

  if (lowerMaterialName && normalizedPurchaseUnit === 'saco') {
    for (const keyword in materialSpecificSackConversions) {
      if (lowerMaterialName.includes(keyword)) {
        const conversion = materialSpecificSackConversions[keyword];
        return { quantity: numQuantity * conversion.factor, unit: conversion.baseUnit };
      }
    }
  }

  if (lowerMaterialName && normalizedPurchaseUnit === 'caja') {
    for (const keyword in materialSpecificBoxConversions) {
      if (lowerMaterialName.includes(keyword)) {
        const conversion = materialSpecificBoxConversions[keyword];
        return { quantity: numQuantity * conversion.factor, unit: conversion.baseUnit };
      }
    }
  }

  const genericConversion = unitConversionsTable[normalizedPurchaseUnit as keyof typeof unitConversionsTable];
  if (genericConversion) {
    return { quantity: numQuantity * genericConversion.factor, unit: genericConversion.toBaseUnit };
  }

  if (VALID_BASE_UNITS.includes(normalizedPurchaseUnit)) {
    return { quantity: numQuantity, unit: normalizedPurchaseUnit };
  }

  console.warn(`Unidad de compra '${unit}' (normalizada: '${normalizedPurchaseUnit}') para material '${materialName || 'desconocido'}' no tiene conversión a unidad base estándar y no es una unidad base en sí misma. Se devolverá la unidad original NO normalizada '${unit}'.`);
  return { quantity: numQuantity, unit: unit };
}


// --- Types, Models, Data ---
export type AccountType = 'vesElectronic' | 'usdCash' | 'vesCash';
export const accountTypes: AccountType[] = ['vesElectronic', 'usdCash', 'vesCash'];
export const accountTypeNames: Record<AccountType, string> = {
  vesElectronic: "VES Electrónico",
  usdCash: "USD Efectivo",
  vesCash: "VES Efectivo"
};

export interface UserPermissions { [moduleId: string]: boolean; }
export const allModules = [
  "Panel Principal", "Stock de producción", "Producción", "Recetas", "Proveedores",
  "Órdenes de Compra", "Inventario Materia Prima", "Comparación de Precios", "Reorden Inteligente",
  "Metas de Producción", "Ventas", "Clientes", "Cuentas por Cobrar", "Verificación de Pagos", "Movimientos de Cuenta",
  "Empleados", "Gastos", "Reportes", "Perfil de Usuario", "Transferencias MP", "Transferencias Fondos"
];
function normalizeModuleKey(moduleKey: string) {
  return moduleKey.toLowerCase().replace(/ /g, '-').replace(/[óòôõö]/g, 'o').replace(/[áàâãä]/g, 'a')
    .replace(/[éèêë]/g, 'e').replace(/[íìîï]/g, 'i').replace(/[úùûü]/g, 'u').replace(/ñ/g, 'n');
}
export interface Product { id: string; name: string; category: string; stock: number; unitPrice: number; lastUpdated: string; image: string; aiHint?: string; sourceBranchId?: string; sourceBranchName?: string;}
export interface ProductionLogEntry {
  id: string;
  date: string;
  product: string;
  batchSizeMultiplier: number;
  expectedQuantity: number;
  actualQuantity: number;
  unitPrice: number;
  staff: string;
  batchNumber?: string;
  timestamp?: string;
  bagUsed?: string;
  labelUsed?: string;
}
export interface ProductionGoal { id: string; product: string; target: number; achieved: number; status: string; period: 'weekly' | 'monthly'; startDate: string; }
export interface RecipeIngredientItem {
  id: string;
  name: string;
  quantity: number;
  unit: string;
  notes?: string;
}

export interface Recipe {
  id: string;
  name: string;
  ingredients: RecipeIngredientItem[];
  instructions?: string;
  costPerUnit: number;
  expectedYield?: number;
  lastUpdated: string;
  isIntermediate?: boolean;
  outputUnit?: 'kg' | 'L';
  category?: string;
  aiHint?: string;
  batchSizeMultiplier?: number;
}

export interface PriceHistoryEntry {
  price: number;
  date: string;
}
export interface SupplierPriceListItem {
  id: string;
  rawMaterialName: string;
  unit: string;
  priceHistory: PriceHistoryEntry[];
}
export interface Supplier {
  id: string;
  name: string;
  contactPerson?: string;
  phone?: string;
  email?: string;
  address?: string;
  priceList?: SupplierPriceListItem[];
  priceListUSDCash?: SupplierPriceListItem[]; // Nueva lista de precios para USD en efectivo
}
export interface PurchaseOrderItem { id: string; rawMaterialName: string; quantity: number; unit: string; unitPrice: number; subtotal: number; }
export type PurchaseOrderStatus = 'Pagado' | 'Pendiente' | 'Cancelado' | 'Recibido';
export const purchaseOrderStatusList: PurchaseOrderStatus[] = ['Pagado', 'Pendiente', 'Cancelado', 'Recibido'];

export interface PurchaseOrder {
  id: string;
  supplierId: string;
  supplierName: string;
  orderDate: string;
  expectedDelivery: string;
  items: PurchaseOrderItem[];
  totalCost: number;
  status: PurchaseOrderStatus;
  paymentSplits?: PaymentSplit[];
  timestamp?: string;
  exchangeRateOnOrderDate?: number;
  notes?: string;
}
export type PaymentMethodType = 'Efectivo USD' | 'Efectivo VES' | 'Pago Móvil (VES)' | 'Transferencia (VES)' | 'Otro' | 'Crédito a Favor' | 'Nota de Crédito';
export const paymentMethodList: PaymentMethodType[] = ['Efectivo USD', 'Efectivo VES', 'Pago Móvil (VES)', 'Transferencia (VES)', 'Otro', 'Crédito a Favor'].sort((a,b) => a.localeCompare(b));
export const salePaymentMethods: Sale['paymentMethod'][] = ['Pagado', 'Crédito'];

export interface PaymentSplit {
  id: string;
  amount: number;
  currency: 'USD' | 'VES';
  paymentMethod: PaymentMethodType;
  exchangeRateAtPayment?: number;
  paidToBranchId: string;
  paidToAccountId: AccountType;
  referenceNumber?: string;
  items?: PurchaseOrderItem[];
}

export interface SaleItem {
  productId: string;
  productName: string;
  quantity: number;
  unitPrice: number;
  subtotal: number;
  sourceBranchId: string;
  sourceBranchName: string;
}

export interface SaleBranchDetail {
  branchId: string;
  branchName: string;
  items: SaleItem[];
  totalAmount: number;
  amountPaidUSD: number;
}

export interface Sale {
  id: string;
  date: string;
  itemsPerBranch: SaleBranchDetail[];
  changes?: SaleItem[];
  samples?: SaleItem[];
  customerId?: string;
  customerName?: string;
  totalAmount: number;
  paymentMethod: 'Pagado' | 'Crédito';
  dueDate?: string;
  paymentSplits?: PaymentSplit[]; // Usado si paymentMethod es 'Pagado'
  amountPaidUSD: number; 
  status?: SaleStatus;
  timestamp?: string;
  notes?: string;
  creditNoteTargetInvoiceId?: string; // Para identificar a qué factura se aplica la nota de crédito
}

export type SaleStatus = 'Completada' | 'Pendiente de Pago' | 'Vencida' | 'Pagada Parcialmente';

export interface Customer {
  id: string;
  name: string;
  contact: string;
  email?: string; 
  address?: string;
  workZone?: string; 
  lastOrder?: string;
}

export type PaymentStatus = 'pendiente de verificación' | 'verificado' | 'rechazado';
export type PaymentSource = 'invoice' | 'balance_adjustment';


export interface PaymentBranchApplication {
  branchId: string;
  amount: number;
}

export interface Payment {
  id: string;
  customerId: string;
  customerName: string;
  paymentDate: string;
  amountPaidInput: number;
  currencyPaidInput: 'USD' | 'VES';
  exchangeRateAtPayment?: number;
  amountAppliedToDebtUSD: number;
  amountAppliedPerBranch_USD?: PaymentBranchApplication[];
  paymentMethod: PaymentMethodType;
  paidToAccountId?: AccountType;
  paidToBranchId?: string;
  status: PaymentStatus;
  referenceNumber?: string;
  notes?: string;
  verifiedBy?: string;
  verificationDate?: string;
  appliedToInvoiceId?: string;
  paymentSource: PaymentSource;
  creationTimestamp?: string;
  parentPaymentId?: string; // Nuevo para agrupar pagos
}

export type TransactionType = 'ingreso' | 'egreso';
export interface AccountTransaction {
  id: string;
  date: string;
  description: string;
  type: TransactionType;
  amount: number;
  currency: 'USD' | 'VES';
  accountId: AccountType;
  exchangeRateOnTransactionDate?: number;
  amountInOtherCurrency?: number;
  category?: string;
  sourceModule: 'Ventas (Pago Cliente)' | 'Gastos Operativos' | 'Nómina' | 'Compra de Materia Prima' | 'Ajuste Manual Ingreso' | 'Ajuste Manual Egreso' | 'Transferencia de Fondos';
  sourceId?: string;
  relatedSaleId?: string;
  relatedPaymentId?: string;
  balanceAfterTransaction?: number;
  timestamp?: string;
}
export interface AccountBalance {
  balance: number;
  currency: 'USD' | 'VES';
  lastTransactionDate?: string;
}
export interface CompanyAccountsData { // Representa las cuentas de UNA sede
  vesElectronic: AccountBalance;
  usdCash: AccountBalance;
  vesCash: AccountBalance;
}
export interface Employee { id: string; name: string; role: string; contact: string; hireDate: string; status: string; salary?: number; }
export interface Expense {
  id: string;
  date: string;
  mainCategoryType?: 'Fijo' | 'Variable' | string;
  category: string;
  description: string;
  amount: number; // Siempre en USD para el gasto, la transacción de cuenta se hace en la moneda de la cuenta
  paidTo: string;
  sourceModule?: 'Compra de Materia Prima' | 'Gastos Operativos';
  sourceId?: string;
  paymentAccountId?: AccountType; // La cuenta desde donde se pagó
  timestamp?: string;
}
export interface UserProfile { fullName: string; email: string; phone: string; moduleAccess: UserPermissions; }
export interface RawMaterialInventoryItem { name: string; quantity: number; unit: string; }
export interface InventoryTransfer {
  id: string;
  date: string;
  fromBranchId: string;
  fromBranchName: string;
  toBranchId: string;
  toBranchName: string;
  materialName: string;
  quantity: number;
  unit: string;
  notes?: string;
  timestamp?: string;
}
export interface ExpenseFixedCategory { name: string; monthlyAmount?: number; }

export interface DirectIngredient {
  name: string;
  quantity: number;
  unit: string;
  isIntermediate: boolean;
  originalRecipeUnit?: string;
}

export interface PendingFundTransfer {
  id: string;
  saleId: string;
  fromBranchId: string;
  fromBranchName: string;
  toBranchId: string;
  toBranchName: string;
  amountUSD: number;
  amountVES?: number; // Nuevo
  originalPaymentAccountId?: AccountType;
  originalPaymentCurrency?: 'USD' | 'VES';
  exchangeRateAtPayment?: number; // Añadido
  fromAccountId?: AccountType;
  toAccountId?: AccountType;
  creationTimestamp: string;
  status: 'pendiente' | 'completada';
  completionTimestamp?: string;
  notes?: string;
  parentPaymentId?: string;
}

export interface LossEntry {
  type: 'Merma' | 'Cambio' | 'Muestra';
  date: string;
  productName: string;
  quantity: number;
  costPerUnitUSD: number;
  totalCostUSD: number;
  customerId?: string;
  customerName?: string;
  saleId?: string;
  sourceBranchId: string;
  sourceBranchName: string;
}

export interface WeeklyLossReport {
  id: string; // e.g., WLR-YYYY-MM-DD
  weekStartDate: string;
  weekEndDate: string;
  generatedOn: string;
  totalLossUSD: number;
  entries: LossEntry[];
}

export interface ProfitEntry {
    date: string;
    productName: string;
    quantitySold: number;
    salePricePerUnitUSD: number;
    costPerUnitUSD: number;
    profitPerUnitUSD: number;
    totalProfitUSD: number;
    sourceBranchId: string;
    sourceBranchName: string;
    saleId: string;
}

export interface WeeklyProfitReport {
  id: string;
  weekStartDate: string;
  weekEndDate: string;
  generatedOn: string;
  totalRevenueUSD: number;
  totalCostsUSD: number;
  totalProfitUSD: number;
  entries: ProfitEntry[];
}


// --- Global Data Variables ---
export let productsData: Product[] = [];
export let productionLogData: ProductionLogEntry[] = [];
export let recipesData: Recipe[] = [];
export let suppliersData: Supplier[] = []; // Global
export let rawMaterialOptions: string[] = []; // Global
export let purchaseOrdersData: PurchaseOrder[] = [];
export let rawMaterialInventoryData: RawMaterialInventoryItem[] = [];
export let weeklyGoalsData: ProductionGoal[] = [];
export let monthlyGoalsData: ProductionGoal[] = [];
export let employeesData: Employee[] = [];
export let expensesData: Expense[] = [];
export let customConversionRulesData: CustomConversionRule[] = [];


// Datos GLOBALES
export let salesData: Sale[] = [];
export let customersData: Customer[] = [];
export let paymentsData: Payment[] = [];
export let inventoryTransfersData: InventoryTransfer[] = [];
export let userProfileData: UserProfile = getDefaultObjectStructure(KEYS.USER_PROFILE, KEYS.USER_PROFILE) as UserProfile;
export let pendingFundTransfersData: PendingFundTransfer[] = [];
export let weeklyLossReportsData: WeeklyLossReport[] = []; 
export let weeklyProfitReportsData: WeeklyProfitReport[] = []; // Nuevo


// --- Default Expense Categories ---
const defaultFixedExpenseCategories: ExpenseFixedCategory[] = [];
const defaultVariableExpenseCategories: string[] = [];


// --- Initial Data for Recipes (Empty by default now) ---
const initialRecipesDataInternal: Recipe[] = [];


// --- Expense Categories Functions (AHORA POR SEDE) ---
export function loadExpenseFixedCategories(branchId?: string): ExpenseFixedCategory[] {
  const currentBranchId = branchId || getActiveBranchId();
  if (!currentBranchId) {
    console.warn("loadExpenseFixedCategories: No branch ID provided and no active branch.");
    return [];
  }
  const key = getStorageKeyForBranch(KEYS.EXPENSE_FIXED_CATEGORIES, currentBranchId);
  let workingCategories: ExpenseFixedCategory[];

  if (typeof window === 'undefined') {
    workingCategories = JSON.parse(JSON.stringify(defaultFixedExpenseCategories));
  } else {
    const raw = localStorage.getItem(key);
    if (raw === null) {
      workingCategories = JSON.parse(JSON.stringify(defaultFixedExpenseCategories));
    } else {
      const storedCategories = safeParse<ExpenseFixedCategory[]>(raw, []);
      if (!Array.isArray(storedCategories) || (storedCategories.length > 0 && !storedCategories.every(cat => typeof cat === 'object' && cat !== null && 'name' in cat && typeof cat.name === 'string'))) {
        workingCategories = JSON.parse(JSON.stringify(defaultFixedExpenseCategories));
      } else {
        workingCategories = storedCategories;
      }
    }
  }

  workingCategories = workingCategories.filter(cat => cat.name.toLowerCase() !== 'compra de materia prima');

  const nominaIndex = workingCategories.findIndex(cat => cat.name.toLowerCase() === 'nómina');
  if (nominaIndex === -1) {
    workingCategories.push({ name: "Nómina" });
  } else {
    workingCategories[nominaIndex] = { name: "Nómina" }; // Asegurar que no tenga monto editable aquí
  }
  return workingCategories.sort((a, b) => a.name.localeCompare(b.name));
}


export function saveExpenseFixedCategories(branchId: string, categories: ExpenseFixedCategory[]): void {
  if (!branchId) {
    console.error("saveExpenseFixedCategories: Branch ID is required.");
    return;
  }
  const uniqueCategoriesMap = new Map<string, ExpenseFixedCategory>();
  let nominaExists = false;
  categories.forEach(cat => {
    if (cat && typeof cat.name === 'string' && cat.name.trim() !== "") {
      const nameTrimmed = cat.name.trim();
      const nameLower = nameTrimmed.toLowerCase();
      if (!uniqueCategoriesMap.has(nameLower)) {
        const categoryToSave: ExpenseFixedCategory = { name: nameTrimmed };
        if (nameLower === 'nómina') {
          nominaExists = true;
        } else if (typeof cat.monthlyAmount === 'number' && cat.monthlyAmount >= 0) {
          categoryToSave.monthlyAmount = cat.monthlyAmount;
        }
        uniqueCategoriesMap.set(nameLower, categoryToSave);
      }
    }
  });

  if (!nominaExists) {
    uniqueCategoriesMap.set('nómina', { name: "Nómina" });
  }
  const dataToSave = Array.from(uniqueCategoriesMap.values()).sort((a, b) => a.name.localeCompare(b.name));
  saveToLocalStorageForBranch<ExpenseFixedCategory[]>(KEYS.EXPENSE_FIXED_CATEGORIES, branchId, dataToSave);
}

export function addExpenseFixedCategory(branchId: string, categoryName: string, monthlyAmount?: number): boolean {
  if (!branchId) return false;
  const trimmedCategoryName = categoryName.trim();
  if (!trimmedCategoryName || trimmedCategoryName.toLowerCase() === 'compra de materia prima') return false;

  const currentCategories = loadExpenseFixedCategories(branchId);
  if (currentCategories.find(c => c.name.toLowerCase() === trimmedCategoryName.toLowerCase())) {
    return false;
  }
  const newCategory: ExpenseFixedCategory = { name: trimmedCategoryName };
  if (trimmedCategoryName.toLowerCase() !== 'nómina' && typeof monthlyAmount === 'number' && monthlyAmount >= 0) {
    newCategory.monthlyAmount = monthlyAmount;
  }
  saveExpenseFixedCategories(branchId, [...currentCategories, newCategory]);
  return true;
}

export function removeExpenseFixedCategory(branchId: string, categoryNameToRemove: string): void {
  if (!branchId) return;
  const trimmedCategoryToRemove = categoryNameToRemove.trim().toLowerCase();
  if (trimmedCategoryToRemove === 'nómina' || trimmedCategoryToRemove === 'compra de materia prima') {
    console.warn(`Attempted to remove protected category: ${categoryNameToRemove}`);
    return;
  }
  const currentCategories = loadExpenseFixedCategories(branchId);
  const initialLength = currentCategories.length;
  const updatedCategories = currentCategories.filter(
    c => c.name.toLowerCase() !== trimmedCategoryToRemove
  );

  if (updatedCategories.length < initialLength) {
    saveExpenseFixedCategories(branchId, updatedCategories);
  } else {
    console.warn(`Category to remove not found in fixed list for branch ${branchId}: ${categoryNameToRemove}`);
  }
}

export function loadExpenseVariableCategories(branchId?: string): string[] {
  const currentBranchId = branchId || getActiveBranchId();
  if (!currentBranchId) {
    console.warn("loadExpenseVariableCategories: No branch ID provided and no active branch.");
    return [];
  }
  let categories = loadFromLocalStorageForBranch<string[]>(KEYS.EXPENSE_VARIABLE_CATEGORIES, currentBranchId);
  categories = Array.isArray(categories) ? categories : [];
  categories = categories.filter(cat => typeof cat === 'string' && cat.toLowerCase() !== 'compra de materia prima');
  return categories.sort((a, b) => a.localeCompare(b));
}

export function saveExpenseVariableCategories(branchId: string, categories: string[]): void {
  if (!branchId) {
    console.error("saveExpenseVariableCategories: Branch ID is required.");
    return;
  }
  const dataToSave = [...new Set(categories.filter(cat => typeof cat === 'string' && cat.trim() !== '' && cat.toLowerCase() !== 'compra de materia prima'))].sort((a, b) => a.localeCompare(b));
  saveToLocalStorageForBranch<string[]>(KEYS.EXPENSE_VARIABLE_CATEGORIES, branchId, dataToSave);
}

export function addExpenseVariableCategory(branchId: string, category: string): boolean {
  if (!branchId) return false;
  const trimmedCategory = category.trim();
  if (!trimmedCategory || trimmedCategory.toLowerCase() === 'compra de materia prima') return false;
  const currentCategories = loadExpenseVariableCategories(branchId);
  if (currentCategories.find(c => c.toLowerCase() === trimmedCategory.toLowerCase())) {
    return false;
  }
  saveExpenseVariableCategories(branchId, [...currentCategories, trimmedCategory]);
  return true;
}

export function removeExpenseVariableCategory(branchId: string, categoryToRemove: string): void {
  if (!branchId) return;
  const trimmedCategoryToRemove = categoryToRemove.trim().toLowerCase();
  if (trimmedCategoryToRemove === 'compra de materia prima') return;
  const currentCategories = loadExpenseVariableCategories(branchId);
  const updatedCategories = currentCategories.filter(c => c.toLowerCase() !== trimmedCategoryToRemove);
  if (updatedCategories.length < currentCategories.length) {
    saveExpenseVariableCategories(branchId, updatedCategories);
  }
}


// --- Specific Load/Save Functions ---
export function loadUserProfileFromLocalStorage(): UserProfile { // Global
  const loadedProfile = loadFromLocalStorage<UserProfile>(KEYS.USER_PROFILE, true);
  const defaultPermissions = allModules.reduce((acc, moduleKey) => {
    const permKey = normalizeModuleKey(moduleKey);
    acc[permKey] = true;
    return acc;
  }, {} as UserPermissions);

  return {
    fullName: typeof loadedProfile.fullName === 'string' && loadedProfile.fullName.trim() ? loadedProfile.fullName : "Administrador Principal",
    email: typeof loadedProfile.email === 'string' && loadedProfile.email.trim() ? loadedProfile.email : SIMULATED_ADMIN_USERNAME,
    phone: typeof loadedProfile.phone === 'string' ? loadedProfile.phone : "",
    moduleAccess: (typeof loadedProfile.moduleAccess === 'object' && loadedProfile.moduleAccess !== null && Object.keys(loadedProfile.moduleAccess).length > 0)
      ? loadedProfile.moduleAccess
      : defaultPermissions,
  };
}
export function saveUserProfileData(data: UserProfile): void { // Global
  userProfileData = data;
  saveToLocalStorage<UserProfile>(KEYS.USER_PROFILE, userProfileData);
}

export function loadCompanyAccountsData(branchIdToLoad?: string): CompanyAccountsData {
  const branchId = branchIdToLoad || getActiveBranchId();
  if (!branchId) {
    console.error("loadCompanyAccountsData: No branchId provided and no active branch selected.");
    return getDefaultObjectStructure(KEYS.COMPANY_ACCOUNTS, KEYS.COMPANY_ACCOUNTS) as CompanyAccountsData;
  }
  const loadedAccounts = loadFromLocalStorageForBranch<CompanyAccountsData>(KEYS.COMPANY_ACCOUNTS, branchId, true);
  const defaultStructure = getDefaultObjectStructure(KEYS.COMPANY_ACCOUNTS, KEYS.COMPANY_ACCOUNTS) as CompanyAccountsData;

  return JSON.parse(JSON.stringify({
    vesElectronic: {
      balance: typeof loadedAccounts.vesElectronic?.balance === 'number' ? loadedAccounts.vesElectronic.balance : defaultStructure.vesElectronic.balance,
      currency: 'VES',
      lastTransactionDate: typeof loadedAccounts.vesElectronic?.lastTransactionDate === 'string' ? loadedAccounts.vesElectronic.lastTransactionDate : undefined,
    },
    usdCash: {
      balance: typeof loadedAccounts.usdCash?.balance === 'number' ? loadedAccounts.usdCash.balance : defaultStructure.usdCash.balance,
      currency: 'USD',
      lastTransactionDate: typeof loadedAccounts.usdCash?.lastTransactionDate === 'string' ? loadedAccounts.usdCash?.lastTransactionDate : undefined,
    },
    vesCash: {
      balance: typeof loadedAccounts.vesCash?.balance === 'number' ? loadedAccounts.vesCash.balance : defaultStructure.vesCash.balance,
      currency: 'VES',
      lastTransactionDate: typeof loadedAccounts.vesCash?.lastTransactionDate === 'string' ? loadedAccounts.vesCash?.lastTransactionDate : undefined,
    },
  }));
}

export function saveCompanyAccountsData(branchIdToSave: string, data: CompanyAccountsData): void {
  if (!branchIdToSave) {
    console.error("saveCompanyAccountsData: No branchId provided.");
    return;
  }
  saveToLocalStorageForBranch<CompanyAccountsData>(KEYS.COMPANY_ACCOUNTS, branchIdToSave, data);
}


export function saveExchangeRate(rate: number, date?: Date): void {
  if (typeof window === 'undefined') return;
  const targetDate = date || new Date();
  const targetDateStr = formatDateFns(targetDate, "yyyy-MM-dd");

  let history = loadFromLocalStorage<ExchangeRateEntry[]>(KEYS.EXCHANGE_RATE_HISTORY, false);
  if (!Array.isArray(history)) {
    history = [];
  }
  const entryIndex = history.findIndex(entry => entry.date === targetDateStr);
  
  if (rate >= 0) {
    if (entryIndex > -1) {
      history[entryIndex].rate = rate;
    } else {
      history.push({ date: targetDateStr, rate });
    }
  }

  history.sort((a, b) => compareDesc(parseISO(a.date), parseISO(b.date)));
  
  localStorage.setItem(KEYS.EXCHANGE_RATE_HISTORY, JSON.stringify(history));
  
  // Also update the main rate if the date is today
  const todayStr = formatDateFns(new Date(), "yyyy-MM-dd");
  if (!date || isSameDay(targetDate, new Date())) {
      localStorage.setItem(KEYS.EXCHANGE_RATE, (rate >= 0 ? rate : 0).toString());
  }

  dispatchDataUpdateEvent(KEYS.EXCHANGE_RATE);
  dispatchDataUpdateEvent(KEYS.EXCHANGE_RATE_HISTORY);
}

export function removeExchangeRate(dateToRemove: string): void {
  if (typeof window === 'undefined' || !dateToRemove) return;

  let history = loadFromLocalStorage<ExchangeRateEntry[]>(KEYS.EXCHANGE_RATE_HISTORY, false);
  if (!Array.isArray(history)) {
    return; // Nothing to remove
  }

  const initialLength = history.length;
  const updatedHistory = history.filter(entry => entry.date !== dateToRemove);

  if (updatedHistory.length < initialLength) {
    localStorage.setItem(KEYS.EXCHANGE_RATE_HISTORY, JSON.stringify(updatedHistory));
    
    // Check if the deleted rate was today's rate
    const todayStr = formatDateFns(new Date(), "yyyy-MM-dd");
    if (dateToRemove === todayStr) {
      // Find the new "latest" rate to set as the current rate
      const newLatestRateEntry = updatedHistory.length > 0 ? updatedHistory[0] : null;
      const newRate = newLatestRateEntry ? newLatestRateEntry.rate : 0;
      localStorage.setItem(KEYS.EXCHANGE_RATE, newRate.toString());
    }
    
    dispatchDataUpdateEvent(KEYS.EXCHANGE_RATE);
    dispatchDataUpdateEvent(KEYS.EXCHANGE_RATE_HISTORY);
  }
}

export function loadExchangeRate(targetDate?: Date): number {
  if (typeof window === 'undefined') return 0;
  
  const history = loadFromLocalStorage<ExchangeRateEntry[]>(KEYS.EXCHANGE_RATE_HISTORY, false);

  if (!Array.isArray(history) || history.length === 0) {
    const legacyRate = localStorage.getItem(KEYS.EXCHANGE_RATE);
    return legacyRate ? parseFloat(legacyRate) : 0;
  }
  
  const searchDate = targetDate || new Date();
  const searchDateStr = formatDateFns(searchDate, "yyyy-MM-dd");

  const exactMatch = history.find(entry => entry.date === searchDateStr);
  if (exactMatch) {
    return exactMatch.rate;
  }

  // Find the most recent entry on or before the targetDate
  const olderEntry = history.find(entry => entry.date <= searchDateStr);
  
  if (olderEntry) {
    return olderEntry.rate;
  }
  
  return 0; // Return 0 if no suitable rate is found
}


export function initializeRawMaterialOptions(): string[] { // Global
  let storedOptions = loadFromLocalStorage<string[]>(KEYS.RAW_MATERIAL_OPTIONS);
  const defaultSampleOptions: string[] = [];

  if (!Array.isArray(storedOptions)) {
    rawMaterialOptions = [...defaultSampleOptions].sort((a, b) => a.localeCompare(b));
  } else {
    const validStoredOptions = storedOptions.filter(opt => typeof opt === 'string' && opt.trim() !== '');
    const mergedOptions = [...new Set([...validStoredOptions, ...defaultSampleOptions])];
    rawMaterialOptions = mergedOptions.sort((a, b) => a.localeCompare(b));
  }
  saveToLocalStorage<string[]>(KEYS.RAW_MATERIAL_OPTIONS, rawMaterialOptions);
  return rawMaterialOptions;
}

export function getCurrentRawMaterialOptions(): string[] { // Global
  return [...rawMaterialOptions];
}

export function saveRawMaterialOptionsData(options: string[]): void { // Global
  const uniqueSortedOptions = [...new Set(options.filter(opt => typeof opt === 'string' && opt.trim() !== ''))].sort((a, b) => a.localeCompare(b));
  rawMaterialOptions = uniqueSortedOptions;
  saveToLocalStorage<string[]>(KEYS.RAW_MATERIAL_OPTIONS, rawMaterialOptions);
}

export function addRawMaterialOption(option: string): boolean { // Global
  const trimmedOption = option.trim();
  if (trimmedOption && !rawMaterialOptions.find(o => o.toLowerCase() === trimmedOption.toLowerCase())) {
    const updatedOptions = [...rawMaterialOptions, trimmedOption];
    saveRawMaterialOptionsData(updatedOptions);
    return true;
  }
  return false;
}

export function removeRawMaterialOption(optionToRemove: string): void { // Global
  const initialLength = rawMaterialOptions.length;
  const trimmedOptionToRemove = optionToRemove.trim().toLowerCase();
  const updatedOptions = rawMaterialOptions.filter(option => option.toLowerCase().trim() !== trimmedOptionToRemove);

  if (updatedOptions.length < initialLength) {
    saveRawMaterialOptionsData(updatedOptions);
  }
}

export function loadRawMaterialInventoryData(branchIdToLoad?: string): RawMaterialInventoryItem[] {
  const branchId = branchIdToLoad || getActiveBranchId();
  if (!branchId) {
    console.error("loadRawMaterialInventoryData: No branchId and no active branch.");
    return [];
  }
  let inventory = loadFromLocalStorageForBranch<RawMaterialInventoryItem[]>(KEYS.RAW_MATERIAL_INVENTORY, branchId);
  inventory = Array.isArray(inventory) ? inventory : [];
  const aggregatedInventory = filterAndAggregateInventoryItems(inventory);
  if (branchId === getActiveBranchId()) {
    rawMaterialInventoryData = aggregatedInventory;
  }
  return aggregatedInventory;
}


function filterAndAggregateInventoryItems(data: RawMaterialInventoryItem[]): RawMaterialInventoryItem[] {
  if (!Array.isArray(data)) {
    console.warn("filterAndAggregateInventoryItems: received non-array data. Returning empty array.", data);
    return [];
  }
  const uniqueDataMap = new Map<string, RawMaterialInventoryItem>();
  for (const item of data) {
    if (!item || !item.name || typeof item.quantity !== 'number' || !item.unit) continue;

    const { quantity: baseQuantity, unit: baseUnit } = convertMaterialToBaseUnit(
      item.quantity,
      item.unit,
      item.name
    );
    
    if (!VALID_BASE_UNITS.includes(baseUnit)) {
      // console.warn(`Ítem de inventario con unidad base resultante inválida '${baseUnit}' para '${item.name}' será ignorado al agregar/guardar.`);
      continue;
    }
    
    const key = `${item.name.toLowerCase().trim()}-${baseUnit}`;
    const currentEntry = uniqueDataMap.get(key);
    if (currentEntry) {
      currentEntry.quantity += Number(baseQuantity);
    } else {
      uniqueDataMap.set(key, { ...item, name: item.name.trim(), unit: baseUnit, quantity: Number(baseQuantity) });
    }
  }
  return Array.from(uniqueDataMap.values())
    .map(item => ({ ...item, quantity: Number(Number(item.quantity).toFixed(4)) }))
    .filter(item => item.quantity > 0.0001);
}


export function saveRawMaterialInventoryData(branchIdToSave: string, data: RawMaterialInventoryItem[]): void {
  if (!branchIdToSave) {
    console.error("saveRawMaterialInventoryData: No branchId provided.");
    return;
  }
  const aggregatedData = filterAndAggregateInventoryItems(data);
  saveToLocalStorageForBranch<RawMaterialInventoryItem[]>(KEYS.RAW_MATERIAL_INVENTORY, branchIdToSave, aggregatedData);
  if (branchIdToSave === getActiveBranchId()) {
    rawMaterialInventoryData = aggregatedData;
  }
}


export function loadAllProductsFromAllBranches(): Product[] { // Global
  const allProductsCombined: Product[] = [];
  availableBranches.forEach(branch => {
    const branchProducts = loadFromLocalStorageForBranch<Product[]>(KEYS.PRODUCTS, branch.id);
    if (Array.isArray(branchProducts)) {
      branchProducts.forEach(p => {
        allProductsCombined.push({ ...p, sourceBranchId: branch.id, sourceBranchName: branch.name });
      });
    }
  });
  return allProductsCombined.sort((a, b) => a.name.localeCompare(b.name));
}

export function loadProductsForBranch(branchId: string): Product[] { // Specific Branch
  return loadFromLocalStorageForBranch<Product[]>(KEYS.PRODUCTS, branchId);
}
export function saveProductsDataForBranch(branchId: string, data: Product[]): void { // Specific Branch
  saveToLocalStorageForBranch<Product[]>(KEYS.PRODUCTS, branchId, data);
  if (getActiveBranchId() === branchId) {
    productsData = data;
  }
}


export function loadPurchaseOrdersFromStorage(branchId?: string): PurchaseOrder[] { // For specific or active branch
  const idToLoad = branchId || getActiveBranchId();
  if (!idToLoad) {
    console.error("loadPurchaseOrdersFromStorage: Branch ID not provided and no active branch.");
    return [];
  }
  const loaded = loadFromLocalStorageForBranch<PurchaseOrder[]>(KEYS.PURCHASE_ORDERS, idToLoad);
  return Array.isArray(loaded) ? loaded : [];
}

export interface PricePointInfo {
  supplierId: string;
  supplierName: string;
  pricePerBaseUnit: number;
  baseUnit: string;
  originalUnitPrice: number;
  originalUnit: string;
  lastUpdated: string;
}

export function getCurrentPriceFromHistory(priceHistory: PriceHistoryEntry[] | undefined): PriceHistoryEntry | null {
  if (!priceHistory || priceHistory.length === 0) return null;
  return priceHistory.sort((a, b) => compareDesc(parseISO(a.date), parseISO(b.date)))[0];
}

function getPricePointInfoForStrategy(
  rawMaterialName: string,
  strategy: 'lowest' | 'highest' = 'lowest',
  targetPriceListType?: 'default' | 'usdCash'
): PricePointInfo | null {
  let optimalPricePoint: PricePointInfo | null = null;

  suppliersData.forEach(supplier => {
    const listToUse = targetPriceListType === 'usdCash' ? supplier.priceListUSDCash : supplier.priceList;
    if (!listToUse) return;

    listToUse.forEach(priceItem => {
      if (priceItem.rawMaterialName.toLowerCase() === rawMaterialName.toLowerCase()) {
        const currentPriceEntry = getCurrentPriceFromHistory(priceItem.priceHistory);
        if (!currentPriceEntry) return;

        const conversionResult = convertMaterialToBaseUnit(1, priceItem.unit, rawMaterialName);
        if (!VALID_BASE_UNITS.includes(conversionResult.unit)) return;

        const baseUnitsPerPurchaseUnit = conversionResult.quantity;
        const baseUnitForComparison = conversionResult.unit;

        if (baseUnitsPerPurchaseUnit > 0 && currentPriceEntry.price >= 0) {
          const currentPricePerBaseUnit = currentPriceEntry.price / baseUnitsPerPurchaseUnit;

          if (optimalPricePoint === null ||
              (strategy === 'lowest' && currentPricePerBaseUnit < optimalPricePoint.pricePerBaseUnit) ||
              (strategy === 'highest' && currentPricePerBaseUnit > optimalPricePoint.pricePerBaseUnit) ||
              (currentPricePerBaseUnit === optimalPricePoint.pricePerBaseUnit && new Date(currentPriceEntry.date) > new Date(optimalPricePoint.lastUpdated))
          ) {
            optimalPricePoint = {
              supplierId: supplier.id,
              supplierName: supplier.name,
              pricePerBaseUnit: currentPricePerBaseUnit,
              baseUnit: baseUnitForComparison,
              originalUnitPrice: currentPriceEntry.price,
              originalUnit: priceItem.unit,
              lastUpdated: currentPriceEntry.date,
            };
          }
        }
      }
    });
  });
  return optimalPricePoint;
}

export function getLowestPriceInfo(rawMaterialName: string, targetPriceListType?: 'default' | 'usdCash'): PricePointInfo | null {
  return getPricePointInfoForStrategy(rawMaterialName, 'lowest', targetPriceListType);
}

export function getHighestPriceInfo(rawMaterialName: string, targetPriceListType?: 'default' | 'usdCash'): PricePointInfo | null {
  return getPricePointInfoForStrategy(rawMaterialName, 'highest', targetPriceListType);
}

export function getBestPriceInfo(rawMaterialName: string, targetPriceListType?: 'default' | 'usdCash'): PricePointInfo | null {
 return getPricePointInfoForStrategy(rawMaterialName, 'lowest', targetPriceListType || 'default');
}

export function calculatePackagingCost(quantity: number): { minCost: number; maxCost: number } {
  if (quantity <= 0) {
    return { minCost: 0, maxCost: 0 };
  }

  const packagingMaterials = ["Bolsas", "Etiquetas"];
  let totalMinCost = 0;
  let totalMaxCost = 0;

  packagingMaterials.forEach(material => {
    const lowestPrice = getLowestPriceInfo(material);
    const highestPrice = getHighestPriceInfo(material);

    let minItemCost = 0;
    let maxItemCost = 0;

    if (lowestPrice && normalizeUnit(lowestPrice.baseUnit) === 'unidad') {
      minItemCost = lowestPrice.pricePerBaseUnit;
    }
    if (highestPrice && normalizeUnit(highestPrice.baseUnit) === 'unidad') {
      maxItemCost = highestPrice.pricePerBaseUnit;
    }

    totalMinCost += quantity * (minItemCost > 0 ? minItemCost : maxItemCost > 0 ? maxItemCost : 0);
    totalMaxCost += quantity * (maxItemCost > 0 ? maxItemCost : minItemCost > 0 ? minItemCost : 0);
  });
  
  return { minCost: totalMinCost, maxCost: totalMaxCost };
}


export const updateSupplierPriceList = (order: PurchaseOrder) => { // Global
  if (!order.supplierId || order.status !== 'Pagado') return;

  let currentSuppliersList = [...suppliersData];
  const supplierIndex = currentSuppliersList.findIndex(s => s.id === order.supplierId);

  if (supplierIndex !== -1) {
    const supplierToUpdate = { ...currentSuppliersList[supplierIndex] };
    let priceListChanged = false;
    
    order.paymentSplits?.forEach(split => {
        const targetPriceListName = split.paymentMethod === 'Efectivo USD' ? 'priceListUSDCash' : 'priceList';
        let targetPriceList = supplierToUpdate[targetPriceListName] ? [...(supplierToUpdate[targetPriceListName]!)] : [];

        split.items?.forEach(orderItem => {
            if (orderItem.rawMaterialName && orderItem.unit && Number(orderItem.unitPrice) >= 0) {
                const priceItemIndex = targetPriceList.findIndex(
                    pli => pli.rawMaterialName === orderItem.rawMaterialName && pli.unit === orderItem.unit
                );
                const orderDateToUse = order.timestamp ? formatDateFns(parseISO(order.timestamp), "yyyy-MM-dd") : order.orderDate;


                if (priceItemIndex !== -1) {
                    const priceListItem = { ...targetPriceList[priceItemIndex] };
                    priceListItem.priceHistory = priceListItem.priceHistory ? [...priceListItem.priceHistory] : [];
                    
                    const existingHistoryEntryIndex = priceListItem.priceHistory.findIndex(entry => entry.date === orderDateToUse);

                    if (existingHistoryEntryIndex !== -1) {
                        if (priceListItem.priceHistory[existingHistoryEntryIndex].price !== Number(orderItem.unitPrice)) {
                            priceListItem.priceHistory[existingHistoryEntryIndex].price = Number(orderItem.unitPrice);
                            priceListChanged = true;
                        }
                    } else {
                        priceListItem.priceHistory.push({ date: orderDateToUse, price: Number(orderItem.unitPrice) });
                        priceListChanged = true;
                    }
                    priceListItem.priceHistory.sort((a,b) => compareDesc(parseISO(a.date), parseISO(b.date)));
                    targetPriceList[priceItemIndex] = priceListItem;
                } else {
                    targetPriceList.push({
                        id: `spl-${order.supplierId}-${targetPriceListName}-${orderItem.rawMaterialName.replace(/\s+/g, '')}-${Date.now()}`,
                        rawMaterialName: orderItem.rawMaterialName,
                        unit: orderItem.unit,
                        priceHistory: [{ date: orderDateToUse, price: Number(orderItem.unitPrice) }],
                    });
                    priceListChanged = true;
                }
            }
        });
        supplierToUpdate[targetPriceListName] = targetPriceList;
    });


    if (priceListChanged) {
      currentSuppliersList[supplierIndex] = supplierToUpdate;
      saveSuppliersData(currentSuppliersList);
    }
  }
};

export const updateCompanyAccountAndExpensesForPO = (
  order: PurchaseOrder,
  operation: 'add' | 'subtract',
  currentGlobalRate: number,
  originalOrder?: PurchaseOrder
) => {
  const activeBranchIdForPO = getActiveBranchId();
  if (!activeBranchIdForPO) {
    console.error("updateCompanyAccountAndExpensesForPO: No active branch for PO finances.");
    return;
  }

  let companyAccountsForBranch = loadCompanyAccountsData(activeBranchIdForPO);
  let accountTransactionsForBranch = loadFromLocalStorageForBranch<AccountTransaction[]>(KEYS.ACCOUNT_TRANSACTIONS, activeBranchIdForPO);
  let expensesForBranch = loadFromLocalStorageForBranch<Expense[]>(KEYS.EXPENSES, activeBranchIdForPO);

  const processSplits = (splits: PaymentSplit[], op: 'add' | 'subtract') => {
    splits.forEach(split => {
      const accountIdForTx = split.paidToAccountId;
      const accountUsed = companyAccountsForBranch[accountIdForTx];

      if (!accountUsed) {
        console.error(`Error: Account ${accountTypeNames[accountIdForTx]} not found for split in branch ${activeBranchIdForPO}.`);
        return; // Skip this split if account not found
      }

      let transactionAmountInAccountCurrency = split.amount;
      let amountOfSplitInUSD = 0; // Será el total de items del split en USD
      
      if (split.items && split.items.length > 0) {
          amountOfSplitInUSD = split.items.reduce((sum, item) => sum + (item.subtotal || 0), 0);
      } else if (op === 'subtract' && originalOrder && originalOrder.paymentSplits) {
          // Para revertir, si el split original no tenía items (legado), usar el 'amount' del split
          const originalSplit = originalOrder.paymentSplits.find(os => os.id === split.id);
          if (originalSplit?.currency === 'USD') {
            amountOfSplitInUSD = originalSplit.amount;
          } else if (originalSplit?.currency === 'VES') {
            const rateForRevert = originalSplit.exchangeRateAtPayment || currentGlobalRate;
            amountOfSplitInUSD = rateForRevert > 0 ? originalSplit.amount / rateForRevert : 0;
          }
      }


      let amountInOtherCurrencyForTx: number | undefined = undefined;


      if (accountUsed.currency === 'VES') {
        if (currentGlobalRate <= 0) {
            console.warn(`OC ${order.id}, pago desde cuenta VES sin tasa de cambio válida. El monto de la transacción será 0.`);
            transactionAmountInAccountCurrency = 0;
        } else {
            transactionAmountInAccountCurrency = amountOfSplitInUSD * currentGlobalRate;
        }
        amountInOtherCurrencyForTx = amountOfSplitInUSD;
      } else { // La cuenta es USD
        transactionAmountInAccountCurrency = amountOfSplitInUSD;
        if (currentGlobalRate > 0) {
          amountInOtherCurrencyForTx = amountOfSplitInUSD * currentGlobalRate;
        }
      }


      if (op === 'add') {
        const newAccountTx: AccountTransaction = {
          id: `TRN-POC-SPLIT-${order.id}-${split.id.slice(-4)}-${Date.now().toString().slice(-3)}`,
          date: order.orderDate,
          description: `Pago OC: ${order.supplierName}, OC#: ${order.id} (Método: ${split.paymentMethod}, Ref: ${split.referenceNumber || 'N/A'})`,
          type: 'egreso',
          accountId: accountIdForTx,
          amount: parseFloat(transactionAmountInAccountCurrency.toFixed(2)),
          currency: accountUsed.currency,
          exchangeRateOnTransactionDate: currentGlobalRate > 0 ? currentGlobalRate : undefined,
          amountInOtherCurrency: amountInOtherCurrencyForTx ? parseFloat(amountInOtherCurrencyForTx.toFixed(2)) : undefined,
          category: 'Compra de Materia Prima',
          sourceModule: 'Compra de Materia Prima',
          sourceId: order.id,
          timestamp: order.timestamp || new Date().toISOString(),
        };
        accountUsed.balance = parseFloat((accountUsed.balance - transactionAmountInAccountCurrency).toFixed(2));
        newAccountTx.balanceAfterTransaction = accountUsed.balance;
        accountUsed.lastTransactionDate = order.timestamp || new Date().toISOString();
        accountTransactionsForBranch = [newAccountTx, ...accountTransactionsForBranch];
      } else { 
        const originalTxIndex = accountTransactionsForBranch.findIndex(tx =>
            tx.sourceId === order.id &&
            tx.sourceModule === 'Compra de Materia Prima' &&
            tx.accountId === accountIdForTx &&
            (
                (tx.currency === 'VES' && tx.amountInOtherCurrency && Math.abs(tx.amountInOtherCurrency - amountOfSplitInUSD) < 0.01) ||
                (tx.currency === 'USD' && Math.abs(tx.amount - amountOfSplitInUSD) < 0.01)
            ) &&
            tx.description.includes(`(Método: ${split.paymentMethod}`)
        );

        if (originalTxIndex !== -1) {
          const originalTx = accountTransactionsForBranch[originalTxIndex];
          accountUsed.balance = parseFloat((accountUsed.balance + originalTx.amount).toFixed(2));
          // No actualizar lastTransactionDate aquí al eliminar
          accountTransactionsForBranch.splice(originalTxIndex, 1);
        }
      }
    });
  };

  if (operation === 'add' && order.status === 'Pagado' && order.paymentSplits && order.paymentSplits.length > 0) {
    processSplits(order.paymentSplits, 'add');
    const newExpenseEntry: Expense = {
      id: `EXP-PO-${order.id}`, date: order.orderDate, category: 'Compra de Materia Prima', mainCategoryType: 'Variable',
      description: `Compra a ${order.supplierName}, OC#: ${order.id}`,
      amount: order.totalCost, paidTo: order.supplierName,
      sourceModule: 'Compra de Materia Prima', sourceId: order.id,
      timestamp: order.timestamp || new Date().toISOString(),
      paymentAccountId: order.paymentSplits[0]?.paidToAccountId // Asignar la cuenta del primer split como referencia para el gasto
    };
    expensesForBranch = [newExpenseEntry, ...expensesForBranch];

  } else if (operation === 'subtract' && originalOrder && originalOrder.status === 'Pagado' && originalOrder.paymentSplits && originalOrder.paymentSplits.length > 0) {
    processSplits(originalOrder.paymentSplits, 'subtract');
    expensesForBranch = expensesForBranch.filter(exp => !(exp.sourceId === originalOrder.id && exp.sourceModule === 'Compra de Materia Prima'));
  }


  saveAccountTransactionsData(activeBranchIdForPO, accountTransactionsForBranch);
  saveCompanyAccountsData(activeBranchIdForPO, companyAccountsForBranch);
  saveExpensesData(activeBranchIdForPO, expensesForBranch);
};


export const updateRawMaterialInventoryFromOrder = (
  order: PurchaseOrder,
  operation: 'add' | 'subtract'
) => {
  const activeBranchIdForPO = getActiveBranchId();
  if (!activeBranchIdForPO) {
    console.error("updateRawMaterialInventoryFromOrder: No active branch ID. Cannot update inventory.");
    return;
  }

  let branchInventory = loadRawMaterialInventoryData(activeBranchIdForPO);
  const itemsToProcess = order.status === 'Pagado' && order.paymentSplits && order.paymentSplits.length > 0
    ? order.paymentSplits.flatMap(split => split.items || [])
    : order.items;

  itemsToProcess.forEach(item => {
    if (item.rawMaterialName && item.quantity > 0 && item.unit) {
      const { quantity: baseQuantity, unit: baseUnit } = convertMaterialToBaseUnit(item.quantity, item.unit, item.rawMaterialName);
      if (!VALID_BASE_UNITS.includes(baseUnit)) {
        console.warn(`Unidad base inválida '${baseUnit}' para ${item.rawMaterialName} en OC ${order.id}. Saltando.`);
        return;
      }

      const itemIndex = branchInventory.findIndex(
        invItem => invItem.name.toLowerCase() === item.rawMaterialName.toLowerCase() &&
                   normalizeUnit(invItem.unit) === normalizeUnit(baseUnit)
      );

      if (operation === 'add') {
        if (itemIndex !== -1) {
          branchInventory[itemIndex].quantity += baseQuantity;
        } else {
          branchInventory.push({ name: item.rawMaterialName, quantity: baseQuantity, unit: baseUnit });
        }
      } else { // 'subtract'
        if (itemIndex !== -1) {
          branchInventory[itemIndex].quantity -= baseQuantity;
          if (branchInventory[itemIndex].quantity < 0.0001) {
            // No eliminar si es < 0.0001, pero mantener como 0 si se quiere.
            // O filtrar después como ya se hace.
            branchInventory[itemIndex].quantity = 0; 
          }
        } else {
          console.warn(`Attempted to subtract ${item.rawMaterialName} which is not in inventory for branch ${activeBranchIdForPO} during order operation.`);
        }
      }
    }
  });

  branchInventory = branchInventory.filter(item => item.quantity > 0.0001); // Limpiar ítems con cantidad cero o insignificante
  saveRawMaterialInventoryData(activeBranchIdForPO, branchInventory);
};

export function calculateDynamicRecipeCost(
  recipeId: string,
  priceStrategy: 'lowest' | 'highest',
  allRecipesDataLocal?: Recipe[]
): number {
  const recipesToUse = allRecipesDataLocal;
  if (!recipesToUse || recipesToUse.length === 0) {
    return 0;
  }
  const recipe = recipesToUse.find(r => r.id === recipeId);
  if (!recipe) return 0;

  let totalCostOfIngredients = 0;
  const ingredients: RecipeIngredientItem[] = Array.isArray(recipe.ingredients) ? recipe.ingredients : [];

  for (const ingredient of ingredients) {
    const subRecipe = recipesToUse.find(r => r.name.toLowerCase() === ingredient.name.toLowerCase() && r.isIntermediate);
    let ingredientCost = 0;
    if (subRecipe && subRecipe.id) {
      const costOfEntireSubRecipeTanda = calculateDynamicRecipeCost(subRecipe.id, priceStrategy, recipesToUse);
      const yieldOfSubRecipeTanda = subRecipe.expectedYield && subRecipe.expectedYield > 0 ? subRecipe.expectedYield : 1;
      const costPerOutputUnitOfSubRecipe = yieldOfSubRecipeTanda > 0 ? costOfEntireSubRecipeTanda / yieldOfSubRecipeTanda : costOfEntireSubRecipeTanda;
      const { quantity: requiredIngredientInSubRecipeBaseUnit, unit: requiredIngredientUnitBase } = convertMaterialToBaseUnit(ingredient.quantity, ingredient.unit, ingredient.name);
      const subRecipeOutputBaseUnit = normalizeUnit(subRecipe.outputUnit || (subRecipe.name.toLowerCase().includes("melado") || subRecipe.name.toLowerCase().includes("jarabe") ? "l" : "kg"));
      if (requiredIngredientUnitBase.toLowerCase() === subRecipeOutputBaseUnit.toLowerCase()) {
        ingredientCost = costPerOutputUnitOfSubRecipe * requiredIngredientInSubRecipeBaseUnit;
      } else { ingredientCost = 0; }
    } else {
      const priceDetails = priceStrategy === 'lowest' ? getLowestPriceInfo(ingredient.name) : getHighestPriceInfo(ingredient.name);
      if (priceDetails) {
        const { quantity: ingredientQuantityInBase, unit: ingredientUnitInBase } = convertMaterialToBaseUnit(ingredient.quantity, ingredient.unit, ingredient.name);
        if (ingredientUnitInBase.toLowerCase() === priceDetails.baseUnit.toLowerCase()) {
          ingredientCost = ingredientQuantityInBase * priceDetails.pricePerBaseUnit;
        } else { ingredientCost = 0; }
      } else { ingredientCost = 0; }
    }
    totalCostOfIngredients += ingredientCost;
  }
  
  // This now returns the TOTAL cost of the batch, not per unit.
  // Per-unit calculation will be done where needed.
  return totalCostOfIngredients;
}


export interface AggregatedRawMaterial { name: string; quantity: number; unit: string; }

export function getRawMaterialsForProductQuantity(
  productName: string,
  quantityToProduce: number,
  allRecipes: Recipe[]
): AggregatedRawMaterial[] {
  const currentBranchId = getActiveBranchId();
  if (!currentBranchId) {
    console.error("getRawMaterialsForProductQuantity: No active branch ID.");
    return [];
  }
  const recipesForBranch = allRecipes.length > 0 ? allRecipes : loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, currentBranchId);
  const productRecipe = recipesForBranch.find(r => r.name.toLowerCase() === productName.toLowerCase());

  if (!productRecipe) { console.warn(`Receta no encontrada para: ${productName}`); return []; }

  const recipeMultiplier = quantityToProduce / (productRecipe.expectedYield || 1);
  if (isNaN(recipeMultiplier) || recipeMultiplier <= 0) { console.warn(`Multiplicador de receta inválido para ${productName}`); return []; }

  const aggregatedMaterialsMap = new Map<string, AggregatedRawMaterial>();

  function processIngredients(currentRecipeId: string, currentMultiplier: number) {
    const recipe = recipesForBranch.find(r => r.id === currentRecipeId);
    if (!recipe || !Array.isArray(recipe.ingredients)) return;
    const recipeIngredients = recipe.ingredients;

    for (const ingredient of recipeIngredients) {
      const subRecipe = recipesForBranch.find(r => r.name.toLowerCase() === ingredient.name.toLowerCase() && r.isIntermediate);
      const requiredIngredientQuantityTotal = ingredient.quantity * currentMultiplier;

      if (subRecipe && subRecipe.id) {
        const subRecipeYield = subRecipe.expectedYield || 1;
        const subRecipeBatchesNeeded = requiredIngredientQuantityTotal / subRecipeYield;
        processIngredients(subRecipe.id, subRecipeBatchesNeeded);
      } else {
        const { quantity: baseQuantity, unit: baseUnit } = convertMaterialToBaseUnit(
          requiredIngredientQuantityTotal, ingredient.unit, ingredient.name
        );
        if (VALID_BASE_UNITS.includes(baseUnit)) {
          const key = `${ingredient.name.toLowerCase().trim()}-${baseUnit}`;
          const existing = aggregatedMaterialsMap.get(key);
          if (existing) {
            existing.quantity += baseQuantity;
          } else {
            aggregatedMaterialsMap.set(key, { name: ingredient.name, quantity: baseQuantity, unit: baseUnit });
          }
        } else { console.warn(`Unidad base no válida '${baseUnit}' para ingrediente '${ingredient.name}'.`); }
      }
    }
  }
  processIngredients(productRecipe.id, recipeMultiplier);
  return Array.from(aggregatedMaterialsMap.values()).map(item => ({
    ...item, quantity: parseFloat(item.quantity.toFixed(4))
  })).filter(item => item.quantity > 0.0001);
}

export function getDirectIngredientsForRecipe(
  productName: string,
  batchMultiplier: number,
  allRecipes: Recipe[]
): DirectIngredient[] {
  const currentBranchId = getActiveBranchId();
  if (!currentBranchId) {
    console.error("getDirectIngredientsForRecipe: No active branch ID.");
    return [];
  }
  const recipesForBranch = allRecipes.length > 0 ? allRecipes : loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, currentBranchId);
  const recipe = recipesForBranch.find(r => r.name.toLowerCase() === productName.toLowerCase());

  if (!recipe) { console.warn(`getDirectIngredientsForRecipe: Receta no encontrada para: ${productName}`); return []; }
  const recipeIngredientsArray: RecipeIngredientItem[] = Array.isArray(recipe.ingredients) ? recipe.ingredients : [];
  if (recipeIngredientsArray.length === 0) return [];

  const directIngredients: DirectIngredient[] = [];
  for (const ingredient of recipeIngredientsArray) {
    const subRecipe = recipesForBranch.find(r => r.name.toLowerCase() === ingredient.name.toLowerCase() && r.isIntermediate);
    const scaledIngredientQuantity = ingredient.quantity * batchMultiplier;
    if (subRecipe) {
      const outputUnit = normalizeUnit(subRecipe.outputUnit || (subRecipe.name.toLowerCase().includes("melado") || subRecipe.name.toLowerCase().includes("jarabe") ? "l" : "kg"));
      directIngredients.push({
        name: subRecipe.name, quantity: scaledIngredientQuantity, unit: outputUnit,
        isIntermediate: true, originalRecipeUnit: ingredient.unit
      });
    } else {
      const { quantity: baseQuantity, unit: baseUnit } = convertMaterialToBaseUnit(scaledIngredientQuantity, ingredient.unit, ingredient.name);
      directIngredients.push({
        name: ingredient.name, quantity: baseQuantity, unit: baseUnit,
        isIntermediate: false, originalRecipeUnit: ingredient.unit
      });
    }
  }
  return directIngredients;
}

export interface GoalIngredientsAndCost {
  ingredientsList: AggregatedRawMaterial[];
  totalCostMinUSD: number;
  totalCostMaxUSD: number;
  missingPriceInfoForMaterials: string[];
}

export function calculateTotalIngredientsAndCostForGoal(
  goal: ProductionGoal,
  allRecipesDataLocal: Recipe[]
): GoalIngredientsAndCost {
  const ingredientsList = getRawMaterialsForProductQuantity(
    goal.product, goal.target, allRecipesDataLocal
  );
  let totalCostMinUSD = 0; let totalCostMaxUSD = 0; const missingPriceInfoForMaterials: string[] = [];
  for (const material of ingredientsList) {
    const lowestPrice = getLowestPriceInfo(material.name); const highestPrice = getHighestPriceInfo(material.name); // Proveedores globales
    let minItemCost = 0; let maxItemCost = 0; let priceFound = false;
    if (lowestPrice && normalizeUnit(lowestPrice.baseUnit) === normalizeUnit(material.unit)) {
      minItemCost = material.quantity * lowestPrice.pricePerBaseUnit; priceFound = true;
    }
    if (highestPrice && normalizeUnit(highestPrice.baseUnit) === normalizeUnit(material.unit)) {
      maxItemCost = material.quantity * highestPrice.pricePerBaseUnit; priceFound = true;
    }
    if (priceFound) {
      totalCostMinUSD += (minItemCost > 0 ? minItemCost : (maxItemCost > 0 ? maxItemCost : 0));
      totalCostMaxUSD += (maxItemCost > 0 ? maxItemCost : (minItemCost > 0 ? minItemCost : 0));
    } else if (material.quantity > 0) { missingPriceInfoForMaterials.push(material.name); }
  }
  return { ingredientsList, totalCostMinUSD, totalCostMaxUSD, missingPriceInfoForMaterials };
}

// --- Save Functions for Each Data Type ---
// Branch-specific saves
export function saveProductsData(data: Product[]): void {
  const activeBranchId = getActiveBranchId();
  if (!activeBranchId) return;
  productsData = data;
  saveToLocalStorageForBranch<Product[]>(KEYS.PRODUCTS, activeBranchId, data);
}
export function saveProductionLogData(data: ProductionLogEntry[]): void {
  const activeBranchId = getActiveBranchId();
  if (!activeBranchId) return;
  productionLogData = data;
  saveToLocalStorageForBranch<ProductionLogEntry[]>(KEYS.PRODUCTION_LOG, activeBranchId, data);
}
export function saveRecipesData(data: Recipe[]): void {
  const activeBranchId = getActiveBranchId();
  if (!activeBranchId) return;
  recipesData = data.map(r => ({...r})).sort((a, b) => a.name.localeCompare(b.name));
  saveToLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, activeBranchId, data);
}

export function savePurchaseOrdersData(branchId: string, data: PurchaseOrder[]): void {
  if (!branchId) {
      console.error("savePurchaseOrdersData: No branchId provided.");
      return;
  }
  saveToLocalStorageForBranch<PurchaseOrder[]>(KEYS.PURCHASE_ORDERS, branchId, data);
  if (branchId === getActiveBranchId()) {
    purchaseOrdersData = data;
  }
}
export function saveWeeklyGoalsData(data: ProductionGoal[]): void {
  const activeBranchId = getActiveBranchId();
  if (!activeBranchId) return;
  weeklyGoalsData = data;
  saveToLocalStorageForBranch<ProductionGoal[]>(KEYS.WEEKLY_GOALS, activeBranchId, data);
}
export function saveMonthlyGoalsData(data: ProductionGoal[]): void {
  const activeBranchId = getActiveBranchId();
  if (!activeBranchId) return;
  monthlyGoalsData = data;
  saveToLocalStorageForBranch<ProductionGoal[]>(KEYS.MONTHLY_GOALS, activeBranchId, data);
}

export function saveAccountTransactionsData(branchIdToSave: string, data: AccountTransaction[]): void {
  if (!branchIdToSave) {
    console.error("saveAccountTransactionsData: No branchId provided.");
    return;
  }
  const sortedData = [...data].sort((a, b) => {
    const dateA = a.date && isValid(parseISO(a.date)) ? parseISO(a.date) : new Date(0);
    const dateB = b.date && isValid(parseISO(b.date)) ? parseISO(b.date) : new Date(0);
    const dayA = new Date(dateA.getFullYear(), dateA.getMonth(), dateA.getDate()).getTime();
    const dayB = new Date(dateB.getFullYear(), dateB.getMonth(), dateB.getDate()).getTime();
    if (dayB !== dayA) return dayB - dayA;
    const timestampAValue = a.timestamp && isValid(parseISO(a.timestamp)) ? parseISO(a.timestamp).getTime() : 0;
    const timestampBValue = b.timestamp && isValid(parseISO(b.timestamp)) ? parseISO(b.timestamp).getTime() : 0;
    if (timestampBValue !== timestampAValue) return timestampBValue - timestampAValue;
    return (b.id || '').localeCompare(a.id || '');
  });
  saveToLocalStorageForBranch<AccountTransaction[]>(KEYS.ACCOUNT_TRANSACTIONS, branchIdToSave, sortedData);
}

// Global saves (Proveedores, Opciones de MP)
export function saveSuppliersData(data: Supplier[]): void {
  // Ensure priceListUSDCash is initialized if missing for any supplier during save
  const suppliersWithInitializedUSDCashList = data.map(supplier => ({
    ...supplier,
    priceList: Array.isArray(supplier.priceList) ? supplier.priceList : [],
    priceListUSDCash: Array.isArray(supplier.priceListUSDCash) ? supplier.priceListUSDCash : [],
  }));
  suppliersData = suppliersWithInitializedUSDCashList;
  saveToLocalStorage<Supplier[]>(KEYS.SUPPLIERS, suppliersData);
}


// Branch-specific saves for Employees and Expenses
export function saveEmployeesData(branchIdToSave: string, data: Employee[]): void {
  if (!branchIdToSave) {
    console.error("saveEmployeesData: No branchId provided.");
    return;
  }
  if (branchIdToSave === getActiveBranchId()) {
    employeesData = data;
  }
  saveToLocalStorageForBranch<Employee[]>(KEYS.EMPLOYEES, branchIdToSave, data);
}

export function saveExpensesData(branchIdToSave: string, data: Expense[]): void {
  if (!branchIdToSave) {
    console.error("saveExpensesData: No branchId provided.");
    return;
  }
  if (branchIdToSave === getActiveBranchId()) {
    expensesData = data;
  }
  saveToLocalStorageForBranch<Expense[]>(KEYS.EXPENSES, branchIdToSave, data);
}


export function saveSalesData(data: Sale[]): void {
  const validatedSales = data.map(sale => ({
    ...sale,
    amountPaidUSD: typeof sale.amountPaidUSD === 'number' ? sale.amountPaidUSD : 0,
    itemsPerBranch: Array.isArray(sale.itemsPerBranch) ? sale.itemsPerBranch.map(branchDetail => ({
        ...branchDetail,
        amountPaidUSD: typeof branchDetail.amountPaidUSD === 'number' ? branchDetail.amountPaidUSD : 0,
        totalAmount: typeof branchDetail.totalAmount === 'number' ? branchDetail.totalAmount : 0,
        items: Array.isArray(branchDetail.items) ? branchDetail.items : []
    })) : [],
  }));
  salesData = validatedSales;
  saveToLocalStorage<Sale[]>(KEYS.SALES, salesData);
}
export function saveCustomersData(data: Customer[]): void {
  const uniqueCustomersMap = new Map<string, Customer>();
  for (const customer of data) {
    if (customer && customer.id) {
      const customerToSave = { ...customer };
      uniqueCustomersMap.set(customer.id, customerToSave as Customer);
    }
  }
  customersData = Array.from(uniqueCustomersMap.values());
  saveToLocalStorage<Customer[]>(KEYS.CUSTOMERS, customersData);
}
export function savePaymentsData(data: Payment[]): void {
  paymentsData = data;
  saveToLocalStorage<Payment[]>(KEYS.PAYMENTS, data);
}
export function saveInventoryTransfersData(data: InventoryTransfer[]): void { inventoryTransfersData = data; saveToLocalStorage<InventoryTransfer[]>(KEYS.INVENTORY_TRANSFERS, data); }
export function savePendingFundTransfersData(data: PendingFundTransfer[]): void { pendingFundTransfersData = data; saveToLocalStorage<PendingFundTransfer[]>(KEYS.PENDING_FUND_TRANSFERS, data); }
export function saveWeeklyLossReportsData(data: WeeklyLossReport[]): void { weeklyLossReportsData = data; saveToLocalStorage<WeeklyLossReport[]>(KEYS.WEEKLY_LOSS_REPORTS, data); }
export function saveWeeklyProfitReportsData(data: WeeklyProfitReport[]): void { weeklyProfitReportsData = data; saveToLocalStorage<WeeklyProfitReport[]>(KEYS.WEEKLY_PROFIT_REPORTS, data); }


// --- Constants ---
export const commonUnitOptions: string[] = [
  "kg", "g", "L", "ml", "galon", "unidad", "docena", "paquete", "caja", "saco", "bandeja"
].sort((a, b) => a.localeCompare(b));

// --- Goal Status Calculation ---
export function calculateGoalStatus(target: number, achieved: number): string {
  if (target <= 0) return 'No Definido';
  if (achieved <= 0 && target > 0) return 'Sin Empezar';
  const progress = (achieved / target) * 100;
  if (progress >= 100) return 'Completado';
  if (progress >= 90) return 'Casi Logrado';
  if (progress >= 50) return 'En Progreso';
  return 'Atrasado';
}

// --- Customer Balance Calculation (Global) ---
export function calculateCustomerBalance(customerId: string): number {
  const allSales = loadFromLocalStorage<Sale[]>(KEYS.SALES);
  const allPayments = loadFromLocalStorage<Payment[]>(KEYS.PAYMENTS);

  const customerDebts = allSales
    .filter(s => s.customerId === customerId && s.totalAmount >= 0)
    .reduce((sum, s) => sum + s.totalAmount, 0);

  const customerRealPayments = allPayments
    .filter(p => p.customerId === customerId && p.status === 'verificado' && p.paymentMethod !== 'Crédito a Favor')
    .reduce((sum, p) => sum + p.amountAppliedToDebtUSD, 0);
  
  return parseFloat((customerDebts - customerRealPayments).toFixed(4));
}


// --- Data Initialization Function ---
if (typeof window !== 'undefined') {
  userProfileData = loadUserProfileFromLocalStorage();
  loadExchangeRate();
  inventoryTransfersData = loadFromLocalStorage<InventoryTransfer[]>(KEYS.INVENTORY_TRANSFERS);
  pendingFundTransfersData = loadFromLocalStorage<PendingFundTransfer[]>(KEYS.PENDING_FUND_TRANSFERS);
  customersData = loadFromLocalStorage<Customer[]>(KEYS.CUSTOMERS);
  salesData = loadFromLocalStorage<Sale[]>(KEYS.SALES).map(s => ({...s, amountPaidUSD: s.amountPaidUSD || 0, itemsPerBranch: Array.isArray(s.itemsPerBranch) ? s.itemsPerBranch : [] }));
  paymentsData = loadFromLocalStorage<Payment[]>(KEYS.PAYMENTS);
  suppliersData = loadFromLocalStorage<Supplier[]>(KEYS.SUPPLIERS).map(s => ({ ...s, priceList: s.priceList || [], priceListUSDCash: s.priceListUSDCash || [] }));
  rawMaterialOptions = initializeRawMaterialOptions();
  customConversionRulesData = loadCustomConversionRules();
  weeklyLossReportsData = loadFromLocalStorage<WeeklyLossReport[]>(KEYS.WEEKLY_LOSS_REPORTS);
  weeklyProfitReportsData = loadFromLocalStorage<WeeklyProfitReport[]>(KEYS.WEEKLY_PROFIT_REPORTS);

  const activeBranchIdLoaded = getActiveBranchId();
  if (activeBranchIdLoaded) {
    productsData = loadProductsForBranch(activeBranchIdLoaded);
    productionLogData = loadFromLocalStorageForBranch<ProductionLogEntry[]>(KEYS.PRODUCTION_LOG, activeBranchIdLoaded);
    recipesData = loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, activeBranchIdLoaded).sort((a, b) => a.name.localeCompare(b.name));
    purchaseOrdersData = loadFromLocalStorageForBranch<PurchaseOrder[]>(KEYS.PURCHASE_ORDERS, activeBranchIdLoaded);
    rawMaterialInventoryData = loadRawMaterialInventoryData(activeBranchIdLoaded);
    weeklyGoalsData = loadFromLocalStorageForBranch<ProductionGoal[]>(KEYS.WEEKLY_GOALS, activeBranchIdLoaded);
    monthlyGoalsData = loadFromLocalStorageForBranch<ProductionGoal[]>(KEYS.MONTHLY_GOALS, activeBranchIdLoaded);
    employeesData = loadFromLocalStorageForBranch<Employee[]>(KEYS.EMPLOYEES, activeBranchIdLoaded);
    expensesData = loadFromLocalStorageForBranch<Expense[]>(KEYS.EXPENSES, activeBranchIdLoaded);
    loadExpenseFixedCategories(activeBranchIdLoaded);
    loadExpenseVariableCategories(activeBranchIdLoaded);
  } else {
    productsData = []; productionLogData = []; recipesData = [];
    purchaseOrdersData = []; rawMaterialInventoryData = []; weeklyGoalsData = [];
    monthlyGoalsData = []; employeesData = []; expensesData = [];
  }
}

export function updateGlobalSaleDataAndFinances(
  payment: Payment,
  operation: 'add' | 'subtract'
): void {
  
  let currentSales = loadFromLocalStorage<Sale[]>(KEYS.SALES);
  let currentPendingTransfers = loadFromLocalStorage<PendingFundTransfer[]>(KEYS.PENDING_FUND_TRANSFERS);

  const saleIndex = payment.appliedToInvoiceId ? currentSales.findIndex(s => s.id === payment.appliedToInvoiceId) : -1;

  if (operation === 'add') {
    if (saleIndex !== -1) {
      const sale = currentSales[saleIndex];
      sale.amountPaidUSD = (sale.amountPaidUSD || 0) + payment.amountAppliedToDebtUSD;

      if (payment.paymentMethod !== 'Nota de Crédito' && payment.paymentMethod !== 'Crédito a Favor' && sale.itemsPerBranch.length > 1 && payment.paidToBranchId) { // Pagos normales
        const rateForTransfer = payment.exchangeRateAtPayment || loadExchangeRate(parseISO(payment.paymentDate));
        const amountPaidInUSD = payment.amountAppliedToDebtUSD;

        sale.itemsPerBranch.forEach(branchDetail => {
          if (branchDetail.branchId !== payment.paidToBranchId) {
            const proportionOfTotal = sale.totalAmount > 0 ? branchDetail.totalAmount / sale.totalAmount : 0;
            const amountToTransferUSD = amountPaidInUSD * proportionOfTotal;

            if (amountToTransferUSD > 0.001) {
              const transferObject: PendingFundTransfer = {
                id: `TRNFR-${sale.id.slice(-4)}-${payment.id.slice(-4)}-${branchDetail.branchId.slice(-4)}`,
                saleId: sale.id,
                fromBranchId: payment.paidToBranchId!,
                fromBranchName: availableBranches.find(b => b.id === payment.paidToBranchId)?.name || 'Desconocida',
                toBranchId: branchDetail.branchId,
                toBranchName: branchDetail.branchName,
                amountUSD: 0,
                amountVES: 0,
                originalPaymentAccountId: payment.paidToAccountId,
                originalPaymentCurrency: payment.currencyPaidInput,
                exchangeRateAtPayment: rateForTransfer,
                creationTimestamp: payment.verificationDate || new Date().toISOString(),
                status: 'pendiente',
                parentPaymentId: payment.parentPaymentId,
              };
              
              if (payment.currencyPaidInput === 'VES') {
                  transferObject.amountVES = parseFloat((amountToTransferUSD * rateForTransfer).toFixed(2));
              } else {
                  transferObject.amountUSD = parseFloat(amountToTransferUSD.toFixed(2));
              }

              currentPendingTransfers.push(transferObject);
            }
          }
        });
      }
    }

    if (payment.paidToBranchId && payment.paidToAccountId && payment.paymentMethod !== 'Crédito a Favor' && payment.paymentMethod !== 'Nota de Crédito') {
      let companyAccounts = loadCompanyAccountsData(payment.paidToBranchId);
      const account = companyAccounts[payment.paidToAccountId];
      if (account) {
        const rate = payment.exchangeRateAtPayment || loadExchangeRate(parseISO(payment.paymentDate));
        const amountInAccountCurrency = account.currency === 'USD'
          ? payment.amountAppliedToDebtUSD
          : (rate > 0 ? payment.amountAppliedToDebtUSD * rate : 0);

        account.balance += amountInAccountCurrency;
        account.lastTransactionDate = new Date().toISOString();

        const newTransaction: AccountTransaction = {
          id: `TRN-PAYMENT-${payment.id}`,
          date: payment.paymentDate,
          description: `Ingreso por pago de ${payment.customerName}`,
          type: 'ingreso',
          amount: parseFloat(amountInAccountCurrency.toFixed(2)),
          currency: account.currency,
          accountId: payment.paidToAccountId,
          sourceModule: 'Ventas (Pago Cliente)',
          sourceId: payment.id,
          timestamp: payment.verificationDate || new Date().toISOString(),
          balanceAfterTransaction: account.balance
        };
        let transactions = loadFromLocalStorageForBranch<AccountTransaction[]>(KEYS.ACCOUNT_TRANSACTIONS, payment.paidToBranchId);
        transactions.unshift(newTransaction);
        saveToLocalStorageForBranch(KEYS.ACCOUNT_TRANSACTIONS, payment.paidToBranchId, transactions);
        saveCompanyAccountsData(payment.paidToBranchId, companyAccounts);
      }
    }
  } else { // operation === 'subtract'
     // 1. Revert Sale's amountPaidUSD
    if (saleIndex !== -1) {
      currentSales[saleIndex].amountPaidUSD = Math.max(0, (currentSales[saleIndex].amountPaidUSD || 0) - payment.amountAppliedToDebtUSD);
    }
    
    // 2. Revert Company Account Balance
    if (payment.paidToBranchId && payment.paidToAccountId && payment.paymentMethod !== 'Crédito a Favor' && payment.paymentMethod !== 'Nota de Crédito') {
      let companyAccounts = loadCompanyAccountsData(payment.paidToBranchId);
      const account = companyAccounts[payment.paidToAccountId];
      if (account) {
          const rate = payment.exchangeRateAtPayment || loadExchangeRate(parseISO(payment.paymentDate));
          const amountInAccountCurrency = account.currency === 'USD'
            ? payment.amountAppliedToDebtUSD
            : (rate > 0 ? payment.amountAppliedToDebtUSD * rate : 0);
          account.balance -= amountInAccountCurrency;
      }
      saveCompanyAccountsData(payment.paidToBranchId, companyAccounts);
    }

    // 3. Remove Account Transaction
    if(payment.paidToBranchId && payment.paymentMethod !== 'Crédito a Favor' && payment.paymentMethod !== 'Nota de Crédito') {
      let transactions = loadFromLocalStorageForBranch<AccountTransaction[]>(KEYS.ACCOUNT_TRANSACTIONS, payment.paidToBranchId);
      transactions = transactions.filter(t => t.sourceId !== payment.id);
      saveToLocalStorageForBranch(KEYS.ACCOUNT_TRANSACTIONS, payment.paidToBranchId, transactions);
    }

    // 4. Remove Pending Fund Transfers (if any)
    const initialTransferCount = currentPendingTransfers.length;
    currentPendingTransfers = currentPendingTransfers.filter(t => !t.id.includes(payment.id.slice(0, 15)));
    if(currentPendingTransfers.length < initialTransferCount) {
        savePendingFundTransfersData(currentPendingTransfers);
    }
  }

  // Save updated global states at the end
  saveSalesData(currentSales);
  savePendingFundTransfersData(currentPendingTransfers);
}


export function getInvoiceStatus(sale: Sale, allPayments: Payment[]): SaleStatus {
  if (!sale || typeof sale.totalAmount !== 'number') return 'Pendiente de Pago';

  const balance = calculateInvoiceBalance(sale.id, allPayments, [sale]);
  
  if (balance <= 0.01) {
    return 'Completada';
  }

  if (sale.dueDate && isValid(parseISO(sale.dueDate))) {
    if (differenceInDays(new Date(), parseISO(sale.dueDate)) > 0) {
      return 'Vencida';
    }
  }
  
  const paymentsForThisInvoice = allPayments.filter(p => p.appliedToInvoiceId === sale.id && p.status === 'verificado').reduce((sum, p) => sum + p.amountAppliedToDebtUSD, 0);
  if (paymentsForThisInvoice > 0.01) {
    return 'Pagada Parcialmente';
  }

  return 'Pendiente de Pago';
}

export function calculateInvoiceBalance(invoiceId: string, allPayments: Payment[], allSales: Sale[]): number {
    const sale = allSales.find(s => s.id === invoiceId);
    if (!sale) return 0;
    
    const paymentsForThisInvoice = allPayments
      .filter(p => p.appliedToInvoiceId === invoiceId && p.status === 'verificado')
      .reduce((sum, p) => sum + p.amountAppliedToDebtUSD, 0);

    return (sale.totalAmount || 0) - paymentsForThisInvoice;
}


// --- dashboard ---


"use client";

import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { PageHeader } from '@/components/page-header';
import { Button, buttonVariants } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  DollarSign,
  Home,
  Package,
  Save,
  AlertTriangle,
  BarChart as BarChartIcon,
  ShoppingCart,
  Utensils,
  Receipt,
  Archive,
  CreditCard as CreditCardIcon,
  type LucideIcon,
  ArrowRightLeft,
  CheckCircle2,
  TrendingUp,
  TrendingDown,
  Shuffle, 
  Calendar as CalendarIcon,
  Trash2
} from 'lucide-react';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { useToast } from "@/hooks/use-toast";
import {
  loadExchangeRate,
  saveExchangeRate,
  removeExchangeRate, // <-- Importado
  salesData as initialSalesDataGlobal,
  paymentsData as initialPaymentsDataGlobal,
  pendingFundTransfersData as initialPendingFundTransfersData,
  type Sale,
  type Payment,
  KEYS,
  availableBranches,
  getActiveBranchId,
  loadAllProductsFromAllBranches,
  loadFromLocalStorageForBranch,
  type Product,
  type PurchaseOrder,
  type RawMaterialInventoryItem,
  type Recipe,
  calculateDynamicRecipeCost,
  loadExpenseFixedCategories,
  type ExpenseFixedCategory,
  type Employee,
  WEEKS_IN_MONTH,
  getInvoiceStatus,
  type PendingFundTransfer,
  inventoryTransfersData as initialInventoryTransfersData, 
  calculatePackagingCost,
  weeklyLossReportsData,
  saveWeeklyLossReportsData,
  weeklyProfitReportsData,
  saveWeeklyProfitReportsData,
  loadFromLocalStorage,
  type ExchangeRateEntry
} from '@/lib/data-storage';
import { format, parseISO, subDays, isValid, compareDesc, isSameDay, startOfToday, isAfter, isBefore, addDays, startOfWeek, endOfWeek, isWithinInterval, getDay } from 'date-fns';
import { es } from 'date-fns/locale';
import { Bar, BarChart, CartesianGrid, XAxis, YAxis, Tooltip as RechartsTooltip, ResponsiveContainer, Legend } from "recharts";
import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion";
import { FormattedNumber } from '@/components/ui/formatted-number';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Calendar } from "@/components/ui/calendar";
import { cn } from '@/lib/utils';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from '@/components/ui/alert-dialog';


interface StatCardProps {
  title: string;
  titleBranch1?: string;
  valueBranch1?: React.ReactNode;
  numericValue1?: number;
  descriptionBranch1?: React.ReactNode;
  titleBranch2?: string;
  valueBranch2?: React.ReactNode;
  numericValue2?: number;
  descriptionBranch2?: React.ReactNode;
  icon: React.ElementType;
  trend?: string;
  isLoading?: boolean;
  variant?: 'default' | 'warning' | 'destructive' | 'success';
}

function StatCard({
  title,
  titleBranch1, valueBranch1, numericValue1, descriptionBranch1,
  titleBranch2, valueBranch2, numericValue2, descriptionBranch2,
  icon: Icon, trend, isLoading, variant = 'default'
}: StatCardProps) {
  const iconColor =
    variant === 'destructive' ? 'text-destructive' :
    variant === 'warning' ? 'text-yellow-500' :
    variant === 'success' ? 'text-green-500' :
    'text-primary';

  const getValueColor = (val?: number) => {
    if (isLoading) return 'text-muted-foreground';
    if (val === undefined) return 'text-foreground';

    if (variant === 'destructive' && val > 0) return 'text-destructive';
    if (variant === 'success' && val < 0) return 'text-destructive';
    if (variant === 'success') return 'text-green-600 dark:text-green-500';
    if (variant === 'warning' && val > 0) return 'text-yellow-600 dark:text-yellow-500';
    return 'text-foreground';
  }

  return (
    <Card className="shadow-lg hover:shadow-xl transition-shadow duration-300 flex flex-col">
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium text-muted-foreground">{title}</CardTitle>
        <Icon className={`h-5 w-5 ${iconColor}`} />
      </CardHeader>
      <CardContent className="flex-grow flex flex-col">
        {isLoading ? (
          <div className="text-2xl font-bold text-muted-foreground">Cargando...</div>
        ) : (
          <div className="flex-grow flex flex-col">
            {(titleBranch1 || valueBranch1) && (
              <div className="mb-2">
                {titleBranch1 && <p className="text-xs font-medium text-muted-foreground">{titleBranch1}</p>}
                {valueBranch1 && <div className={`text-2xl font-bold ${getValueColor(numericValue1)}`}>{valueBranch1}</div>}
                {descriptionBranch1 && (
                  <ScrollArea className="max-h-16 mt-1">
                      <div className="text-sm text-muted-foreground pt-0.5 pr-2">{descriptionBranch1}</div>
                  </ScrollArea>
                )}
              </div>
            )}

            {(titleBranch2 || valueBranch2) && (
              <div className={titleBranch1 || valueBranch1 ? "border-t border-border/50 pt-2 mt-2" : ""}>
                {titleBranch2 && <p className="text-xs font-medium text-muted-foreground">{titleBranch2}</p>}
                {valueBranch2 && <div className={`text-2xl font-bold ${getValueColor(numericValue2)}`}>{valueBranch2}</div>}
                {descriptionBranch2 && (
                    <ScrollArea className="max-h-16 mt-1">
                        <div className="text-sm text-muted-foreground pt-0.5 pr-2">{descriptionBranch2}</div>
                    </ScrollArea>
                )}
              </div>
            )}
            
            {trend && <p className="text-xs text-green-600 dark:text-green-400 pt-1 mt-auto">{trend}</p>}
          </div>
        )}
      </CardContent>
    </Card>
  );
}


const LOW_STOCK_THRESHOLD = 10;
const RAW_MATERIAL_LOW_STOCK_THRESHOLD = 5;
const CREDITS_DUE_SOON_DAYS = 3;
const TOP_N_PRODUCTS_DASHBOARD = 10;

interface ProductSalesData { name: string; quantity: number; }
const productSalesChartConfig = { quantity: { label: "Cantidad Vendida", color: "hsl(var(--chart-1))" }, } satisfies ChartConfig;

interface ActivityItem { id: string; type: string; description: string; date: string; displayTime: string; icon: LucideIcon; rawDate: Date; branchName?: string; }

const mainBakeryId = 'panaderia_principal';
const processedProductsId = 'productos_elaborados';

export default function DashboardPage() {
  const { toast } = useToast();
  const [exchangeRateInput, setExchangeRateInput] = useState<string>('');
  const [currentDisplayRate, setCurrentDisplayRate] = useState<number>(0);
  const [isLoadingStats, setIsLoadingStats] = useState(true);
  const [dataVersion, setDataVersion] = useState(0);
  
  const [pastDate, setPastDate] = useState<Date | undefined>();
  const [pastRateInput, setPastRateInput] = useState<string>('');
  const [isPastDatePickerOpen, setIsPastDatePickerOpen] = useState(false);

  const [weeklyRevenueBranch1, setWeeklyRevenueBranch1] = useState<number>(0);
  const [estimatedWeeklyLossBranch1, setEstimatedWeeklyLossBranch1] = useState<number>(0);
  const [estimatedWeeklyProfitBranch1, setEstimatedWeeklyProfitBranch1] = useState<number>(0);
  const [productsWithStockCountBranch1, setProductsWithStockCountBranch1] = useState<number>(0);
  const [lowStockItemsCountBranch1, setLowStockItemsCountBranch1] = useState<number>(0);
  const [lowRawMaterialStockItemsCountBranch1, setLowRawMaterialStockItemsCountBranch1] = useState<number>(0);
  const [pendingOrdersBranch1, setPendingOrdersBranch1] = useState<number>(0);
  const [descriptionStockBranch1, setDescriptionStockBranch1] = useState<React.ReactNode>('');
  const [descriptionLowStockBranch1, setDescriptionLowStockBranch1] = useState<React.ReactNode>('');
  const [descriptionLowRawBranch1, setDescriptionLowRawBranch1] = useState<React.ReactNode>('');
  const [descriptionPendingOrdersBranch1, setDescriptionPendingOrdersBranch1] = useState<React.ReactNode>('');

  const [weeklyRevenueBranch2, setWeeklyRevenueBranch2] = useState<number>(0);
  const [estimatedWeeklyLossBranch2, setEstimatedWeeklyLossBranch2] = useState<number>(0);
  const [estimatedWeeklyProfitBranch2, setEstimatedWeeklyProfitBranch2] = useState<number>(0);
  const [productsWithStockCountBranch2, setProductsWithStockCountBranch2] = useState<number>(0);
  const [lowStockItemsCountBranch2, setLowStockItemsCountBranch2] = useState<number>(0);
  const [lowRawMaterialStockItemsCountBranch2, setLowRawMaterialStockItemsCountBranch2] = useState<number>(0);
  const [pendingOrdersBranch2, setPendingOrdersBranch2] = useState<number>(0);
  const [descriptionStockBranch2, setDescriptionStockBranch2] = useState<React.ReactNode>('');
  const [descriptionLowStockBranch2, setDescriptionLowStockBranch2] = useState<React.ReactNode>('');
  const [descriptionLowRawBranch2, setDescriptionLowRawBranch2] = useState<React.ReactNode>('');
  const [descriptionPendingOrdersBranch2, setDescriptionPendingOrdersBranch2] = useState<React.ReactNode>('');

  const [overdueCreditsAmountUSD, setOverdueCreditsAmountUSD] = useState<number>(0);
  const [creditsDueSoonAmountUSD, setCreditsDueSoonAmountUSD] = useState<number>(0);
  const [productSalesChartData, setProductSalesChartData] = useState<ProductSalesData[]>([]);
  const [recentActivities, setRecentActivities] = useState<ActivityItem[]>([]);
  const [rateHistory, setRateHistory] = useState<ExchangeRateEntry[]>([]);
  const [isConfirmRateDeleteOpen, setIsConfirmRateDeleteOpen] = useState(false);
  const [rateToDelete, setRateToDelete] = useState<ExchangeRateEntry | null>(null);

  const checkForAutomatedWeeklyReportsGeneration = useCallback(() => {
    const today = new Date();
    // getDay() -> Domingo: 0, Sábado: 6
    if (getDay(today) === 0) { // Es Domingo
      const weekEndDate = endOfWeek(today, { weekStartsOn: 1 });

      // Generar Reporte de Pérdidas
      const lossReportId = `WLR-${format(weekEndDate, 'yyyy-MM-dd')}`;
      const existingLossReports = weeklyLossReportsData;
      const lossReportAlreadyExists = existingLossReports.some(report => report.id === lossReportId);
      
      if (!lossReportAlreadyExists) {
        console.log(`Es domingo y no existe reporte de PÉRDIDAS para la semana que termina el ${format(weekEndDate, 'yyyy-MM-dd')}. Generando...`);
        // const newLossReport = generateDetailedWeeklyLossReport(weekEndDate);
        // if (newLossReport) {
        //   saveWeeklyLossReportsData([newLossReport, ...existingLossReports]);
        //   toast({
        //     title: "Reporte Semanal de Pérdidas Generado",
        //     description: `Se ha generado y guardado automáticamente el reporte. Puedes verlo en la página de Reportes.`,
        //     duration: 10000,
        //   });
        // }
      }
      
      // Generar Reporte de Ganancias
      const profitReportId = `WPR-${format(weekEndDate, 'yyyy-MM-dd')}`;
      const existingProfitReports = weeklyProfitReportsData;
      const profitReportAlreadyExists = existingProfitReports.some(report => report.id === profitReportId);

      if (!profitReportAlreadyExists) {
          console.log(`Es domingo y no existe reporte de GANANCIAS para la semana que termina el ${format(weekEndDate, 'yyyy-MM-dd')}. Generando...`);
          // const newProfitReport = generateDetailedWeeklyProfitReport(weekEndDate);
          // if (newProfitReport) {
          //     saveWeeklyProfitReportsData([newProfitReport, ...existingProfitReports]);
          //     toast({
          //         title: "Reporte Semanal de Ganancias Generado",
          //         description: `Se ha generado y guardado automáticamente el reporte. Puedes verlo en la página de Reportes.`,
          //         duration: 10000,
          //     });
          // }
      }
    }
  }, [toast]);


  const calculateDashboardStats = useCallback(() => {
    setIsLoadingStats(true);
    const today = new Date();
    const startOfCurrentWeek = startOfWeek(today, { weekStartsOn: 1 });
    const endOfCurrentWeek = endOfWeek(today, { weekStartsOn: 1 });

    let revenueWeekB1 = 0;
    let revenueWeekB2 = 0;
    
    // Revenue from 'Pagado' sales
    initialSalesDataGlobal.forEach(sale => {
      if (sale.paymentMethod === 'Pagado' && sale.date && isValid(parseISO(sale.date)) && isWithinInterval(parseISO(sale.date), { start: startOfCurrentWeek, end: endOfCurrentWeek })) {
        if (sale.paymentSplits && sale.paymentSplits.length > 0) {
          sale.paymentSplits.forEach(split => {
            const splitDate = sale.date; // Use sale date for paid invoices
            const rateForSplit = loadExchangeRate(parseISO(splitDate));
            const amountUSD = split.currency === 'USD' ? split.amount : (rateForSplit > 0 ? split.amount / rateForSplit : 0);

            if (split.paidToBranchId === mainBakeryId) {
              revenueWeekB1 += amountUSD;
            } else if (split.paidToBranchId === processedProductsId) {
              revenueWeekB2 += amountUSD;
            }
          });
        } else if(sale.paidToBranchId){ // Legacy support for old sales data structure
            if (sale.paidToBranchId === mainBakeryId) revenueWeekB1 += sale.totalAmount;
            else if (sale.paidToBranchId === processedProductsId) revenueWeekB2 += sale.totalAmount;
        }
      }
    });

    // Revenue from verified payments for 'Crédito' sales
    initialPaymentsDataGlobal.forEach(payment => {
      if (payment.status === 'verificado' && payment.paymentDate && isValid(parseISO(payment.paymentDate)) && isWithinInterval(parseISO(payment.paymentDate), { start: startOfCurrentWeek, end: endOfCurrentWeek })) {
        const originalSale = initialSalesDataGlobal.find(s => s.id === payment.appliedToInvoiceId);
        if (originalSale && originalSale.paymentMethod !== 'Pagado') {
          if (payment.paidToBranchId === mainBakeryId) {
            revenueWeekB1 += payment.amountAppliedToDebtUSD;
          } else if (payment.paidToBranchId === processedProductsId) {
            revenueWeekB2 += payment.amountAppliedToDebtUSD;
          }
        }
      }
    });
    
    // Revenue from completed fund transfers
    initialPendingFundTransfersData.forEach(transfer => {
      if (transfer.status === 'completada' && transfer.completionTimestamp && isValid(parseISO(transfer.completionTimestamp)) && isWithinInterval(parseISO(transfer.completionTimestamp), { start: startOfCurrentWeek, end: endOfCurrentWeek })) {
        if (transfer.toBranchId === mainBakeryId) revenueWeekB1 += transfer.amountUSD;
        else if (transfer.toBranchId === processedProductsId) revenueWeekB2 += transfer.amountUSD;
        if (transfer.fromBranchId === mainBakeryId) revenueWeekB1 -= transfer.amountUSD;
        else if (transfer.fromBranchId === processedProductsId) revenueWeekB2 -= transfer.amountUSD;
      }
    });

    setWeeklyRevenueBranch1(revenueWeekB1);
    setWeeklyRevenueBranch2(revenueWeekB2);

    const branchOperatingCosts: { [key: string]: number } = {};
    const branchSacksProduced: { [key: string]: number } = {};
    const branchCostPerSack: { [key: string]: number } = {};
    const productionLogByBranch: { [key: string]: ProductionLogEntry[] } = {};
    const recipesByBranch: { [key: string]: Recipe[] } = {};

    availableBranches.forEach(branch => {
      if (branch.id === mainBakeryId || branch.id === processedProductsId) {
        const fixedCategories = loadFromLocalStorageForBranch<ExpenseFixedCategory[]>(KEYS.EXPENSE_FIXED_CATEGORIES, branch.id);
        const employees = loadFromLocalStorageForBranch<Employee[]>(KEYS.EMPLOYEES, branch.id);
        productionLogByBranch[branch.id] = loadFromLocalStorageForBranch<ProductionLogEntry[]>(KEYS.PRODUCTION_LOG, branch.id);
        recipesByBranch[branch.id] = loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, branch.id);

        const fixedWeekly = fixedCategories
          .filter(cat => cat.name.toLowerCase() !== 'nómina' && cat.monthlyAmount && cat.monthlyAmount > 0)
          .reduce((sum, cat) => sum + (cat.monthlyAmount! / WEEKS_IN_MONTH), 0);
        const payrollWeekly = employees.reduce((sum, emp) => sum + (emp.salary || 0), 0);
        branchOperatingCosts[branch.id] = fixedWeekly + payrollWeekly;

        branchSacksProduced[branch.id] = productionLogByBranch[branch.id]
          .filter(log => {
            if (!log.date || !isValid(parseISO(log.date))) return false;
            return isWithinInterval(parseISO(log.date), { start: startOfCurrentWeek, end: endOfCurrentWeek });
          })
          .reduce((sum, log) => {
            const recipeDetails = recipesByBranch[branch.id]?.find(r => r.name === log.product);
            return (recipeDetails && !recipeDetails.isIntermediate) ? sum + (log.batchSizeMultiplier || 0) : sum;
          }, 0);

        branchCostPerSack[branch.id] = branchSacksProduced[branch.id] > 0 && branchOperatingCosts[branch.id] >= 0
                                 ? branchOperatingCosts[branch.id] / branchSacksProduced[branch.id]
                                 : 0;
      }
    });
    
    let totalWeeklyLossB1 = 0; let totalWeeklyLossB2 = 0;
    let totalGrossProfitB1 = 0; let totalGrossProfitB2 = 0;

    const salesThisWeekForLossProfit = initialSalesDataGlobal.filter(sale => {
        if (!sale.date || !isValid(parseISO(sale.date))) return false;
        return isWithinInterval(parseISO(sale.date), { start: startOfCurrentWeek, end: endOfCurrentWeek });
    });
    
    salesThisWeekForLossProfit.forEach(sale => {
      const changes = (sale.changes || []).map(c => ({...c, lossType: 'change'}));
      const samples = (sale.samples || []).map(s => ({...s, lossType: 'sample'}));
      const changesAndSamples = [...changes, ...samples];

      changesAndSamples.forEach(item => {
        if (item.productId && item.sourceBranchId && (item.sourceBranchId === mainBakeryId || item.sourceBranchId === processedProductsId)) {
          const recipesForSourceBranch = recipesByBranch[item.sourceBranchId];
          const recipeForLoss = recipesForSourceBranch?.find(r => r.id === item.productId || r.name === item.productName);
          
          if (recipeForLoss) {
            let lossValue = 0;
            if (item.lossType === 'change') {
                const nonDespachableRecipeName = `No despachable ${item.productName}`;
                const nonDespachableRecipe = recipesForSourceBranch?.find(r => r.name === nonDespachableRecipeName);
                if (nonDespachableRecipe) {
                    lossValue = (nonDespachableRecipe.costPerUnit || 0) * item.quantity;
                } else {
                    lossValue = item.subtotal || 0; // Fallback to subtotal if no counterpart found
                }
            } else if (item.lossType === 'sample') {
                const costOfIngredientsPerTanda = calculateDynamicRecipeCost(recipeForLoss.id, 'highest', recipesForSourceBranch || []);
                const costOfIngredientsPerUnit = (recipeForLoss.expectedYield && recipeForLoss.expectedYield > 0) ? costOfIngredientsPerTanda / recipeForLoss.expectedYield : 0;
                const operatingCostPerUnit = (recipeForLoss.expectedYield && recipeForLoss.expectedYield > 0 && branchCostPerSack[item.sourceBranchId] !== undefined && branchCostPerSack[item.sourceBranchId] >= 0) ? branchCostPerSack[item.sourceBranchId] / recipeForLoss.expectedYield : 0;
                const packagingCostPerUnit = calculatePackagingCost(1).maxCost;
                const totalCostPerUnitSampled = costOfIngredientsPerUnit + operatingCostPerUnit + packagingCostPerUnit;
                lossValue = item.quantity * totalCostPerUnitSampled;
            }

            if (item.sourceBranchId === mainBakeryId) totalWeeklyLossB1 += lossValue;
            else if (item.sourceBranchId === processedProductsId) totalWeeklyLossB2 += lossValue;
          }
        }
      });

      const saleStatus = getInvoiceStatus(sale, initialPaymentsDataGlobal);
      if (saleStatus === 'Completada' || saleStatus === 'Pagada Parcialmente') {
        sale.itemsPerBranch.forEach(branchDetail => {
            const recipesForCurrentBranch = recipesByBranch[branchDetail.branchId];
            if (!recipesForCurrentBranch) return;
            branchDetail.items.forEach(item => {
                if (item.productId && (branchDetail.branchId === mainBakeryId || branchDetail.branchId === processedProductsId) && item.unitPrice > 0) {
                    const recipe = recipesForCurrentBranch.find(r => r.id === item.productId || r.name === item.productName);
                    if (recipe && !recipe.isIntermediate) { 
                        const costOfIngredientsPerTanda = calculateDynamicRecipeCost(recipe.id, 'highest', recipesForCurrentBranch || []);
                        const costOfIngredientsPerUnit = (recipe.expectedYield && recipe.expectedYield > 0) ? costOfIngredientsPerTanda / recipe.expectedYield : 0;
                        const operatingCostPerUnit = (recipe.expectedYield && recipe.expectedYield > 0 && branchCostPerSack[branchDetail.branchId] !== undefined && branchCostPerSack[branchDetail.branchId] >= 0)
                                                     ? branchCostPerSack[branchDetail.branchId] / recipe.expectedYield : 0;
                        const packagingCostPerUnit = calculatePackagingCost(1).maxCost;
                        const totalCostPerUnitSold = costOfIngredientsPerUnit + operatingCostPerUnit + packagingCostPerUnit;
                        const profitPerUnit = item.unitPrice - totalCostPerUnitSold;
                        
                        const profitValue = item.quantity * profitPerUnit;
                        if (branchDetail.branchId === mainBakeryId) totalGrossProfitB1 += profitValue;
                        else if (branchDetail.branchId === processedProductsId) totalGrossProfitB2 += profitValue;
                    }
                }
            });
        });
      }
    });

    availableBranches.forEach(branch => {
      if (branch.id === mainBakeryId || branch.id === processedProductsId) {
        const productionThisWeek = productionLogByBranch[branch.id]?.filter(log => {
          if (!log.date || !isValid(parseISO(log.date))) return false;
          return isWithinInterval(parseISO(log.date), { start: startOfCurrentWeek, end: endOfCurrentWeek });
        }) || [];

        productionThisWeek.forEach(log => {
          const recipeDetails = recipesByBranch[branch.id]?.find(r => r.name === log.product);
          if (recipeDetails && !recipeDetails.isIntermediate) { 
            const wastageQuantity = log.expectedQuantity - log.actualQuantity;
            if (wastageQuantity > 0) {
              const costOfIngredientsPerTanda = calculateDynamicRecipeCost(recipeDetails.id, 'highest', recipesByBranch[branch.id] || []);
              const costOfIngredientsPerUnit = (recipeDetails.expectedYield && recipeDetails.expectedYield > 0) ? costOfIngredientsPerTanda / recipeDetails.expectedYield : 0;
              let operatingCostPerUnit = 0;
              if (recipeDetails.expectedYield && recipeDetails.expectedYield > 0 &&
                  branchCostPerSack[branch.id] !== undefined && branchCostPerSack[branch.id] >= 0) {
                operatingCostPerUnit = branchCostPerSack[branch.id] / recipeDetails.expectedYield;
              }
              const totalCostPerUnitForWastage = costOfIngredientsPerUnit + operatingCostPerUnit;
              const wastageCost = wastageQuantity * totalCostPerUnitForWastage;

              if (branch.id === mainBakeryId) {
                totalWeeklyLossB1 += wastageCost;
              } else if (branch.id === processedProductsId) {
                totalWeeklyLossB2 += wastageCost;
              }
            }
          }
        });
      }
    });

    setEstimatedWeeklyLossBranch1(totalWeeklyLossB1); 
    setEstimatedWeeklyLossBranch2(totalWeeklyLossB2);
    setEstimatedWeeklyProfitBranch1(totalGrossProfitB1 - totalWeeklyLossB1);
    setEstimatedWeeklyProfitBranch2(totalGrossProfitB2 - totalWeeklyLossB2);

    const allProductsGlobal = loadAllProductsFromAllBranches();
    const productsB1 = allProductsGlobal.filter(p => p.sourceBranchId === mainBakeryId);
    const productsB2 = allProductsGlobal.filter(p => p.sourceBranchId === processedProductsId);

    const productsInStockB1 = productsB1.filter(p => p.stock > 0);
    setProductsWithStockCountBranch1(productsInStockB1.length);
    setDescriptionStockBranch1(
      productsInStockB1.length > 0 ? (
        <ul className="list-disc list-inside text-left text-xs">
          {productsInStockB1.map(p => <li key={p.id}>{p.name} ({p.stock})</li>)}
        </ul>
      ) : "No hay productos en stock."
    );

    const productsInStockB2 = productsB2.filter(p => p.stock > 0);
    setProductsWithStockCountBranch2(productsInStockB2.length);
    setDescriptionStockBranch2(
      productsInStockB2.length > 0 ? (
        <ul className="list-disc list-inside text-left text-xs">
          {productsInStockB2.map(p => <li key={p.id}>{p.name} ({p.stock})</li>)}
        </ul>
      ) : "No hay productos en stock."
    );

    const lowStockB1 = productsB1.filter(p => p.stock > 0 && p.stock < LOW_STOCK_THRESHOLD);
    setLowStockItemsCountBranch1(lowStockB1.length);
    setDescriptionLowStockBranch1(
      lowStockB1.length > 0 ? (
        <ul className="list-disc list-inside text-left text-xs">
          {lowStockB1.map(p => <li key={p.id}>{p.name} ({p.stock})</li>)}
        </ul>
      ) : `Menos de ${LOW_STOCK_THRESHOLD} unid.`
    );
    const lowStockB2 = productsB2.filter(p => p.stock > 0 && p.stock < LOW_STOCK_THRESHOLD);
    setLowStockItemsCountBranch2(lowStockB2.length);
    setDescriptionLowStockBranch2(
      lowStockB2.length > 0 ? (
        <ul className="list-disc list-inside text-left text-xs">
          {lowStockB2.map(p => <li key={p.id}>{p.name} ({p.stock})</li>)}
        </ul>
      ) : `Menos de ${LOW_STOCK_THRESHOLD} unid.`
    );
    

    const rawMatsB1 = loadFromLocalStorageForBranch<RawMaterialInventoryItem[]>(KEYS.RAW_MATERIAL_INVENTORY, mainBakeryId);
    const lowRawB1 = rawMatsB1.filter(item => item.quantity < RAW_MATERIAL_LOW_STOCK_THRESHOLD);
    setLowRawMaterialStockItemsCountBranch1(lowRawB1.length);
    setDescriptionLowRawBranch1(
      lowRawB1.length > 0 ? (
        <ul className="list-disc list-inside text-left text-xs">
          {lowRawB1.map(p => <li key={p.name}>{p.name} ({p.quantity.toFixed(2)} {p.unit})</li>)}
        </ul>
      ) : `Menos de ${RAW_MATERIAL_LOW_STOCK_THRESHOLD} unid.`
    );

    const rawMatsB2 = loadFromLocalStorageForBranch<RawMaterialInventoryItem[]>(KEYS.RAW_MATERIAL_INVENTORY, processedProductsId);
    const lowRawB2 = rawMatsB2.filter(item => item.quantity < RAW_MATERIAL_LOW_STOCK_THRESHOLD);
    setLowRawMaterialStockItemsCountBranch2(lowRawB2.length);
    setDescriptionLowRawBranch2(
       lowRawB2.length > 0 ? (
        <ul className="list-disc list-inside text-left text-xs">
          {lowRawB2.map(p => <li key={p.name}>{p.name} ({p.quantity.toFixed(2)} {p.unit})</li>)}
        </ul>
      ) : `Menos de ${RAW_MATERIAL_LOW_STOCK_THRESHOLD} unid.`
    );

    const ordersB1 = loadFromLocalStorageForBranch<PurchaseOrder[]>(KEYS.PURCHASE_ORDERS, mainBakeryId).filter(po => po.status === 'Pedido' || po.status === 'Pendiente');
    setPendingOrdersBranch1(ordersB1.length);
    setDescriptionPendingOrdersBranch1(ordersB1.length > 0 ? `Total ${ordersB1.length}. No recibidas o no pagadas.` : "Sin órdenes pendientes.");
    const ordersB2 = loadFromLocalStorageForBranch<PurchaseOrder[]>(KEYS.PURCHASE_ORDERS, processedProductsId).filter(po => po.status === 'Pedido' || po.status === 'Pendiente');
    setPendingOrdersBranch2(ordersB2.length);
    setDescriptionPendingOrdersBranch2(ordersB2.length > 0 ? `Total ${ordersB2.length}. No recibidas o no pagadas.` : "Sin órdenes pendientes.");

    const startOfTodayDate = startOfToday(); let overdueAmount = 0; let dueSoonAmount = 0;
    initialSalesDataGlobal.forEach(sale => {
      if (sale.paymentMethod === 'Crédito' && sale.dueDate) {
        const dueDate = parseISO(sale.dueDate);
        if (isValid(dueDate)) {
          const outstandingAmount = sale.totalAmount - (sale.amountPaidUSD || 0);
          if (outstandingAmount > 0) {
            if (isBefore(dueDate, startOfTodayDate)) overdueAmount += outstandingAmount;
            else if (isBefore(dueDate, addDays(startOfTodayDate, CREDITS_DUE_SOON_DAYS + 1)) && isAfter(dueDate, subDays(startOfTodayDate,1))) dueSoonAmount += outstandingAmount;
          }
        }
      }
    });
    setOverdueCreditsAmountUSD(overdueAmount);
    setCreditsDueSoonAmountUSD(dueSoonAmount);

    const sevenDaysAgo = subDays(new Date(), 6);
    const productSales: { [productName: string]: number } = {};
    initialSalesDataGlobal.forEach(sale => {
      if (sale.date && isValid(parseISO(sale.date))) {
        const saleDate = parseISO(sale.date);
        if (isAfter(saleDate, subDays(sevenDaysAgo, 1)) && isBefore(saleDate, addDays(new Date(), 1))) {
           if (Array.isArray(sale.itemsPerBranch)) {
            sale.itemsPerBranch.forEach(branchDetail => {
              if (Array.isArray(branchDetail.items)) {
                branchDetail.items.forEach(item => {
                  if (item.productName) productSales[item.productName] = (productSales[item.productName] || 0) + item.quantity;
                });
              }
            });
           }
        }
      }
    });
    setProductSalesChartData(Object.entries(productSales).map(([name, quantity]) => ({ name, quantity })).sort((a, b) => b.quantity - a.quantity).slice(0, TOP_N_PRODUCTS_DASHBOARD));

    const activities: ActivityItem[] = [];
    const formatDateForDisplayLocal = (isoString?: string): string => {
        if (!isoString) return "Fecha desconocida";
        const parsedDate = parseISO(isoString);
        if (!isValid(parsedDate)) return "Fecha inválida";
        return format(parsedDate, "dd/MM/yy hh:mm a", { locale: es });
    };
    initialSalesDataGlobal.forEach(sale => { if (sale.timestamp && isValid(parseISO(sale.timestamp))) { activities.push({ id: sale.id, type: "Venta", description: `Venta a ${sale.customerName || 'N/A'} por $${sale.totalAmount.toFixed(2)}`, date: sale.timestamp, displayTime: formatDateForDisplayLocal(sale.timestamp), icon: ShoppingCart, rawDate: parseISO(sale.timestamp), branchName: sale.paidToBranchId ? availableBranches.find(b => b.id === sale.paidToBranchId)?.name || 'Global' : 'Global'});}});
    initialPaymentsDataGlobal.filter(p => p.status === 'verificado').forEach(payment => { const pDate = payment.verificationDate || payment.creationTimestamp || payment.paymentDate; if (pDate && isValid(parseISO(pDate))) { activities.push({ id: payment.id, type: "Pago Cliente", description: `Pago verificado de ${payment.customerName} por $${payment.amountAppliedToDebtUSD.toFixed(2)}`, date: pDate, displayTime: formatDateForDisplayLocal(pDate), icon: CheckCircle2, rawDate: parseISO(pDate), branchName: payment.paidToBranchId ? availableBranches.find(b => b.id === payment.paidToBranchId)?.name || 'Global' : 'Global'});}});
    
    availableBranches.forEach(branch => {
        const productionLogBranch = loadFromLocalStorageForBranch<ProductionLogEntry[]>(KEYS.PRODUCTION_LOG, branch.id);
        productionLogBranch.forEach(log => { if (log.timestamp && isValid(parseISO(log.timestamp))) { activities.push({ id: log.id, type: "Producción", description: `${log.actualQuantity} unid. de ${log.product}`, date: log.timestamp, displayTime: formatDateForDisplayLocal(log.timestamp), icon: Utensils, rawDate: parseISO(log.timestamp), branchName: branch.name});}});
        const expensesForBranch = loadFromLocalStorageForBranch<Expense[]>(KEYS.EXPENSES, branch.id);
        expensesForBranch.forEach(expense => { if (expense.timestamp && isValid(parseISO(expense.timestamp))) { activities.push({ id: expense.id, type: "Gasto", description: `Gasto: ${expense.description} por $${expense.amount.toFixed(2)}`, date: expense.timestamp, displayTime: formatDateForDisplayLocal(expense.timestamp), icon: DollarSign, rawDate: parseISO(expense.timestamp), branchName: branch.name});}});
        const purchaseOrdersBranch = loadFromLocalStorageForBranch<PurchaseOrder[]>(KEYS.PURCHASE_ORDERS, branch.id);
        purchaseOrdersBranch.filter(po => po.status === 'Pagado').forEach(po => { if (po.timestamp && isValid(parseISO(po.timestamp))) { activities.push({ id: po.id, type: "Compra MP", description: `OC Pagada a ${po.supplierName} por $${po.totalCost.toFixed(2)}`, date: po.timestamp, displayTime: formatDateForDisplayLocal(po.timestamp), icon: Receipt, rawDate: parseISO(po.timestamp), branchName: branch.name});}});
    });

    initialPendingFundTransfersData.forEach(transfer => {
      if (transfer.status === 'completada' && transfer.completionTimestamp && isValid(parseISO(transfer.completionTimestamp))) {
        activities.push({
          id: transfer.id,
          type: "Transf. Fondos Comp.",
          description: `$${transfer.amountUSD.toFixed(2)} de ${transfer.fromBranchName} a ${transfer.toBranchName}`,
          date: transfer.completionTimestamp,
          displayTime: formatDateForDisplayLocal(transfer.completionTimestamp),
          icon: Shuffle,
          rawDate: parseISO(transfer.completionTimestamp),
          branchName: "Global"
        });
      }
    });

    const inventoryTransfers = initialInventoryTransfersData; 
    inventoryTransfers.forEach(transfer => { if (transfer.timestamp && isValid(parseISO(transfer.timestamp))) { activities.push({ id: transfer.id, type: "Transferencia MP", description: `${transfer.quantity.toFixed(2)}${transfer.unit} de ${transfer.materialName} (${transfer.fromBranchName} → ${transfer.toBranchName})`, date: transfer.timestamp, displayTime: formatDateForDisplayLocal(transfer.completionTimestamp), icon: ArrowRightLeft, rawDate: parseISO(transfer.timestamp), branchName: "Global"});}});


    activities.sort((a, b) => compareDesc(a.rawDate, b.rawDate));
    setRecentActivities(activities.slice(0, 5));

    const history = loadFromLocalStorage<ExchangeRateEntry[]>(KEYS.EXCHANGE_RATE_HISTORY, false);
    setRateHistory(history.slice(0, 7)); // Get the last 7 entries for display

    setIsLoadingStats(false);
  }, [toast]);

  useEffect(() => {
    const loadedRate = loadExchangeRate();
    setCurrentDisplayRate(loadedRate);
    setExchangeRateInput(loadedRate > 0 ? loadedRate.toString() : '');
    calculateDashboardStats();
    checkForAutomatedWeeklyReportsGeneration();
  }, [calculateDashboardStats, checkForAutomatedWeeklyReportsGeneration]);

  useEffect(() => {
    const handleDataUpdate = () => { setDataVersion(prev => prev + 1); };
    window.addEventListener('data-updated', handleDataUpdate);
    return () => { window.removeEventListener('data-updated', handleDataUpdate); };
  }, []);

  useEffect(() => { if (dataVersion > 0) calculateDashboardStats(); }, [dataVersion, calculateDashboardStats]);

  const handleSaveExchangeRate = () => {
    const rateNumber = parseFloat(exchangeRateInput);
    if (isNaN(rateNumber) || rateNumber <= 0) {
      toast({ title: "Error", description: "Por favor, ingresa una tasa de cambio válida y positiva.", variant: "destructive", });
      return;
    }
    saveExchangeRate(rateNumber);
    setCurrentDisplayRate(rateNumber);
    toast({ title: "Tasa Guardada", description: `La tasa de cambio USD/VES se ha guardado como ${rateNumber.toFixed(4)}.`, });
    setDataVersion(prev => prev + 1);
  };
  
  const handleSavePastRate = () => {
    if (!pastDate) {
      toast({ title: "Error", description: "Por favor, selecciona una fecha.", variant: "destructive" });
      return;
    }
    const rateNumber = parseFloat(pastRateInput);
    if (isNaN(rateNumber) || rateNumber <= 0) {
      toast({ title: "Error", description: "Por favor, ingresa una tasa válida y positiva.", variant: "destructive" });
      return;
    }
    saveExchangeRate(rateNumber, pastDate);
    toast({
      title: "Tasa Histórica Guardada",
      description: `La tasa para el ${format(pastDate, "dd/MM/yyyy", { locale: es })} se ha guardado como ${rateNumber.toFixed(4)}.`,
    });
    setPastDate(undefined);
    setPastRateInput('');
    setDataVersion(prev => prev + 1); // Trigger data reload
  };

  const handleOpenDeleteDialog = (entry: ExchangeRateEntry) => {
    setRateToDelete(entry);
    setIsConfirmRateDeleteOpen(true);
  };
  
  const handleConfirmDeleteRate = () => {
    if (!rateToDelete) return;
    removeExchangeRate(rateToDelete.date);
    toast({
      title: "Tasa Eliminada",
      description: `La tasa para el ${format(parseISO(rateToDelete.date), "dd/MM/yyyy", { locale: es })} ha sido eliminada.`,
    });
    setIsConfirmRateDeleteOpen(false);
    setRateToDelete(null);
    setDataVersion(prev => prev + 1); // Trigger data reload
  };

  const nameBranch1 = "Panadería";
  const nameBranch2 = "Productos";
  const totalCredits = overdueCreditsAmountUSD + creditsDueSoonAmountUSD;

  return (
    <div className="space-y-8">
      <PageHeader title="Panel Principal Global" description="Resumen de operaciones. Los datos de 'Ingresos', 'Pérdida', 'Ganancia', 'Stock', 'MP Baja' y 'OCs Pendientes' se desglosan por sede. Créditos es global." icon={Home} />
      <Card className="shadow-lg">
        <CardHeader>
          <CardTitle>Configuración de Tasa de Cambio (USD a VES)</CardTitle>
          <CardDescription>Ingresa la tasa de cambio oficial del BCV para el día (VES por USD). Tasa actual: <span className="font-bold text-primary">{currentDisplayRate > 0 ? `Bs. ${currentDisplayRate.toFixed(4)} por USD` : 'No establecida'}</span></CardDescription>
        </CardHeader>
        <CardContent className="flex flex-col sm:flex-row items-end gap-4">
          <div className="flex-grow space-y-1"><Label htmlFor="exchange_rate_input">Tasa del Día (VES por USD)</Label><Input id="exchange_rate_input" type="number" value={exchangeRateInput} onChange={(e) => setExchangeRateInput(e.target.value)} placeholder="ej., 36.5000" step="0.0001"/></div>
          <Button onClick={handleSaveExchangeRate} className="w-full sm:w-auto"><Save className="mr-2 h-4 w-4" /> Guardar Tasa</Button>
        </CardContent>
        <CardFooter className="flex-col items-start pt-4 border-t">
          <Accordion type="single" collapsible className="w-full">
            <AccordionItem value="item-1">
              <AccordionTrigger>Ver Historial Reciente / Eliminar Tasas</AccordionTrigger>
              <AccordionContent>
                {rateHistory.length > 0 ? (
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead>Fecha</TableHead>
                        <TableHead className="text-right">Tasa (VES por USD)</TableHead>
                        <TableHead className="text-right">Acciones</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {rateHistory.map((entry) => (
                        <TableRow key={entry.date}>
                          <TableCell>{format(parseISO(entry.date), "dd/MM/yyyy", { locale: es })}</TableCell>
                          <TableCell className="text-right">{entry.rate.toFixed(4)}</TableCell>
                          <TableCell className="text-right">
                            <Button
                              variant="ghost"
                              size="icon"
                              onClick={() => handleOpenDeleteDialog(entry)}
                              title={`Eliminar tasa del ${format(parseISO(entry.date), "dd/MM/yyyy", { locale: es })}`}
                              className="h-8 w-8 text-destructive hover:bg-destructive/10"
                            >
                              <Trash2 className="h-4 w-4" />
                            </Button>
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                ) : (
                  <p className="text-sm text-muted-foreground text-center py-2">No hay historial de tasas guardado.</p>
                )}
              </AccordionContent>
            </AccordionItem>
            <AccordionItem value="item-2">
              <AccordionTrigger>Añadir Tasa de un Día Anterior</AccordionTrigger>
              <AccordionContent>
                <div className="space-y-4 pt-2">
                  <p className="text-xs text-muted-foreground">
                    Usa esta sección si olvidaste registrar la tasa de un día pasado. Esto corregirá los cálculos históricos.
                  </p>
                  <div className="flex flex-col sm:flex-row items-end gap-4">
                    <div className="flex-grow space-y-1">
                      <Label htmlFor="past_date_picker">Fecha</Label>
                      <Popover open={isPastDatePickerOpen} onOpenChange={setIsPastDatePickerOpen}>
                        <PopoverTrigger asChild>
                          <Button
                            id="past_date_picker"
                            variant={"outline"}
                            className={cn("w-full justify-start text-left font-normal", !pastDate && "text-muted-foreground")}
                          >
                            <CalendarIcon className="mr-2 h-4 w-4" />
                            {pastDate ? format(pastDate, "PPP", { locale: es }) : <span>Selecciona una fecha</span>}
                          </Button>
                        </PopoverTrigger>
                        <PopoverContent className="w-auto p-0">
                          <Calendar
                            mode="single"
                            selected={pastDate}
                            onSelect={(date) => { setPastDate(date); setIsPastDatePickerOpen(false); }}
                            initialFocus
                            locale={es}
                            disabled={(date) => date > new Date() || date < new Date("2023-01-01")}
                          />
                        </PopoverContent>
                      </Popover>
                    </div>
                    <div className="flex-grow space-y-1">
                      <Label htmlFor="past_rate_input">Tasa (VES por USD)</Label>
                      <Input
                        id="past_rate_input"
                        type="number"
                        value={pastRateInput}
                        onChange={(e) => setPastRateInput(e.target.value)}
                        placeholder="ej., 36.1234"
                        step="0.0001"
                      />
                    </div>
                    <Button onClick={handleSavePastRate} disabled={!pastDate || !pastRateInput}>
                      <Save className="mr-2 h-4 w-4" /> Guardar Tasa Pasada
                    </Button>
                  </div>
                </div>
              </AccordionContent>
            </AccordionItem>
          </Accordion>
        </CardFooter>
      </Card>

      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
        <StatCard title="Ingresos de la Semana" icon={DollarSign} isLoading={isLoadingStats}
          titleBranch1={nameBranch1} 
          valueBranch1={<FormattedNumber value={weeklyRevenueBranch1} prefix="$" />}
          numericValue1={weeklyRevenueBranch1}
          descriptionBranch1={<FormattedNumber value={weeklyRevenueBranch1 * currentDisplayRate} prefix="Bs. " />}
          titleBranch2={nameBranch2} 
          valueBranch2={<FormattedNumber value={weeklyRevenueBranch2} prefix="$" />}
          numericValue2={weeklyRevenueBranch2}
          descriptionBranch2={<FormattedNumber value={weeklyRevenueBranch2 * currentDisplayRate} prefix="Bs. " />}
        />
        <StatCard title="Pérdida Sem. Estimada" icon={TrendingDown} isLoading={isLoadingStats} variant="destructive"
          titleBranch1={nameBranch1} 
          valueBranch1={<FormattedNumber value={estimatedWeeklyLossBranch1} prefix="$" />}
          numericValue1={estimatedWeeklyLossBranch1}
          descriptionBranch1={<FormattedNumber value={estimatedWeeklyLossBranch1 * currentDisplayRate} prefix="Bs. " />}
          titleBranch2={nameBranch2} 
          valueBranch2={<FormattedNumber value={estimatedWeeklyLossBranch2} prefix="$" />}
          numericValue2={estimatedWeeklyLossBranch2}
          descriptionBranch2={<FormattedNumber value={estimatedWeeklyLossBranch2 * currentDisplayRate} prefix="Bs. " />}
        />
        <StatCard title="Ganancia Sem. Estimada" icon={TrendingUp} isLoading={isLoadingStats} variant="success"
          titleBranch1={nameBranch1} 
          valueBranch1={<FormattedNumber value={estimatedWeeklyProfitBranch1} prefix="$" />}
          numericValue1={estimatedWeeklyProfitBranch1}
          descriptionBranch1={<FormattedNumber value={estimatedWeeklyProfitBranch1 * currentDisplayRate} prefix="Bs. " />}
          titleBranch2={nameBranch2} 
          valueBranch2={<FormattedNumber value={estimatedWeeklyProfitBranch2} prefix="$" />}
          numericValue2={estimatedWeeklyProfitBranch2}
          descriptionBranch2={<FormattedNumber value={estimatedWeeklyProfitBranch2 * currentDisplayRate} prefix="Bs. " />}
        />
        <StatCard title="Productos en Stock" icon={Package} isLoading={isLoadingStats}
          titleBranch1={nameBranch1} 
          valueBranch1={<FormattedNumber value={productsWithStockCountBranch1} decimalPlaces={0} />}
          descriptionBranch1={descriptionStockBranch1}
          titleBranch2={nameBranch2} 
          valueBranch2={<FormattedNumber value={productsWithStockCountBranch2} decimalPlaces={0} />}
          descriptionBranch2={descriptionStockBranch2}
        />
        <StatCard title="Materia Prima Baja" icon={Archive} isLoading={isLoadingStats} variant={lowRawMaterialStockItemsCountBranch1 > 0 || lowRawMaterialStockItemsCountBranch2 > 0 ? 'warning' : 'default'}
          titleBranch1={nameBranch1} 
          valueBranch1={<FormattedNumber value={lowRawMaterialStockItemsCountBranch1} decimalPlaces={0} />}
          numericValue1={lowRawMaterialStockItemsCountBranch1}
          descriptionBranch1={descriptionLowRawBranch1}
          titleBranch2={nameBranch2} 
          valueBranch2={<FormattedNumber value={lowRawMaterialStockItemsCountBranch2} decimalPlaces={0} />}
          numericValue2={lowRawMaterialStockItemsCountBranch2}
          descriptionBranch2={descriptionLowRawBranch2}
        />
        <StatCard title="Productos Bajos Stock" icon={AlertTriangle} isLoading={isLoadingStats} variant={lowStockItemsCountBranch1 > 0 || lowStockItemsCountBranch2 > 0 ? 'warning' : 'default'}
          titleBranch1={nameBranch1} 
          valueBranch1={<FormattedNumber value={lowStockItemsCountBranch1} decimalPlaces={0} />}
          numericValue1={lowStockItemsCountBranch1}
          descriptionBranch1={descriptionLowStockBranch1}
          titleBranch2={nameBranch2} 
          valueBranch2={<FormattedNumber value={lowStockItemsCountBranch2} decimalPlaces={0} />}
          numericValue2={lowStockItemsCountBranch2}
          descriptionBranch2={descriptionLowStockBranch2}
        />
        <StatCard title="Créditos Pendientes (Global)" icon={CreditCardIcon} isLoading={isLoadingStats}
          valueBranch1={<FormattedNumber value={totalCredits} prefix="$" />}
          numericValue1={totalCredits}
          descriptionBranch1={
            <>
              Vencido: <FormattedNumber value={overdueCreditsAmountUSD} prefix="$" />
              , Por Vencer (próx. {CREDITS_DUE_SOON_DAYS} días): <FormattedNumber value={creditsDueSoonAmountUSD} prefix="$" />. 
              Total Equiv: <FormattedNumber value={totalCredits * currentDisplayRate} prefix="Bs. " />
            </>
          }
          variant={overdueCreditsAmountUSD > 0 ? 'destructive' : creditsDueSoonAmountUSD > 0 ? 'warning' : 'default'}
        />
        <StatCard title="Órdenes Compra Pendientes" icon={Receipt} isLoading={isLoadingStats} variant={pendingOrdersBranch1 > 0 || pendingOrdersBranch2 > 0 ? 'warning' : 'default'}
          titleBranch1={nameBranch1} 
          valueBranch1={<FormattedNumber value={pendingOrdersBranch1} decimalPlaces={0} />}
          numericValue1={pendingOrdersBranch1}
          descriptionBranch1={descriptionPendingOrdersBranch1}
          titleBranch2={nameBranch2} 
          valueBranch2={<FormattedNumber value={pendingOrdersBranch2} decimalPlaces={0} />}
          numericValue2={pendingOrdersBranch2}
          descriptionBranch2={descriptionPendingOrdersBranch2}
        />
      </div>

      <div className="grid gap-6 md:grid-cols-2">
        <Card className="shadow-lg col-span-2 lg:col-span-1">
          <CardHeader><CardTitle className="flex items-center gap-2"><BarChartIcon className="h-5 w-5 text-primary" /> Top {TOP_N_PRODUCTS_DASHBOARD} Productos Vendidos (Global - Últimos 7 Días)</CardTitle><CardDescription>Cantidad de unidades vendidas por producto.</CardDescription></CardHeader>
          <CardContent className="h-[300px] w-full">
            {isLoadingStats || productSalesChartData.length === 0 ? (<div className="h-full flex items-center justify-center bg-muted/50 rounded-md"><p className="text-muted-foreground">{isLoadingStats ? "Cargando datos del gráfico..." : "No hay datos de ventas de productos para mostrar."}</p></div>) : (
              <ChartContainer config={productSalesChartConfig} className="h-full w-full">
                <BarChart data={productSalesChartData} layout="vertical" margin={{ top: 5, right: 20, left: 20, bottom: 5 }}>
                  <CartesianGrid strokeDasharray="3 3" /><XAxis type="number" allowDecimals={false} tickLine={false} axisLine={false} tickMargin={10} fontSize={12}/><YAxis dataKey="name" type="category" tickLine={false} axisLine={false} tickMargin={5} width={120} interval={0} fontSize={12}/>
                  <ChartTooltip cursor={{ fill: 'hsl(var(--muted))' }} content={<ChartTooltipContent indicator="dot" />}/>
                  <Bar dataKey="quantity" fill="var(--color-quantity)" radius={4} nameKey="name" />
                </BarChart>
              </ChartContainer>
            )}
          </CardContent>
        </Card>
        <Card className="shadow-lg col-span-2 lg:col-span-1">
          <CardHeader><CardTitle>Actividad Reciente</CardTitle><CardDescription>Últimas actualizaciones. Eventos de producción/gastos/compras MP se muestran de la sede que los originó o la sede activa/por defecto.</CardDescription></CardHeader>
          <CardContent>
            {isLoadingStats ? (<p className="text-center text-muted-foreground py-4">Cargando actividad...</p>) : recentActivities.length > 0 ? (
              <Table><TableHeader><TableRow><TableHead className="w-12"></TableHead><TableHead>Tipo (Sede)</TableHead><TableHead>Descripción</TableHead><TableHead className="text-right">Fecha/Hora</TableHead></TableRow></TableHeader>
                <TableBody>{recentActivities.map((activity) => (<TableRow key={`${activity.type}-${activity.id}-${activity.rawDate.toISOString()}`}><TableCell><activity.icon className="h-5 w-5 text-muted-foreground"/></TableCell><TableCell className="font-medium">{activity.type} <span className="text-xs text-muted-foreground">({activity.branchName || 'N/A'})</span></TableCell><TableCell className="text-sm">{activity.description}</TableCell><TableCell className="text-right text-muted-foreground text-xs whitespace-nowrap">{activity.displayTime}</TableCell></TableRow>))}</TableBody>
              </Table>
            ) : (<p className="text-muted-foreground text-center py-4">No hay actividad reciente para mostrar.</p>)}
          </CardContent>
        </Card>
      </div>

      <AlertDialog open={isConfirmRateDeleteOpen} onOpenChange={setIsConfirmRateDeleteOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>¿Confirmar Eliminación?</AlertDialogTitle>
            <AlertDialogDescription>
              ¿Estás seguro de que quieres eliminar la tasa de cambio para el día {rateToDelete && format(parseISO(rateToDelete.date), "dd/MM/yyyy", { locale: es })}?
              Esta acción no se puede deshacer.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={() => setRateToDelete(null)}>Cancelar</AlertDialogCancel>
            <AlertDialogAction onClick={handleConfirmDeleteRate} className={cn(buttonVariants({ variant: "destructive" }))}>
              Eliminar
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}


// --- account-movements ---

"use client";

import React, { useState, useEffect, useCallback } from 'react';
import { usePathname } from 'next/navigation';
import { PageHeader } from '@/components/page-header';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Popover, PopoverTrigger, PopoverContent } from '@/components/ui/popover';
import { Calendar } from '@/components/ui/calendar';
import { Landmark, ArrowDownCircle, ArrowUpCircle, Loader2, PiggyBank, Banknote, DollarSign, Filter, Calendar as CalendarIcon, FileText as PdfIcon } from 'lucide-react';
import {
  loadFromLocalStorage,
  ACCOUNT_TRANSACTIONS_STORAGE_KEY_BASE,
  COMPANY_ACCOUNTS_STORAGE_KEY_BASE,
  loadExchangeRate,
  type AccountTransaction,
  type CompanyAccountsData,
  type AccountType,
  accountTypeNames,
  accountTypes,
  KEYS
} from '@/lib/data-storage';
import { format, parseISO, isValid, isWithinInterval, startOfDay, endOfDay } from 'date-fns';
import type { DateRange } from "react-day-picker";
import { es } from 'date-fns/locale';
import { Badge } from '@/components/ui/badge';
import { cn } from '@/lib/utils';
import { useToast } from "@/hooks/use-toast";
import jsPDF from 'jspdf';
import 'jspdf-autotable';
import { FormattedNumber } from '@/components/ui/formatted-number';

interface jsPDFWithAutoTable extends jsPDF {
  autoTable: (options: any) => jsPDFWithAutoTable;
}

const ALL_ACCOUNTS_FILTER_VALUE = "all";

export default function AccountMovementsPage() {
  const { toast } = useToast();
  const [allTransactions, setAllTransactions] = useState<AccountTransaction[]>([]);
  const [filteredTransactions, setFilteredTransactions] = useState<AccountTransaction[]>([]);
  const [companyAccounts, setCompanyAccounts] = useState<CompanyAccountsData | null>(null);
  const [globalExchangeRate, setGlobalExchangeRate] = useState<number>(0);
  const [isLoading, setIsLoading] = useState(true);
  const [isGeneratingPdf, setIsGeneratingPdf] = useState(false);
  const pathname = usePathname();

  const [dateRangeFilter, setDateRangeFilter] = useState<DateRange | undefined>(undefined);
  const [selectedAccountIdFilter, setSelectedAccountIdFilter] = useState<AccountType | typeof ALL_ACCOUNTS_FILTER_VALUE>(ALL_ACCOUNTS_FILTER_VALUE);

  const loadAccountData = useCallback(() => {
    setIsLoading(true);
    const currentTransactions = loadFromLocalStorage<AccountTransaction[]>(ACCOUNT_TRANSACTIONS_STORAGE_KEY_BASE);
    
    const sortedTransactions = [...currentTransactions].sort((a, b) => {
      const dateA = a.date && isValid(parseISO(a.date)) ? parseISO(a.date) : new Date(0);
      const dateB = b.date && isValid(parseISO(b.date)) ? parseISO(b.date) : new Date(0);
      
      const dateComparison = dateB.getTime() - dateA.getTime();
      if (dateComparison !== 0) return dateComparison;

      // Ordenamiento secundario por timestamp si las fechas son idénticas
      const timestampA = a.timestamp && isValid(parseISO(a.timestamp)) ? parseISO(a.timestamp).getTime() : 0;
      const timestampB = b.timestamp && isValid(parseISO(b.timestamp)) ? parseISO(b.timestamp).getTime() : 0;
      
      return timestampB - timestampA; // Más reciente primero
    });

    setAllTransactions(sortedTransactions);

    const currentCompanyAccounts = loadFromLocalStorage<CompanyAccountsData>(COMPANY_ACCOUNTS_STORAGE_KEY_BASE, true);
    setCompanyAccounts(currentCompanyAccounts);

    setGlobalExchangeRate(loadExchangeRate());
    setIsLoading(false);
  }, []);

  useEffect(() => {
    if (pathname === '/account-movements') {
      loadAccountData();
    }
    const handleDataUpdate = (event: Event) => {
        const customEvent = event as CustomEvent;
        if (customEvent.detail?.key === KEYS.ACCOUNT_TRANSACTIONS || customEvent.detail?.key === KEYS.COMPANY_ACCOUNTS) {
            if (pathname === '/account-movements') { // Solo recargar si estamos en la página
                loadAccountData();
            }
        }
    };
    window.addEventListener('data-updated', handleDataUpdate);
    return () => {
        window.removeEventListener('data-updated', handleDataUpdate);
    };
  }, [pathname, loadAccountData]);


  const applyFilters = useCallback(() => {
    let transactionsToFilter = [...allTransactions];

    if (dateRangeFilter?.from) {
      const toDate = dateRangeFilter.to ? endOfDay(dateRangeFilter.to) : endOfDay(dateRangeFilter.from);
      transactionsToFilter = transactionsToFilter.filter(transaction => {
        if (!transaction.date || !isValid(parseISO(transaction.date))) return false;
        return isWithinInterval(parseISO(transaction.date), { start: startOfDay(dateRangeFilter.from!), end: toDate });
      });
    }

    if (selectedAccountIdFilter !== ALL_ACCOUNTS_FILTER_VALUE) {
      transactionsToFilter = transactionsToFilter.filter(transaction => transaction.accountId === selectedAccountIdFilter);
    }

    setFilteredTransactions(transactionsToFilter);
  }, [allTransactions, dateRangeFilter, selectedAccountIdFilter]);

  useEffect(() => {
    applyFilters();
  }, [allTransactions, dateRangeFilter, selectedAccountIdFilter, applyFilters]);

  const handleApplyFiltersButton = () => {
    applyFilters(); 
  };

  const handleClearFiltersButton = () => {
    setDateRangeFilter(undefined);
    setSelectedAccountIdFilter(ALL_ACCOUNTS_FILTER_VALUE);
  };

  const getAccountIcon = (accountId?: AccountType): React.ElementType => {
    if (!accountId) return Landmark;
    switch(accountId) {
      case 'vesElectronic': return PiggyBank;
      case 'usdCash': return DollarSign;
      case 'vesCash': return Banknote;
      default: return Landmark;
    }
  }

  const handleGeneratePdf = () => {
    if (filteredTransactions.length === 0) {
      toast({ title: "Sin Datos", description: "No hay transacciones para generar el PDF con los filtros actuales.", variant: "default" });
      return;
    }
    setIsGeneratingPdf(true);
    const doc = new jsPDF() as jsPDFWithAutoTable;

    doc.setFontSize(18);
    doc.text("Panificadora Valladares", 14, 22);
    doc.setFontSize(11);

    let reportSubtitle = "Reporte de Movimientos de Cuenta";
    if (selectedAccountIdFilter !== ALL_ACCOUNTS_FILTER_VALUE && companyAccounts && companyAccounts[selectedAccountIdFilter]) {
      reportSubtitle = `Reporte de Movimientos - ${accountTypeNames[selectedAccountIdFilter]}`;
    }
    
    doc.text(reportSubtitle, 14, 32);
    doc.setFontSize(10);
    
    let currentY = 40;
    
    let dateRangeString = "General";
    if (dateRangeFilter?.from) {
        const fromStr = format(dateRangeFilter.from, "dd/MM/yyyy", { locale: es });
        if (dateRangeFilter.to) {
            const toStr = format(dateRangeFilter.to, "dd/MM/yyyy", { locale: es });
            dateRangeString = `${fromStr} - ${toStr}`;
        } else {
            dateRangeString = `Desde ${fromStr}`;
        }
    }
    doc.text(`Período: ${dateRangeString}`, 14, currentY);
    currentY += 6;

    if (selectedAccountIdFilter === ALL_ACCOUNTS_FILTER_VALUE) {
        doc.text(`Cuentas: Todas las Cuentas (Filtradas)`, 14, currentY);
        currentY += 6;
    }


    const head = [["Fecha", "Descripción", "Cuenta", "Tipo", "Categoría", "Monto", "Tasa", "Equivalente", "Saldo Post-Tx"]];
    const body = filteredTransactions.map(tx => {
      const accountName = tx.accountId ? accountTypeNames[tx.accountId] : "General (Antigua)";
      const amountPrefix = tx.type === 'ingreso' ? '+' : '-';
      const currencySymbol = tx.currency === 'USD' ? '$' : 'Bs.';
      const otherCurrencySymbol = tx.currency === 'USD' ? 'Bs.' : '$';
      const amountDisplay = `${amountPrefix}${currencySymbol} ${tx.amount.toFixed(2)}`;
      const otherAmountDisplay = tx.amountInOtherCurrency !== undefined ? `${amountPrefix}${otherCurrencySymbol} ${tx.amountInOtherCurrency.toFixed(2)}` : '-';
      const balanceAfterDisplay = tx.balanceAfterTransaction !== undefined ? `${currencySymbol} ${tx.balanceAfterTransaction.toFixed(2)}` : '-';

      return [
        tx.date && isValid(parseISO(tx.date)) ? format(parseISO(tx.date), "dd/MM/yy", { locale: es }) : '-',
        tx.description,
        accountName,
        tx.type.charAt(0).toUpperCase() + tx.type.slice(1),
        tx.category || '-',
        amountDisplay,
        tx.exchangeRateOnTransactionDate ? tx.exchangeRateOnTransactionDate.toFixed(2) : '-',
        otherAmountDisplay,
        balanceAfterDisplay
      ];
    });

    doc.autoTable({
      startY: currentY + 2,
      head: head,
      body: body,
      theme: 'striped',
      headStyles: { fillColor: [34, 139, 34] }, 
      didDrawPage: (data) => {
        doc.setFontSize(8);
        doc.text(`Página ${doc.internal.pages.L > 0 ? doc.internal.pages.P : doc.internal.pages.L}`, data.settings.margin.left, doc.internal.pageSize.height - 10);
      }
    });
    
    let pdfFilename = `reporte_movimientos_${selectedAccountIdFilter === ALL_ACCOUNTS_FILTER_VALUE ? 'todas' : selectedAccountIdFilter}`;
    if (dateRangeFilter?.from) {
        pdfFilename += `_${format(dateRangeFilter.from, "yyyyMMdd")}`;
        if (dateRangeFilter.to) pdfFilename += `_a_${format(dateRangeFilter.to, "yyyyMMdd")}`;
    }
    pdfFilename += '.pdf';

    doc.save(pdfFilename);
    toast({ title: "Reporte Generado", description: `PDF ${pdfFilename} descargado.` });
    setIsGeneratingPdf(false);
  };

  if (isLoading || !companyAccounts) {
    return (
      <div className="flex items-center justify-center min-h-[calc(100vh-10rem)]">
        <Loader2 className="h-12 w-12 animate-spin text-primary" />
        <p className="ml-4 text-lg">Cargando movimientos de cuenta...</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <PageHeader
        title="Movimientos de Cuentas"
        description="Saldos y historial de transacciones para cada cuenta de la empresa."
        icon={Landmark}
      />

      <Card className="shadow-lg">
        <CardHeader>
          <CardTitle>Saldos Actuales de las Cuentas</CardTitle>
        </CardHeader>
        <CardContent className="grid grid-cols-1 md:grid-cols-3 gap-4">
          {(Object.keys(companyAccounts) as AccountType[]).map(accountId => {
            const account = companyAccounts[accountId];
            if (!account) return null;
            const Icon = getAccountIcon(accountId);
            let balanceDisplay: React.ReactNode = "";
            let equivalentDisplay: React.ReactNode = "";

            if (account.currency === 'VES') {
              balanceDisplay = <FormattedNumber value={account.balance} prefix="Bs. " />;
              if (globalExchangeRate > 0) {
                equivalentDisplay = <FormattedNumber value={account.balance / globalExchangeRate} prefix="Equiv. $" />;
              }
            } else { 
              balanceDisplay = <FormattedNumber value={account.balance} prefix="$" />;
              if (globalExchangeRate > 0) {
                equivalentDisplay = <FormattedNumber value={account.balance * globalExchangeRate} prefix="Equiv. Bs. " />;
              }
            }

            return (
              <div key={accountId} className="p-4 border rounded-lg bg-muted/50 flex flex-col items-center text-center">
                <Icon className="h-8 w-8 text-primary mb-2" />
                <p className="text-sm font-medium text-muted-foreground">{accountTypeNames[accountId]}</p>
                <p className="text-2xl font-bold text-primary">{balanceDisplay}</p>
                {equivalentDisplay && <p className="text-xs text-muted-foreground">{equivalentDisplay}</p>}
                 {account.lastTransactionDate && isValid(parseISO(account.lastTransactionDate)) && (
                    <p className="text-xs text-muted-foreground mt-1">
                      Últ. Mov: {format(parseISO(account.lastTransactionDate), "dd/MM/yy HH:mm", { locale: es })}
                    </p>
                  )}
              </div>
            );
          })}
        </CardContent>
      </Card>

      <Card className="shadow-lg">
        <CardHeader>
          <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
            <div>
              <CardTitle>Historial General de Transacciones</CardTitle>
              <CardDescription>
                {filteredTransactions.length > 0
                  ? "Lista de todos los ingresos y egresos registrados, la más reciente primero."
                  : "No hay transacciones para los filtros seleccionados."}
              </CardDescription>
            </div>
            <div className="flex flex-col sm:flex-row items-center gap-2 w-full sm:w-auto flex-wrap">
              <Popover>
                <PopoverTrigger asChild>
                  <Button
                    id="date-filter-account-movements"
                    variant={"outline"}
                    className={cn("w-full sm:w-auto min-w-[200px] justify-start text-left font-normal", !dateRangeFilter && "text-muted-foreground")}
                    disabled={isLoading || isGeneratingPdf}
                  >
                    <CalendarIcon className="mr-2 h-4 w-4" />
                    {dateRangeFilter?.from ? (
                      dateRangeFilter.to ? (
                        <>
                          {format(dateRangeFilter.from, "LLL dd, y", { locale: es })} -{" "}
                          {format(dateRangeFilter.to, "LLL dd, y", { locale: es })}
                        </>
                      ) : (
                        format(dateRangeFilter.from, "LLL dd, y", { locale: es })
                      )
                    ) : (
                      <span>Filtrar por Fecha</span>
                    )}
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0" align="end">
                  <Calendar
                    initialFocus
                    mode="range"
                    defaultMonth={dateRangeFilter?.from}
                    selected={dateRangeFilter}
                    onSelect={setDateRangeFilter}
                    numberOfMonths={2}
                    locale={es}
                    disabled={isLoading || isGeneratingPdf}
                  />
                </PopoverContent>
              </Popover>
              <Select 
                value={selectedAccountIdFilter} 
                onValueChange={(value) => setSelectedAccountIdFilter(value as AccountType | typeof ALL_ACCOUNTS_FILTER_VALUE)}
                disabled={isLoading || isGeneratingPdf}
              >
                <SelectTrigger className="w-full sm:w-auto min-w-[180px]">
                  <SelectValue placeholder="Filtrar por Cuenta" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value={ALL_ACCOUNTS_FILTER_VALUE}>Todas las Cuentas</SelectItem>
                  {accountTypes
                    .slice()
                    .sort((a, b) => accountTypeNames[a].localeCompare(accountTypeNames[b]))
                    .map(accType => (
                      <SelectItem key={accType} value={accType}>{accountTypeNames[accType]}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <Button onClick={handleApplyFiltersButton} className="w-full sm:w-auto" disabled={isLoading || isGeneratingPdf}>
                <Filter className="mr-2 h-4 w-4" /> Aplicar Filtros
              </Button>
              <Button onClick={handleClearFiltersButton} variant="outline" className="w-full sm:w-auto" disabled={isLoading || isGeneratingPdf}>Limpiar</Button>
              <Button onClick={handleGeneratePdf} variant="secondary" className="w-full sm:w-auto" disabled={isLoading || isGeneratingPdf || filteredTransactions.length === 0}>
                {isGeneratingPdf ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <PdfIcon className="mr-2 h-4 w-4" />}
                {isGeneratingPdf ? "Generando..." : "Descargar PDF"}
              </Button>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          {filteredTransactions.length > 0 ? (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Fecha/Hora</TableHead>
                  <TableHead>Descripción</TableHead>
                  <TableHead>Cuenta</TableHead>
                  <TableHead>Tipo</TableHead>
                  <TableHead>Categoría</TableHead>
                  <TableHead className="text-right">Monto</TableHead>
                  <TableHead className="text-right">Tasa Aplicada</TableHead>
                  <TableHead className="text-right">Equivalente</TableHead>
                  <TableHead className="text-right">Saldo Post (Cuenta)</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {filteredTransactions.map((transaction) => {
                  const accountName = transaction.accountId ? accountTypeNames[transaction.accountId] : "General (Antigua)";
                  const amountPrefix = transaction.type === 'ingreso' ? '+' : '-';
                  const amountColor = transaction.type === 'ingreso' ? 'text-green-600' : 'text-red-600';
                  
                  const transactionAmount = typeof transaction.amount === 'number' ? transaction.amount : 0;
                  const currencySymbol = transaction.currency === 'USD' ? '$' : 'Bs.';
                  
                  let otherCurrencySymbol = '';
                  let otherAmountDisplay: React.ReactNode = '-';
                  if (transaction.amountInOtherCurrency !== undefined && typeof transaction.amountInOtherCurrency === 'number') {
                    otherCurrencySymbol = transaction.currency === 'USD' ? 'Bs.' : '$';
                    otherAmountDisplay = (
                      <FormattedNumber
                        value={transaction.amountInOtherCurrency}
                        prefix={`${amountPrefix}${otherCurrencySymbol} `}
                      />
                    );
                  }

                  return (
                    <TableRow key={transaction.id}>
                      <TableCell>
                        {transaction.date && isValid(parseISO(transaction.date)) ? format(parseISO(transaction.date), "dd/MM/yy", { locale: es }) : '-'}
                        {transaction.timestamp && isValid(parseISO(transaction.timestamp)) && (
                            <span className="block text-xs text-muted-foreground">
                                {format(parseISO(transaction.timestamp), "HH:mm", { locale: es })}
                            </span>
                        )}
                      </TableCell>
                      <TableCell className="font-medium max-w-xs truncate" title={transaction.description}>{transaction.description}</TableCell>
                      <TableCell>{accountName}</TableCell>
                      <TableCell>
                        <Badge
                          variant={transaction.type === 'ingreso' ? 'default' : 'destructive'}
                          className={cn(
                            transaction.type === 'ingreso'
                              ? 'bg-green-500/20 text-green-700 dark:text-green-400 border-green-500/50'
                              : 'bg-red-500/20 text-red-700 dark:text-red-400 border-red-500/50'
                          )}
                        >
                          {transaction.type === 'ingreso' ?
                            <ArrowUpCircle className="mr-1 h-3.5 w-3.5" /> :
                            <ArrowDownCircle className="mr-1 h-3.5 w-3.5" />
                          }
                          {transaction.type.charAt(0).toUpperCase() + transaction.type.slice(1)}
                        </Badge>
                      </TableCell>
                      <TableCell>{transaction.category || '-'}</TableCell>
                      <TableCell className={cn("text-right font-semibold", amountColor)}>
                        <FormattedNumber value={transactionAmount} prefix={`${amountPrefix}${currencySymbol} `} />
                      </TableCell>
                      <TableCell className="text-right">
                        {transaction.exchangeRateOnTransactionDate ? <FormattedNumber value={transaction.exchangeRateOnTransactionDate}/> : '-'}
                      </TableCell>
                      <TableCell className={cn("text-right font-semibold", amountColor)}>
                        {otherAmountDisplay}
                      </TableCell>
                      <TableCell className="text-right">
                        {transaction.balanceAfterTransaction !== undefined && typeof transaction.balanceAfterTransaction === 'number' 
                          ? <FormattedNumber value={transaction.balanceAfterTransaction} prefix={`${currencySymbol} `} />
                          : '-'
                        }
                      </TableCell>
                    </TableRow>
                  );
                })}
              </TableBody>
            </Table>
          ) : (
            !isLoading && <p className="text-center text-muted-foreground py-8">No hay transacciones que coincidan con los filtros aplicados.</p>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
    
// --- accounts-receivable ---


"use client";

import React, { useState, useEffect, useCallback, ChangeEvent } from 'react';
import { PageHeader } from '@/components/page-header';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogClose } from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Textarea } from '@/components/ui/textarea';
import { Popover, PopoverTrigger, PopoverContent } from '@/components/ui/popover';
import { Calendar } from "@/components/ui/calendar";
import { ScrollArea } from '@/components/ui/scroll-area';
import { format, parseISO, isValid, differenceInDays, isWithinInterval, startOfDay, endOfDay, parse } from 'date-fns';
import type { DateRange } from "react-day-picker";
import { es } from 'date-fns/locale';
import { cn } from '@/lib/utils';
import { CreditCard, DollarSign, Calendar as CalendarIcon, Loader2, FileText as InvoiceHistoryIcon, Building, Filter, Eye, XCircle, PlusCircle, ShieldCheck } from 'lucide-react';
import { useToast } from "@/hooks/use-toast";
import {
  customersData as initialCustomersDataGlobal,
  saveCustomersData,
  type Customer,
  paymentsData as initialPaymentsDataGlobal,
  savePaymentsData,
  type Payment,
  type PaymentMethodType,
  paymentMethodList,
  type AccountTransaction,
  loadCompanyAccountsData,
  saveCompanyAccountsData,
  type CompanyAccountsData,
  type AccountType,
  accountTypeNames,
  loadExchangeRate,
  userProfileData,
  salesData as initialSalesDataGlobal,
  saveSalesData,
  type Sale,
  getInvoiceStatus,
  KEYS,
  loadFromLocalStorageForBranch,
  saveToLocalStorageForBranch,
  type PendingFundTransfer,
  savePendingFundTransfersData,
  pendingFundTransfersData as initialPendingFundTransfersData,
  availableBranches,
  type PaymentBranchApplication,
  calculateCustomerBalance,
  updateGlobalSaleDataAndFinances
} from '@/lib/data-storage';
import { processPayment, type ProcessPaymentInput, type ProcessPaymentOutput } from '@/ai/flows/process-payment-flow';
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion";
import { Badge } from '@/components/ui/badge';
import { FormattedNumber } from '@/components/ui/formatted-number';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Checkbox } from '@/components/ui/checkbox';


interface EnrichedPaymentOutput extends ProcessPaymentOutput {
    fileName?: string;
    exchangeRate?: number;
    amountUSD?: number;
}

interface ManualPaymentEntry {
    id: string;
    date: Date;
    amount: string;
    currency: 'USD' | 'VES';
    method: PaymentMethodType;
    exchangeRate: string;
    referenceNumber?: string;
    notes?: string;
}

export default function AccountsReceivablePage() {
  const { toast } = useToast();
  const [customersWithBalance, setCustomersWithBalance] = useState<Customer[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [exchangeRate, setExchangeRate] = useState<number>(0);

  const [isRegisterPaymentDialogOpen, setIsRegisterPaymentDialogOpen] = useState(false);
  const [payingCustomer, setPayingCustomer] = useState<Customer | null>(null);
  const [pendingInvoicesForCustomer, setPendingInvoicesForCustomer] = useState<Sale[]>([]);
  const [selectedInvoiceId, setSelectedInvoiceId] = useState<string>('');
  
  const [paymentAmountUSD, setPaymentAmountUSD] = useState<number>(0);
  const [isSubmittingPayment, setIsSubmittingPayment] = useState(false);

  const [paidToBranchIdDialog, setPaidToBranchIdDialog] = useState<string>('');
  
  const [isInvoiceHistoryDialogOpenAR, setIsInvoiceHistoryDialogOpenAR] = useState(false);
  const [selectedCustomerForInvoicesAR, setSelectedCustomerForInvoicesAR] = useState<Customer | null>(null);
  const [customerInvoicesAR, setCustomerInvoicesAR] = useState<Sale[]>([]);
  const [invoiceHistoryDateRangeFilterAR, setInvoiceHistoryDateRangeFilterAR] = useState<DateRange | undefined>(undefined);

  const [paymentImageFiles, setPaymentImageFiles] = useState<File[]>([]);
  const [batchPayments, setBatchPayments] = useState<EnrichedPaymentOutput[]>([]);
  const [manualPayments, setManualPayments] = useState<ManualPaymentEntry[]>([]);
  const [isAnalyzingPayment, setIsAnalyzingPayment] = useState(false);
  const [paymentNotes, setPaymentNotes] = useState('');

  // Popover control
  const [openDatePickers, setOpenDatePickers] = useState<Record<string, boolean>>({});
  const [openAnalyzedDatePickers, setOpenAnalyzedDatePickers] = useState<Record<number, boolean>>({});


  // Saldo a favor
  const [customerBalance, setCustomerBalance] = useState(0);
  const [applyCustomerCredit, setApplyCustomerCredit] = useState(false);


  const formatVesPrice = (usdPrice: number): React.ReactNode => {
    if (exchangeRate > 0 && typeof usdPrice === 'number') {
      return <FormattedNumber value={usdPrice * exchangeRate} prefix="Bs. " />;
    }
    return "Bs. --";
  };

  const loadData = useCallback(() => {
    setIsLoading(true);
    const allCustomers = [...initialCustomersDataGlobal];
    const filteredCustomers = allCustomers
      .map(c => ({ ...c, balance: calculateCustomerBalance(c.id) }))
      .filter(c => c.balance !== 0) 
      .sort((a,b) => b.balance - a.balance); 
    setCustomersWithBalance(filteredCustomers);

    const rate = loadExchangeRate(); 
    setExchangeRate(rate);

    if (availableBranches.length > 0 && !paidToBranchIdDialog) {
        setPaidToBranchIdDialog(availableBranches[0].id);
    }
    setIsLoading(false);
  }, [paidToBranchIdDialog]);

  useEffect(() => {
    loadData();
    const handleDataUpdate = (event: Event) => {
      const customEvent = event as CustomEvent;
      if (
        customEvent.detail?.key === KEYS.CUSTOMERS ||
        customEvent.detail?.key === KEYS.SALES ||
        customEvent.detail?.key === KEYS.PAYMENTS ||
        customEvent.detail?.key === KEYS.COMPANY_ACCOUNTS ||
        customEvent.detail?.key === KEYS.ACCOUNT_TRANSACTIONS ||
        customEvent.detail?.key === KEYS.PENDING_FUND_TRANSFERS ||
        customEvent.detail?.key === KEYS.EXCHANGE_RATE_HISTORY
      ) {
        loadData();
      }
    };
    window.addEventListener('data-updated', handleDataUpdate);
    return () => {
      window.removeEventListener('data-updated', handleDataUpdate);
    };
  }, [loadData]);


  useEffect(() => {
    if (payingCustomer) {
      const invoices = initialSalesDataGlobal.filter(
            sale => sale.customerId === payingCustomer.id && getInvoiceStatus(sale, initialPaymentsDataGlobal) !== 'Completada'
      ).sort((a,b) => (a.date && b.date) ? parseISO(a.date).getTime() - parseISO(b.date).getTime() : 0);

      setPendingInvoicesForCustomer(invoices);
      
      const balance = calculateCustomerBalance(payingCustomer.id);
      setCustomerBalance(balance);
    } else {
      setPendingInvoicesForCustomer([]);
      setCustomerBalance(0);
    }
    setApplyCustomerCredit(false);
  }, [payingCustomer]);


  const handleOpenRegisterPaymentDialog = (customer: Customer) => {
    setPayingCustomer(customer);
    setPaymentNotes('');
    setPaymentImageFiles([]);
    setBatchPayments([]);
    
    const initialRate = loadExchangeRate();
    const newManualPaymentEntry: ManualPaymentEntry = {
        id: `manual-${Date.now()}`, date: new Date(), amount: '', currency: 'VES',
        method: 'Pago Móvil (VES)', exchangeRate: initialRate > 0 ? initialRate.toString() : ''
    };
    setManualPayments([newManualPaymentEntry]);

    const initialBranchId = availableBranches.length > 0 ? availableBranches[0].id : '';
    setPaidToBranchIdDialog(initialBranchId);

    setIsRegisterPaymentDialogOpen(true);
  };

  const handlePaymentImageFileChange = (event: ChangeEvent<HTMLInputElement>) => {
    if (event.target.files) {
      setPaymentImageFiles(Array.from(event.target.files));
    } else {
      setPaymentImageFiles([]);
    }
  };

  const handleAnalyzeBatchPayments = async () => {
    if (!paymentImageFiles || paymentImageFiles.length === 0) {
        toast({ title: "Sin imágenes", description: "Por favor, selecciona una o más imágenes de confirmación de pago.", variant: "destructive" });
        return;
    }
    setIsAnalyzingPayment(true);
    
    const analysisPromises = paymentImageFiles.map(file => {
        return new Promise<EnrichedPaymentOutput>((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = async () => {
                try {
                    const paymentImageUri = reader.result as string;
                    const analysisInput: ProcessPaymentInput = { paymentImageUri };
                    const response = await processPayment(analysisInput);

                    let amountUSD: number | undefined;
                    let exchangeRateForPayment: number | undefined;

                    if (response.date && response.amount) {
                        const paymentDateObj = parse(response.date, 'yyyy-MM-dd', new Date());
                        if (isValid(paymentDateObj)) {
                            exchangeRateForPayment = loadExchangeRate(paymentDateObj);
                            if (exchangeRateForPayment > 0) {
                                amountUSD = response.amount / exchangeRateForPayment;
                            }
                        }
                    }

                    const enrichedResponse: EnrichedPaymentOutput = {
                        ...response,
                        fileName: file.name,
                        exchangeRate: exchangeRateForPayment,
                        amountUSD: amountUSD,
                    };

                    resolve(enrichedResponse);
                } catch (aiError) {
                    console.error(`Error analyzing ${file.name}:`, aiError);
                    resolve({
                        analysisNotes: `Error al analizar ${file.name}.`,
                        fileName: file.name
                    });
                }
            };
            reader.onerror = (error) => {
                reject(error);
            };
        });
    });

    try {
        const results = await Promise.all(analysisPromises);
        setBatchPayments(prev => [...prev, ...results]);
        toast({
            title: 'Análisis Completado',
            description: `${results.filter(r => r.amount).length} de ${paymentImageFiles.length} imágenes analizadas. Revisa los resultados.`,
            duration: 7000,
        });

    } catch (error) {
        console.error("Error processing batch payment analysis:", error);
        toast({ title: 'Error Inesperado', description: 'Ocurrió un error al procesar las imágenes.', variant: 'destructive' });
    } finally {
        setIsAnalyzingPayment(false);
        setPaymentImageFiles([]); 
    }
  };

  const handleRemoveBatchItem = (indexToRemove: number) => {
    setBatchPayments(prev => prev.filter((_, index) => index !== indexToRemove));
  };

  const handleAddManualPayment = () => {
    const rate = loadExchangeRate();
    const newEntry: ManualPaymentEntry = {
      id: `manual-${Date.now()}`,
      date: new Date(),
      amount: '',
      currency: 'VES',
      method: 'Pago Móvil (VES)',
      exchangeRate: rate > 0 ? rate.toString() : ''
    };
    setManualPayments(prev => [...prev, newEntry]);
  };

  const handleRemoveManualPayment = (id: string) => {
    setManualPayments(prev => prev.filter(p => p.id !== id));
  };
  
  const handleManualPaymentChange = (id: string, field: keyof ManualPaymentEntry, value: any) => {
    setManualPayments(prev => prev.map(p => {
      if (p.id === id) {
        const updatedPayment = { ...p, [field]: value };
        if (field === 'date') {
          const rate = loadExchangeRate(value);
          updatedPayment.exchangeRate = rate > 0 ? rate.toString() : '';
        }
        if(field === 'currency') {
            if (value === 'USD') updatedPayment.method = 'Efectivo USD';
            else updatedPayment.method = 'Pago Móvil (VES)';
        }
        if (field === 'method') {
            if(value === 'Efectivo USD') updatedPayment.currency = 'USD';
            else updatedPayment.currency = 'VES';
        }
        return updatedPayment;
      }
      return p;
    }));
  };
  
  const handleBatchPaymentDateChange = (index: number, newDate: Date | undefined) => {
    if (!newDate) return;

    setBatchPayments(prev => prev.map((p, i) => {
      if (i === index && p.amount) {
        const newDateStr = format(newDate, "yyyy-MM-dd");
        const newExchangeRate = loadExchangeRate(newDate);
        const newAmountUSD = newExchangeRate > 0 ? p.amount / newExchangeRate : undefined;
        return {
          ...p,
          date: newDateStr,
          exchangeRate: newExchangeRate,
          amountUSD: newAmountUSD,
        };
      }
      return p;
    }));
  };

  const handleBatchPaymentAmountChange = (index: number, newAmountVes: number) => {
    setBatchPayments(prev => prev.map((p, i) => {
      if (i === index) {
        const rate = p.exchangeRate || 0;
        const newAmountUSD = rate > 0 ? newAmountVes / rate : undefined;
        return {
          ...p,
          amount: newAmountVes,
          amountUSD: newAmountUSD
        }
      }
      return p;
    }));
  }

  useEffect(() => {
    const totalFromBatch = batchPayments.reduce((sum, p) => sum + (p.amountUSD || 0), 0);
    const totalFromManual = manualPayments.reduce((sum, p) => {
      const amount = parseFloat(p.amount);
      if (isNaN(amount) || amount <= 0) return sum;
      if (p.currency === 'USD') return sum + amount;
      const rate = parseFloat(p.exchangeRate);
      if (isNaN(rate) || rate <= 0) return sum;
      return sum + (amount / rate);
    }, 0);
    
    setPaymentAmountUSD(totalFromBatch + totalFromManual);

  }, [batchPayments, manualPayments]);



  const handleSavePayment = () => {
    if (!payingCustomer) {
      toast({ title: "Error", description: "Se requiere un cliente.", variant: "destructive" });
      return;
    }

    const totalFromPayments = paymentAmountUSD;
    const creditToApply = applyCustomerCredit && customerBalance < -0.01 ? Math.abs(customerBalance) : 0;
    const totalAmountToApply = totalFromPayments + creditToApply;

    if (totalAmountToApply <= 0) {
        toast({ title: "Error", description: "El monto total a aplicar a la deuda debe ser positivo.", variant: "destructive" });
        return;
    }
    
    // Validation for manual payments
    for (const p of manualPayments) {
        const amount = parseFloat(p.amount);
        if (isNaN(amount) || amount <= 0) continue; // Skip empty/invalid manual payments
        if ((p.method === 'Pago Móvil (VES)' || p.method === 'Transferencia (VES)') && (!p.referenceNumber || !/^\d{6}$/.test(p.referenceNumber))) {
            toast({ title: "Error de Referencia", description: `La referencia para el pago manual de ${p.amount} ${p.currency} debe ser de 6 dígitos.`, variant: "destructive" });
            return; // Stop the submission
        }
    }
    
    const allExistingPayments = initialPaymentsDataGlobal;
    const allNewReferenceNumbers = new Set<string>();

    for (const p of batchPayments) {
        if (p.referenceNumber) {
            const isDuplicate = allExistingPayments.some(existingP => 
                existingP.referenceNumber === p.referenceNumber &&
                (existingP.paymentMethod === 'Pago Móvil (VES)' || existingP.paymentMethod === 'Transferencia (VES)')
            );
            if (isDuplicate) {
                toast({ title: "Error: Pago Duplicado", description: `La referencia ${p.referenceNumber} del archivo ${p.fileName} ya existe.`, variant: "destructive", duration: 7000 });
                return;
            }
            if (allNewReferenceNumbers.has(p.referenceNumber)) {
                toast({ title: "Error: Referencia Duplicada", description: `La referencia ${p.referenceNumber} está duplicada en este lote de pagos.`, variant: "destructive", duration: 7000 });
                return;
            }
            allNewReferenceNumbers.add(p.referenceNumber);
        }
    }

    for (const m of manualPayments) {
        const amount = parseFloat(m.amount);
        if (isNaN(amount) || amount <= 0) continue;
        if ((m.method === 'Pago Móvil (VES)' || m.method === 'Transferencia (VES)') && m.referenceNumber) {
            const isDuplicate = allExistingPayments.some(existingP => 
                existingP.referenceNumber === m.referenceNumber &&
                (existingP.paymentMethod === 'Pago Móvil (VES)' || existingP.paymentMethod === 'Transferencia (VES)')
            );
            if (isDuplicate) {
                toast({ title: "Error: Pago Duplicado", description: `La referencia manual ${m.referenceNumber} ya existe.`, variant: "destructive", duration: 7000 });
                return;
            }
            if (allNewReferenceNumbers.has(m.referenceNumber)) {
                 toast({ title: "Error: Referencia Duplicada", description: `La referencia ${m.referenceNumber} está duplicada en este lote de pagos.`, variant: "destructive", duration: 7000 });
                return;
            }
            allNewReferenceNumbers.add(m.referenceNumber);
        }
    }


    setIsSubmittingPayment(true);
    
    const paymentsToCreate: Partial<Payment>[] = [];
    const parentId = `PAY-P-${Date.now().toString().slice(-6)}`;
    const generalNotes = paymentNotes.trim();
    
    // Add Credit Payment First if applied
    if (creditToApply > 0) {
        paymentsToCreate.push({
            id: `PAY-CREDIT-${Date.now().toString().slice(-4)}`,
            parentPaymentId: parentId,
            customerId: payingCustomer.id,
            customerName: payingCustomer.name,
            paymentDate: format(new Date(), "yyyy-MM-dd"),
            amountPaidInput: creditToApply,
            currencyPaidInput: 'USD',
            amountAppliedToDebtUSD: creditToApply,
            paymentMethod: 'Crédito a Favor',
            paidToBranchId: 'panaderia_principal',
            paidToAccountId: 'vesElectronic', 
            status: 'verificado',
            notes: `Aplicación de saldo a favor existente.${generalNotes ? ` ${generalNotes}` : ''}`.trim(),
            verifiedBy: 'Sistema',
            verificationDate: new Date().toISOString(),
            creationTimestamp: new Date().toISOString(),
        });
    }

    batchPayments.forEach((p, index) => {
      if (p.amount && p.referenceNumber && p.amountUSD) {
          const paymentDateObj = p.date ? parse(p.date, 'yyyy-MM-dd', new Date()) : new Date();
          const paymentStatusForNewPayment: Payment['status'] = 'pendiente de verificación';
          const exchangeRateForPayment = p.exchangeRate || loadExchangeRate(paymentDateObj);
          
          let notesForThisPayment = `(Auto) Ref: ${p.referenceNumber} - Monto: ${p.amount.toFixed(2)} VES - Tasa: ${exchangeRateForPayment?.toFixed(2) || 'N/A'}. ${p.analysisNotes || ''}`.trim();
          if (generalNotes) notesForThisPayment += ` ${generalNotes}`;

          const newPayment: Partial<Payment> = {
            id: `PAY-AI-${Date.now().toString().slice(-6)}-${index}`,
            parentPaymentId: parentId,
            customerId: payingCustomer.id,
            customerName: payingCustomer.name,
            paymentDate: format(paymentDateObj, "yyyy-MM-dd"),
            amountPaidInput: p.amount,
            currencyPaidInput: 'VES',
            exchangeRateAtPayment: exchangeRateForPayment,
            amountAppliedToDebtUSD: p.amountUSD,
            paymentMethod: 'Pago Móvil (VES)',
            paidToBranchId: paidToBranchIdDialog,
            paidToAccountId: 'vesElectronic',
            status: paymentStatusForNewPayment,
            referenceNumber: p.referenceNumber,
            notes: notesForThisPayment.trim(),
            creationTimestamp: new Date().toISOString(),
          };
          paymentsToCreate.push(newPayment);
      }
    });

    manualPayments.forEach((m, index) => {
        const amount = parseFloat(m.amount);
        if(!isNaN(amount) && amount > 0) {
            const paymentStatusForNewPayment: Payment['status'] = (m.method === 'Efectivo USD' || m.method === 'Efectivo VES') ? 'verificado' : 'pendiente de verificación';
            const rate = parseFloat(m.exchangeRate);
            const amountUSD = m.currency === 'USD' ? amount : (rate > 0 ? amount / rate : 0);
            
            const getAccountIdForMethod = (): AccountType => {
                if(m.method === 'Efectivo USD') return 'usdCash';
                if(m.method === 'Efectivo VES') return 'vesCash';
                return 'vesElectronic';
            };
            
            let notesForThisPayment = m.notes || '';
            if (generalNotes) notesForThisPayment = `${notesForThisPayment} ${generalNotes}`.trim();

            const newPayment: Partial<Payment> = {
                id: `PAY-MANUAL-${Date.now().toString().slice(-6)}-${index}`,
                parentPaymentId: parentId,
                customerId: payingCustomer.id,
                customerName: payingCustomer.name,
                paymentDate: format(m.date, "yyyy-MM-dd"),
                amountPaidInput: amount,
                currencyPaidInput: m.currency,
                exchangeRateAtPayment: m.currency === 'VES' ? rate : undefined,
                amountAppliedToDebtUSD: amountUSD,
                paymentMethod: m.method,
                paidToBranchId: paidToBranchIdDialog,
                paidToAccountId: getAccountIdForMethod(),
                status: paymentStatusForNewPayment,
                notes: notesForThisPayment,
                referenceNumber: m.referenceNumber,
                verifiedBy: paymentStatusForNewPayment === 'verificado' ? userProfileData.fullName : undefined,
                verificationDate: paymentStatusForNewPayment === 'verificado' ? new Date().toISOString() : undefined,
                creationTimestamp: new Date().toISOString(),
            };
            paymentsToCreate.push(newPayment);
        }
    });
    
    if (paymentsToCreate.length === 0) {
        toast({ title: "Sin Pagos Válidos", description: "No se encontraron pagos válidos para registrar.", variant: "destructive" });
        setIsSubmittingPayment(false);
        return;
    }

    const remainingAmountToApplyUSD = paymentAmountUSD - creditToApply;
    const finalPayments: Payment[] = [];
    
    // Add credit payment to final list immediately
    const creditPaymentFromList = paymentsToCreate.find(p => p.paymentMethod === 'Crédito a Favor');
    if (creditPaymentFromList) {
        finalPayments.push(creditPaymentFromList as Payment);
    }
    
    // Filter out credit payment for invoice application logic
    const actualMoneyPayments = paymentsToCreate.filter(p => p.paymentMethod !== 'Crédito a Favor');

    let invoicesToProcess = initialSalesDataGlobal.filter(sale => {
      if (sale.customerId !== payingCustomer.id) return false;
      const totalPaidForThisInvoice = initialPaymentsDataGlobal
        .filter(p => p.appliedToInvoiceId === sale.id && p.status === 'verificado')
        .reduce((sum, p) => sum + p.amountAppliedToDebtUSD, 0);
      const remainingBalance = sale.totalAmount - totalPaidForThisInvoice;
      return remainingBalance > 0.01;
    }).sort((a,b) => parseISO(a.date).getTime() - parseISO(b.date).getTime());
    
    // First, apply the credit if any, to oldest invoices
    let creditToDistribute = creditToApply;
    for (const invoice of invoicesToProcess) {
        if (creditToDistribute <= 0.001) break;
        const alreadyPaid = initialPaymentsDataGlobal
            .filter(p => p.appliedToInvoiceId === invoice.id && p.status === 'verificado')
            .reduce((sum, p) => sum + p.amountAppliedToDebtUSD, 0);
        let amountNeededForThisInvoice = (invoice.totalAmount || 0) - alreadyPaid;
        const amountToApplyFromCredit = Math.min(creditToDistribute, amountNeededForThisInvoice);

        if (amountToApplyFromCredit > 0.001 && creditPaymentFromList) {
            finalPayments.push({
                ...creditPaymentFromList,
                 id: `${creditPaymentFromList.id}-inv-${invoice.id?.slice(-4) || 'ADJ'}`,
                amountAppliedToDebtUSD: parseFloat(amountToApplyFromCredit.toFixed(2)),
                appliedToInvoiceId: invoice.id,
                paymentSource: 'invoice',
            } as Payment);
            creditToDistribute -= amountToApplyFromCredit;
            amountNeededForThisInvoice -= amountToApplyFromCredit;
        }
    }


    let paymentIndex = 0;
    let amountToDistribute = remainingAmountToApplyUSD;

    for (const invoice of invoicesToProcess) {
        if (amountToDistribute <= 0.001) break;

        const alreadyPaid = initialPaymentsDataGlobal
            .filter(p => p.appliedToInvoiceId === invoice.id && p.status === 'verificado')
            .reduce((sum, p) => sum + p.amountAppliedToDebtUSD, 0) + (finalPayments.filter(p => p.appliedToInvoiceId === invoice.id).reduce((sum,p) => sum + p.amountAppliedToDebtUSD, 0));
        let amountNeededForThisInvoice = (invoice.totalAmount || 0) - alreadyPaid;
        
        while (amountToDistribute > 0.001 && paymentIndex < actualMoneyPayments.length) {
            const currentPayment = actualMoneyPayments[paymentIndex] as Payment;
            if ((currentPayment.amountAppliedToDebtUSD || 0) <= 0.001) {
              paymentIndex++;
              continue;
            }
            const amountToApplyFromThisPayment = Math.min(amountToDistribute, amountNeededForThisInvoice, currentPayment.amountAppliedToDebtUSD || 0);
            
            if (amountToApplyFromThisPayment > 0.001) {
                const appliedPayment: Payment = {
                    ...currentPayment,
                    id: `${currentPayment.id}-inv-${invoice.id?.slice(-4) || 'ADJ'}`,
                    amountAppliedToDebtUSD: parseFloat(amountToApplyFromThisPayment.toFixed(2)),
                    appliedToInvoiceId: invoice.id,
                    paymentSource: 'invoice',
                };
                finalPayments.push(appliedPayment);

                currentPayment.amountAppliedToDebtUSD! -= amountToApplyFromThisPayment;
                amountToDistribute -= amountToApplyFromThisPayment;
                amountNeededForThisInvoice -= amountToApplyFromThisPayment;
            }
            if ((currentPayment.amountAppliedToDebtUSD || 0) <= 0.001) {
                paymentIndex++;
            }
            if (amountNeededForThisInvoice <= 0.001) break;
        }
    }
    
    // Correctly handle excess money payment after applying credit
    const remainingMoneyPaymentAfterInvoices = actualMoneyPayments.reduce((sum, p) => sum + (p.amountAppliedToDebtUSD || 0), 0);
    
    if (remainingMoneyPaymentAfterInvoices > 0.001) {
        let moneyLeftToMarkAsExcess = remainingMoneyPaymentAfterInvoices;
        paymentIndex = 0; // Reset index to iterate through payments again
        while(moneyLeftToMarkAsExcess > 0.001 && paymentIndex < actualMoneyPayments.length) {
            const currentPayment = actualMoneyPayments[paymentIndex];
            if ((currentPayment.amountAppliedToDebtUSD || 0) > 0.001) {
                const amountForExcess = currentPayment.amountAppliedToDebtUSD || 0;
                 const excessPayment: Payment = {
                    ...currentPayment,
                     id: `${currentPayment.id}-EXCESS`,
                    amountAppliedToDebtUSD: parseFloat(amountForExcess.toFixed(2)),
                    notes: `${currentPayment.notes || ''} (Exceso de pago aplicado como saldo a favor)`.trim(),
                    appliedToInvoiceId: undefined, paymentSource: 'balance_adjustment',
                };
                finalPayments.push(excessPayment);
                moneyLeftToMarkAsExcess -= amountForExcess;
            }
            paymentIndex++;
        }
    }
      
    try {
      const nonCreditPayments = finalPayments.filter(p => p.paymentMethod !== 'Crédito a Favor');
      let currentGlobalPayments = [...initialPaymentsDataGlobal, ...nonCreditPayments];

      // El pago de crédito (si existe) debe ser manejado por updateGlobalSaleDataAndFinances
      const creditPayment = finalPayments.find(p => p.paymentMethod === 'Crédito a Favor');
      if (creditPayment) {
        updateGlobalSaleDataAndFinances(creditPayment, 'add');
      }
      
      const verifiedMoneyPayments = nonCreditPayments.filter(p => p.status === 'verificado');
      verifiedMoneyPayments.forEach(p => {
        updateGlobalSaleDataAndFinances(p, 'add');
      });
      
      savePaymentsData(currentGlobalPayments);

      toast({ 
          title: `Pago de $${totalAmountToApply.toFixed(2)} Registrado`, 
          description: "Pagos verificados aplicados, otros pendientes de verificación."
      });

    } catch (e) {
      const error = e as Error;
      toast({ title: "Error al Procesar Pago", description: error.message, variant: "destructive" });
    }

    setIsRegisterPaymentDialogOpen(false);
    setPayingCustomer(null);
    setIsSubmittingPayment(false);
    loadData();
  };

  const handleOpenInvoiceHistoryDialogAR = (customer: Customer) => {
    setSelectedCustomerForInvoicesAR(customer);
    setInvoiceHistoryDateRangeFilterAR(undefined); 
    const invoices = initialSalesDataGlobal
      .filter(sale => sale.customerId === customer.id)
      .sort((a, b) => (a.date && b.date) ? (parseISO(b.date).getTime() - parseISO(a.date).getTime()) : 0);
    setCustomerInvoicesAR(invoices);
    setIsInvoiceHistoryDialogOpenAR(true);
  };

  useEffect(() => {
    if (selectedCustomerForInvoicesAR) {
      let invoices = initialSalesDataGlobal
        .filter(sale => sale.customerId === selectedCustomerForInvoicesAR.id);

      if (invoiceHistoryDateRangeFilterAR?.from) {
        const toDate = invoiceHistoryDateRangeFilterAR.to ? endOfDay(invoiceHistoryDateRangeFilterAR.to) : endOfDay(invoiceHistoryDateRangeFilterAR.from);
        invoices = invoices.filter(invoice => {
          if (!invoice.date || !isValid(parseISO(invoice.date))) return false;
          return isWithinInterval(parseISO(invoice.date), { start: startOfDay(invoiceHistoryDateRangeFilterAR.from!), end: toDate });
        });
      }
      invoices.sort((a, b) => (a.date && b.date) ? (parseISO(b.date).getTime() - parseISO(a.date).getTime()) : 0);
      setCustomerInvoicesAR(invoices);
    }
  }, [selectedCustomerForInvoicesAR, invoiceHistoryDateRangeFilterAR]);


  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[calc(100vh-10rem)]">
        <Loader2 className="h-12 w-12 animate-spin text-primary" />
        <p className="ml-4 text-lg">Cargando cuentas por cobrar...</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <PageHeader
        title="Cuentas por Cobrar (Global)"
        description="Visualiza saldos pendientes globales y registra pagos. El ingreso se registra en la cuenta de la sede seleccionada y se generan transferencias de fondos pendientes si aplica."
        icon={CreditCard}
      />

      <Card className="shadow-lg">
        <CardHeader>
          <CardTitle>Clientes con Saldo (Global)</CardTitle>
          <CardDescription>
            {customersWithBalance.length > 0
              ? "Lista de clientes con saldos pendientes (deuda) o a favor (crédito)."
              : "¡Excelente! Ningún cliente tiene saldo."}
          </CardDescription>
        </CardHeader>
        <CardContent>
          {customersWithBalance.length > 0 ? (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Nombre del Cliente</TableHead>
                  <TableHead>Contacto</TableHead>
                  <TableHead>Correo Electrónico</TableHead>
                  <TableHead className="text-right">Saldo (USD)</TableHead>
                  <TableHead className="text-right">Saldo (VES)</TableHead>
                  <TableHead className="text-center">Acciones</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {customersWithBalance.map((customer) => {
                  const balance = (customer as any).balance;
                  const isDebt = balance > 0;
                  const balanceValue = Math.abs(balance);
                  const balanceColor = isDebt ? 'text-destructive' : 'text-green-600 dark:text-green-500';
                  const balancePrefix = isDebt ? '$' : 'Saldo a Favor: $';

                  return (
                  <TableRow key={customer.id}>
                    <TableCell className="font-medium">{customer.name}</TableCell>
                    <TableCell>{customer.contact}</TableCell>
                    <TableCell>{customer.email}</TableCell>
                    <TableCell className={cn("text-right font-semibold", balanceColor)}>
                      <FormattedNumber value={balanceValue} prefix={balancePrefix} />
                    </TableCell>
                    <TableCell className={cn("text-right font-semibold", balanceColor)}>
                      {formatVesPrice(balanceValue)}
                    </TableCell>
                    <TableCell className="text-center space-x-2">
                       <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => handleOpenInvoiceHistoryDialogAR(customer)}
                        disabled={isSubmittingPayment}
                        title="Ver Historial de Facturas y Pagos"
                        className="px-2"
                      >
                        <InvoiceHistoryIcon className="mr-1 h-4 w-4" />
                        Historial
                      </Button>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => handleOpenRegisterPaymentDialog(customer)}
                        disabled={isSubmittingPayment}
                        title="Registrar Pago"
                         className="px-2"
                      >
                        <DollarSign className="mr-1 h-4 w-4" />
                        Pago
                      </Button>
                    </TableCell>
                  </TableRow>
                  );
                })}
              </TableBody>
            </Table>
          ) : (
            !isLoading && <p className="text-center text-muted-foreground py-8">No hay clientes con saldos pendientes o a favor.</p>
          )}
        </CardContent>
      </Card>

      <Dialog open={isRegisterPaymentDialogOpen} onOpenChange={(isOpen) => {if(!isSubmittingPayment && !isAnalyzingPayment) setIsRegisterPaymentDialogOpen(isOpen)}}>
        <DialogContent className="sm:max-w-4xl lg:max-w-7xl">
          <DialogHeader>
            <DialogTitle>Registrar Pago de: {payingCustomer?.name}</DialogTitle>
            <DialogDescription>
              Saldo pendiente total del cliente: <span className="font-semibold"><FormattedNumber value={(payingCustomer as any)?.balance || 0} prefix="$" /> ({formatVesPrice((payingCustomer as any)?.balance || 0)})</span>
            </DialogDescription>
          </DialogHeader>
          <ScrollArea className="max-h-[70vh] p-1 pr-3">
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 py-4">

            <div className="space-y-4">
              <div className="p-4 border rounded-lg bg-muted/50 space-y-3">
                <Label className="font-semibold text-base">Autocompletar con IA (Beta)</Label>
                <p className="text-sm text-muted-foreground">Sube una o varias imágenes de la confirmación de pago (ej. Pago Móvil) para rellenar los campos.</p>
                <div className="flex gap-2 items-center">
                    <Input
                        id="payment_image_upload"
                        type="file"
                        accept="image/*"
                        multiple
                        onChange={handlePaymentImageFileChange}
                        disabled={isSubmittingPayment || isAnalyzingPayment}
                        className="flex-grow"
                    />
                    <Button onClick={handleAnalyzeBatchPayments} disabled={isSubmittingPayment || isAnalyzingPayment || paymentImageFiles.length === 0}>
                        {isAnalyzingPayment ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Eye className="mr-2 h-4 w-4" />}
                        {isAnalyzingPayment ? 'Analizando...' : 'Analizar'}
                    </Button>
                </div>
              </div>
              <div className="p-4 border rounded-lg bg-muted/50 space-y-3">
                  <Label className="font-semibold text-base">Añadir Pagos Manuales (Efectivo, etc.)</Label>
                  <div className="space-y-2">
                    {manualPayments.map((p, index) => {
                      const amountNum = parseFloat(p.amount) || 0;
                      const rateNum = parseFloat(p.exchangeRate) || 0;
                      const equivalentUSD = p.currency === 'VES' && amountNum > 0 && rateNum > 0 ? (amountNum / rateNum) : 0;
                      const showRef = p.method === 'Pago Móvil (VES)' || p.method === 'Transferencia (VES)';
                      return (
                      <div key={p.id} className="grid grid-cols-12 gap-2 items-end border-b pb-2 last:border-b-0">
                         <div className="col-span-12 sm:col-span-6 md:col-span-2 space-y-1">
                            {index === 0 && <Label htmlFor={`manual_date_${p.id}`} className="text-xs">Fecha</Label>}
                            <Popover open={openDatePickers[p.id]} onOpenChange={(open) => setOpenDatePickers(prev => ({...prev, [p.id]: open}))}><PopoverTrigger asChild><Button id={`manual_date_${p.id}`} variant="outline" size="sm" className="w-full text-xs h-8 justify-start font-normal"><CalendarIcon className="mr-1 h-3 w-3" />{format(p.date, "dd/MM/yy", {locale: es})}</Button></PopoverTrigger><PopoverContent className="w-auto p-0"><Calendar mode="single" selected={p.date} onSelect={(date) => { if(date) {handleManualPaymentChange(p.id, 'date', date); setOpenDatePickers(prev => ({...prev, [p.id]: false}));} }} initialFocus locale={es} /></PopoverContent></Popover>
                         </div>
                         <div className="col-span-6 sm:col-span-3 md:col-span-2 space-y-1">
                            {index === 0 && <Label htmlFor={`manual_amount_${p.id}`} className="text-xs">Monto</Label>}
                            <Input id={`manual_amount_${p.id}`} type="number" value={p.amount} onChange={(e) => handleManualPaymentChange(p.id, 'amount', e.target.value)} className="h-8 text-xs" />
                         </div>
                         <div className="col-span-6 sm:col-span-3 md:col-span-1 space-y-1">
                            {index === 0 && <Label htmlFor={`manual_currency_${p.id}`} className="text-xs">Moneda</Label>}
                            <Select value={p.currency} onValueChange={(val) => handleManualPaymentChange(p.id, 'currency', val)}><SelectTrigger id={`manual_currency_${p.id}`} className="h-8 text-xs"><SelectValue /></SelectTrigger><SelectContent><SelectItem value="USD">USD</SelectItem><SelectItem value="VES">VES</SelectItem></SelectContent></Select>
                         </div>
                         <div className="col-span-12 sm:col-span-6 md:col-span-3 space-y-1">
                            {index === 0 && <Label htmlFor={`manual_method_${p.id}`} className="text-xs">Método</Label>}
                            <Select value={p.method} onValueChange={(val) => handleManualPaymentChange(p.id, 'method', val)}><SelectTrigger id={`manual_method_${p.id}`} className="h-8 text-xs"><SelectValue /></SelectTrigger><SelectContent>{paymentMethodList.map(m=><SelectItem key={m} value={m}>{m}</SelectItem>)}</SelectContent></Select>
                         </div>
                         <div className="col-span-6 sm:col-span-3 md:col-span-2 space-y-1">
                            {index === 0 && <Label htmlFor={`manual_rate_${p.id}`} className="text-xs">Tasa</Label>}
                            <Input id={`manual_rate_${p.id}`} type="number" value={p.exchangeRate} onChange={(e) => handleManualPaymentChange(p.id, 'exchangeRate', e.target.value)} disabled={p.currency !== 'VES'} className="h-8 text-xs"/>
                         </div>
                         <div className="col-span-6 sm:col-span-3 md:col-span-2 space-y-1">
                            {index === 0 && <Label htmlFor={`manual_equiv_usd_${p.id}`} className="text-xs">Equiv. (USD)</Label>}
                            <div id={`manual_equiv_usd_${p.id}`} className="h-8 flex items-center justify-end pr-2 rounded-md bg-muted/50 text-xs font-medium">
                                <FormattedNumber value={equivalentUSD} prefix="$" />
                            </div>
                         </div>
                         <div className={cn("col-span-6 md:col-span-2 space-y-1", !showRef && "hidden")}>
                            {index === 0 && <Label htmlFor={`manual_ref_${p.id}`} className="text-xs">Ref. (6 dig)*</Label>}
                            <Input id={`manual_ref_${p.id}`} type="text" value={p.referenceNumber || ''} onChange={(e) => handleManualPaymentChange(p.id, 'referenceNumber', e.target.value)} className="h-8 text-xs" maxLength={6} />
                         </div>
                         <div className="col-span-12 sm:col-span-1 flex justify-end items-end">
                            <Button variant="ghost" size="icon" className="h-8 w-8 text-destructive" onClick={() => handleRemoveManualPayment(p.id)}><XCircle className="h-4 w-4" /></Button>
                         </div>
                      </div>
                    )})}
                  </div>
                  <Button variant="outline" size="sm" onClick={handleAddManualPayment}><PlusCircle className="mr-2 h-4 w-4"/> Añadir Pago Manual</Button>
              </div>

            </div>

             <div className="space-y-4">
                 <div className="space-y-1">
                    <Label htmlFor="apply_to_invoice_edit">Aplicar Pago a</Label>
                    <Select value={selectedInvoiceId} onValueChange={setSelectedInvoiceId} disabled={isSubmittingPayment}>
                        <SelectTrigger id="apply_to_invoice_edit">
                            <SelectValue placeholder="Selecciona una factura o abono..." />
                        </SelectTrigger>
                        <SelectContent>
                            <SelectItem value="DEBT_ADJUSTMENT_PAYMENT">Abono directo a la deuda (sin factura)</SelectItem>
                            {pendingInvoicesForCustomer.map(invoice => {
                                const daysDiff = invoice.dueDate ? differenceInDays(new Date(), parseISO(invoice.dueDate)) : 0;
                                let dueDateInfo = "";
                                if (daysDiff > 0) dueDateInfo = ` (Vencida hace ${daysDiff} días)`;
                                else if (daysDiff === 0) dueDateInfo = " (Vence Hoy)";
                                const invoiceGlobalBalance = invoice.totalAmount - (invoice.amountPaidUSD || 0);
                                return (
                                    <SelectItem key={invoice.id} value={invoice.id}>
                                        Factura ID: {invoice.id} ({format(parseISO(invoice.date), "dd/MM/yy")}) - Saldo: ${invoiceGlobalBalance.toFixed(2)}{dueDateInfo}
                                    </SelectItem>
                                );
                            })}
                        </SelectContent>
                    </Select>
                 </div>
                 {batchPayments.length > 0 && (
                  <div className="space-y-2 mt-4">
                      <Label className="font-semibold">Pagos Analizados</Label>
                      <ScrollArea className="h-40 w-full rounded-md border p-2">
                          <div className="space-y-2">
                              {batchPayments.map((payment, index) => (
                                  <div key={index} className="flex items-start justify-between p-2 rounded-md bg-muted/50 gap-2">
                                      <div className="flex-grow space-y-1">
                                          <p className="text-xs font-medium truncate max-w-[200px]">{payment.fileName}</p>
                                          {payment.amount !== undefined ? (
                                              <>
                                                  <div className="grid grid-cols-2 gap-x-2 gap-y-1 items-center">
                                                      <div className="space-y-0.5">
                                                          <Label htmlFor={`batch_amount_${index}`} className="text-xs">Monto (VES)</Label>
                                                          <Input
                                                              id={`batch_amount_${index}`}
                                                              type="number"
                                                              value={payment.amount || ''}
                                                              onChange={(e) => handleBatchPaymentAmountChange(index, parseFloat(e.target.value) || 0)}
                                                              className="h-7 text-xs"
                                                          />
                                                      </div>
                                                      <div className="space-y-0.5">
                                                        <Label className="text-xs">Fecha</Label>
                                                        <Popover open={openAnalyzedDatePickers[index]} onOpenChange={(open) => setOpenAnalyzedDatePickers(prev => ({...prev, [index]: open}))}>
                                                          <PopoverTrigger asChild>
                                                            <Button variant="outline" size="sm" className="h-7 px-1.5 py-0.5 text-xs w-full justify-start">
                                                              <CalendarIcon className="mr-1 h-3 w-3"/>
                                                              {payment.date ? format(parse(payment.date, 'yyyy-MM-dd', new Date()), "dd/MM/yyyy") : 'N/A'}
                                                            </Button>
                                                          </PopoverTrigger>
                                                          <PopoverContent className="w-auto p-0">
                                                            <Calendar mode="single" selected={payment.date ? parse(payment.date, 'yyyy-MM-dd', new Date()) : undefined} onSelect={(date) => { handleBatchPaymentDateChange(index, date); setOpenAnalyzedDatePickers(prev => ({...prev, [index]: false})); }} initialFocus locale={es}/>
                                                          </PopoverContent>
                                                        </Popover>
                                                      </div>
                                                  </div>
                                                  <p className="text-xs">Ref: {payment.referenceNumber}</p>
                                                  {payment.amountUSD !== undefined && payment.exchangeRate !== undefined && (
                                                    <p className="text-xs text-muted-foreground">
                                                      Equiv: <FormattedNumber value={payment.amountUSD} prefix="$" /> (Tasa: {payment.exchangeRate.toFixed(2)})
                                                    </p>
                                                  )}
                                              </>
                                          ) : (
                                              <p className="text-xs text-destructive">{payment.analysisNotes}</p>
                                          )}
                                      </div>
                                      <Button variant="ghost" size="icon" className="h-7 w-7 text-destructive flex-shrink-0" onClick={() => handleRemoveBatchItem(index)}>
                                          <XCircle className="h-4 w-4" />
                                      </Button>
                                  </div>
                              ))}
                          </div>
                      </ScrollArea>
                  </div>
              )}
                
              {customerBalance < -0.01 && (
                  <Alert variant="default" className="bg-green-50 dark:bg-green-900/20 border-green-200 dark:border-green-700">
                    <ShieldCheck className="h-4 w-4 text-green-600 dark:text-green-400" />
                    <AlertTitle className="text-green-800 dark:text-green-300">Saldo a Favor Disponible</AlertTitle>
                    <AlertDescription className="text-green-700 dark:text-green-400">
                      <p>Este cliente tiene un saldo a favor de <FormattedNumber value={Math.abs(customerBalance)} prefix="$" />.</p>
                      <div className="flex items-center space-x-2 mt-2">
                        <Checkbox id="apply_credit_ar" checked={applyCustomerCredit} onCheckedChange={(checked) => setApplyCustomerCredit(!!checked)} />
                        <label htmlFor="apply_credit_ar" className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70">
                          ¿Desea aplicar este saldo a favor a este pago?
                        </label>
                      </div>
                    </AlertDescription>
                  </Alert>
              )}

              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="space-y-1">
                  <Label htmlFor="paid_to_branch_id_dialog_ar">Sede de Ingreso del Pago*</Label>
                  <Select value={paidToBranchIdDialog} onValueChange={setPaidToBranchIdDialog} disabled={isSubmittingPayment || isAnalyzingPayment}>
                    <SelectTrigger id="paid_to_branch_id_dialog_ar"><SelectValue placeholder="Selecciona sede" /></SelectTrigger>
                    <SelectContent>{availableBranches.map(b => <SelectItem key={b.id} value={b.id}>{b.name}</SelectItem>)}</SelectContent>
                  </Select>
                </div>
                 <div className="space-y-1">
                    <Label htmlFor="payment_notes_ar">Notas Generales (Opcional)</Label>
                    <Textarea id="payment_notes_ar" value={paymentNotes} onChange={(e) => setPaymentNotes(e.target.value)} placeholder="ej., Abono a factura X, pago parcial..." disabled={isSubmittingPayment || isAnalyzingPayment}/>
                </div>
              </div>
              {paymentAmountUSD > 0 && (
                  <div className="mt-2 p-2 border rounded-md bg-muted/50 text-sm">
                      <p>Monto Total (Pagos + Crédito): <span className="font-semibold"><FormattedNumber value={paymentAmountUSD + (applyCustomerCredit ? Math.abs(customerBalance) : 0)} prefix="$" /></span></p>
                  </div>
              )}

             </div>

             </div>
          </ScrollArea>
          <DialogFooter>
            <DialogClose asChild>
              <Button variant="outline" onClick={() => {if(!isSubmittingPayment){setIsRegisterPaymentDialogOpen(false); setPayingCustomer(null);}}} disabled={isSubmittingPayment || isAnalyzingPayment}>Cancelar</Button>
            </DialogClose>
            <Button type="button" onClick={handleSavePayment} disabled={isSubmittingPayment || isAnalyzingPayment || !paidToBranchIdDialog || (paymentAmountUSD <= 0 && !applyCustomerCredit)}>
              {isSubmittingPayment ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <DollarSign className="mr-2 h-4 w-4" />}
              {isSubmittingPayment ? "Registrando..." : "Registrar Pagos"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      <Dialog open={isInvoiceHistoryDialogOpenAR} onOpenChange={setIsInvoiceHistoryDialogOpenAR}>
          <DialogContent className="sm:max-w-3xl">
              <DialogHeader>
                  <DialogTitle>Historial de Facturas y Pagos: {selectedCustomerForInvoicesAR?.name}</DialogTitle>
                  <DialogDescription>Consulta todas las facturas globales del cliente y los pagos aplicados a cada una.</DialogDescription>
              </DialogHeader>
              <div className="flex flex-col sm:flex-row items-center gap-2 py-2 border-b mb-2">
                  <Popover>
                      <PopoverTrigger asChild>
                          <Button id="date-filter-invoice-history-ar" variant={"outline"} className={cn("w-full sm:w-auto min-w-[200px] justify-start text-left font-normal", !invoiceHistoryDateRangeFilterAR && "text-muted-foreground")} disabled={isSubmittingPayment}>
                              <CalendarIcon className="mr-2 h-4 w-4" />
                              {invoiceHistoryDateRangeFilterAR?.from ? (invoiceHistoryDateRangeFilterAR.to ? (<>{format(invoiceHistoryDateRangeFilterAR.from, "LLL dd, y", { locale: es })} - {format(invoiceHistoryDateRangeFilterAR.to, "LLL dd, y", { locale: es })}</>) : (format(invoiceHistoryDateRangeFilterAR.from, "LLL dd, y", { locale: es }))) : (<span>Filtrar por Fecha de Factura</span>)}
                          </Button>
                      </PopoverTrigger>
                      <PopoverContent className="w-auto p-0" align="start">
                          <Calendar initialFocus mode="range" defaultMonth={invoiceHistoryDateRangeFilterAR?.from} selected={invoiceHistoryDateRangeFilterAR} onSelect={setInvoiceHistoryDateRangeFilterAR} numberOfMonths={2} locale={es} disabled={isSubmittingPayment} />
                      </PopoverContent>
                  </Popover>
                  <Button onClick={() => setInvoiceHistoryDateRangeFilterAR(undefined)} variant="outline" className="w-full sm:w-auto" disabled={isSubmittingPayment || !invoiceHistoryDateRangeFilterAR?.from}>Limpiar Filtro Fecha</Button>
              </div>
              <ScrollArea className="max-h-[60vh] p-1 pr-4">
                  {customerInvoicesAR.length > 0 ? (
                      <Accordion type="multiple" className="w-full space-y-2 py-4">
                          {customerInvoicesAR.map((invoice) => {
                              const status = getInvoiceStatus(invoice, initialPaymentsDataGlobal);
                              const totalPagadoGlobal = initialPaymentsDataGlobal.filter(p => p.appliedToInvoiceId === invoice.id && p.status === 'verificado').reduce((sum,p) => sum + p.amountAppliedToDebtUSD, 0);
                              const saldoPendienteGlobal = invoice.totalAmount - totalPagadoGlobal;
                              const paymentsForThisInvoice = initialPaymentsDataGlobal.filter(p => p.appliedToInvoiceId === invoice.id);
                              return (
                                  <AccordionItem value={invoice.id} key={invoice.id} className="border rounded-md shadow-sm">
                                      <AccordionTrigger className="px-4 py-3 hover:bg-muted/50 rounded-t-md text-left">
                                          <div className="flex flex-col sm:flex-row justify-between w-full items-start sm:items-center gap-2">
                                              <div className="flex-1">
                                                  <p className="font-semibold text-sm">Factura ID: <span className="font-mono">{invoice.id}</span></p>
                                                  <p className="text-xs text-muted-foreground">Fecha: {invoice.date ? format(parseISO(invoice.date), "dd/MM/yyyy") : 'N/A'}</p>
                                              </div>
                                              <div className="flex-1 text-right sm:text-left">
                                                  <p className="text-xs">Total Global: <FormattedNumber value={invoice.totalAmount} prefix="$" /></p>
                                                  <p className="text-xs">Pagado Global (Verif.): <span className="text-green-600"><FormattedNumber value={totalPagadoGlobal} prefix="$" /></span></p>
                                                  <p className="text-xs">Saldo Global: <span className={(saldoPendienteGlobal > 0.001 ? "text-destructive" : "")}><FormattedNumber value={(saldoPendienteGlobal)} prefix="$" /></span></p>
                                              </div>
                                              <div className="flex-1 text-right">
                                                  <Badge variant={status === 'Completada' ? 'default' : status === 'Vencida' ? 'destructive' : 'secondary'} className={cn("whitespace-nowrap text-xs", status === 'Completada' ? 'bg-green-500/20 text-green-700 dark:text-green-400 border-green-500/50' : status === 'Vencida' ? 'bg-red-500/20 text-red-700 dark:text-red-400 border-red-500/50' : status === 'Pagada Parcialmente' ? 'bg-orange-500/20 text-orange-700 dark:text-orange-400 border-orange-500/50' : 'bg-yellow-500/20 text-yellow-700 dark:text-yellow-400 border-yellow-500/50')}>
                                                      {status}
                                                  </Badge>
                                                  {invoice.paymentMethod === 'Crédito' && invoice.dueDate && <p className="text-xs text-muted-foreground mt-1">Vence: {format(parseISO(invoice.dueDate), "dd/MM/yyyy")}</p>}
                                              </div>
                                          </div>
                                      </AccordionTrigger>
                                      <AccordionContent className="px-4 py-3 border-t">
                                          {invoice.itemsPerBranch && invoice.itemsPerBranch.length > 0 && (<div className="mb-3"><h4 className="font-medium text-xs mb-1.5">Desglose por Sede:</h4>{invoice.itemsPerBranch.map(branchData => (<div key={branchData.branchId} className="mb-1.5 p-2 border rounded-md text-xs bg-muted/30"><p className="font-semibold">{branchData.branchName}:</p><p>Monto Sede: <FormattedNumber value={branchData.totalAmount} prefix="$" /></p><p>Pagado Sede (Verif.): <span className="text-green-600"><FormattedNumber value={branchData.amountPaidUSD} prefix="$" /></span></p><p>Saldo Sede: <span className={(branchData.totalAmount - branchData.amountPaidUSD) > 0.001 ? "text-destructive" : ""}><FormattedNumber value={(branchData.totalAmount - branchData.amountPaidUSD)} prefix="$" /></span></p><ul className="list-disc list-inside pl-3 mt-1">{branchData.items.map((item, idx) => <li key={idx} className="text-muted-foreground">{item.productName} (x{item.quantity})</li>)}</ul></div>))}</div>)}
                                          {paymentsForThisInvoice.length > 0 ? (<><h4 className="font-medium text-sm mb-2">Pagos Registrados para esta Factura:</h4><Table className="text-xs"><TableHeader><TableRow><TableHead>ID Pago</TableHead><TableHead>Fecha</TableHead><TableHead>Monto Aplicado (USD)</TableHead><TableHead>Monto Pagado (Moneda Orig.)</TableHead><TableHead>Método</TableHead><TableHead>Referencia</TableHead><TableHead>Estado Pago</TableHead></TableRow></TableHeader><TableBody>{paymentsForThisInvoice.map(payment => (<TableRow key={payment.id}><TableCell>{payment.id}</TableCell><TableCell>{payment.paymentDate ? format(parseISO(payment.paymentDate), "dd/MM/yy") : 'N/A'}</TableCell><TableCell><FormattedNumber value={payment.amountAppliedToDebtUSD} prefix="$" /></TableCell><TableCell>{payment.currencyPaidInput === 'VES' ? <FormattedNumber value={payment.amountPaidInput} prefix="Bs. " /> : (payment.currencyPaidInput === 'USD' ? <FormattedNumber value={payment.amountPaidInput} prefix="$" /> : 'N/A')}</TableCell><TableCell>{payment.paymentMethod}</TableCell><TableCell>{payment.referenceNumber || '-'}</TableCell><TableCell><Badge variant={payment.status === 'verificado' ? 'default' : payment.status === 'rechazado' ? 'destructive' : 'secondary'} className={cn("text-xs", payment.status === 'verificado' ? 'bg-green-500/20 text-green-700 dark:text-green-400 border-green-500/50' : payment.status === 'rechazado' ? 'bg-red-500/20 text-red-700 dark:text-red-400 border-red-500/50' : 'bg-yellow-500/20 text-yellow-700 dark:text-yellow-400 border-yellow-500/50')}>{payment.status}</Badge></TableCell></TableRow>))}</TableBody></Table></>) : (<p className="text-sm text-muted-foreground text-center py-2">No hay pagos registrados para esta factura.</p>)}
                                      </AccordionContent>
                                  </AccordionItem>
                              );
                          })}
                      </Accordion>
                  ) : (<p className="text-center text-muted-foreground py-8">{invoiceHistoryDateRangeFilterAR?.from ? "Este cliente no tiene facturas en el rango de fechas seleccionado." : "Este cliente no tiene facturas registradas."}</p>)}
              </ScrollArea>
              <DialogFooter>
                  <DialogClose asChild><Button variant="outline" onClick={() => { setIsInvoiceHistoryDialogOpenAR(false); setSelectedCustomerForInvoicesAR(null); setCustomerInvoicesAR([]); setInvoiceHistoryDateRangeFilterAR(undefined); }}>Cerrar</Button></DialogClose>
              </DialogFooter>
          </DialogContent>
      </Dialog>
    </div>
  );
}


// --- customers ---



"use client";

import { useState, useEffect, useMemo, useCallback } from 'react';
import { PageHeader } from '@/components/page-header';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from '@/components/ui/card';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogClose } from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Users, PlusCircle, MoreHorizontal, Edit, Trash2, BarChartHorizontal, AlertTriangle, FileText as InvoiceHistoryIcon, Eye, Calendar as CalendarIcon, ArrowDown, ArrowUp, Download } from 'lucide-react';
import { useToast } from "@/hooks/use-toast";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';
import { 
  customersData as initialCustomersDataGlobal, 
  saveCustomersData, 
  type Customer,
  salesData as initialSalesDataGlobal, 
  type Sale,
  type SaleItem,
  paymentsData as initialPaymentsDataGlobal, 
  type Payment,
  getInvoiceStatus,
  type SaleStatus,
  loadExchangeRate,
  KEYS,
  calculateCustomerBalance,
  calculateInvoiceBalance,
} from '@/lib/data-storage';
import { format, parseISO, isValid, isWithinInterval, startOfDay, endOfDay, startOfWeek, endOfWeek, getWeek } from 'date-fns';
import type { DateRange } from "react-day-picker";
import { es } from 'date-fns/locale';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { 
  BarChart, 
  CartesianGrid, 
  XAxis, 
  YAxis, 
  Tooltip as RechartsTooltip, 
  Legend as RechartsLegend, 
  ResponsiveContainer, 
  Bar 
} from 'recharts';
import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { Popover, PopoverTrigger, PopoverContent } from '@/components/ui/popover';
import { Calendar } from "@/components/ui/calendar";
import { cn } from '@/lib/utils';
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion";
import { Badge } from '@/components/ui/badge';
import { Tooltip, TooltipProvider, TooltipTrigger, TooltipContent } from "@/components/ui/tooltip";
import { FormattedNumber } from '@/components/ui/formatted-number';
import { Separator } from '@/components/ui/separator';
import jsPDF from 'jspdf';
import 'jspdf-autotable';


interface jsPDFWithAutoTable extends jsPDF {
  autoTable: (options: any) => jsPDFWithAutoTable;
}

interface ProductStat {
  name: string;
  quantity: number;
}

interface CombinedProductStat {
  name: string;
  sold: number;
  changedNormal: number;
  changedNonDispatchable: number;
  totalChanged: number;
  changeRate: number;
}

interface WeeklySummary {
  weekKey: string;
  startDate: Date;
  endDate: Date;
  purchases: Sale[]; // Guardar ventas completas
  creditNotes: Sale[]; // Guardar NCs
  returns: { saleId: string; saleDate: string; items: SaleItem[] }[]; // Guardar devoluciones
  totalPurchased: number;
  totalReturned: number;
  netTotal: number;
}


const salesChartConfig = {
  quantity: {
    label: "Cantidad Vendida",
    color: "hsl(var(--chart-1))",
  },
} satisfies ChartConfig;

const changesChartConfig = {
  quantity: {
    label: "Cantidad Cambiada/Devuelta",
    color: "hsl(var(--chart-2))",
  },
} satisfies ChartConfig;

const HIGH_CHANGE_RATE_THRESHOLD = 20; // Percentage

export default function CustomersPage() {
  const { toast } = useToast();
  const [currentCustomers, setCurrentCustomers] = useState<Customer[]>([]);
  const [exchangeRate, setExchangeRate] = useState<number>(0);

  const [isAddCustomerDialogOpen, setIsAddCustomerDialogOpen] = useState(false);
  const [newCustomerName, setNewCustomerName] = useState('');
  const [newCustomerContact, setNewCustomerContact] = useState('');
  const [newCustomerEmail, setNewCustomerEmail] = useState('');
  const [newCustomerAddress, setNewCustomerAddress] = useState('');
  const [newCustomerWorkZone, setNewCustomerWorkZone] = useState('');


  const [isEditCustomerDialogOpen, setIsEditCustomerDialogOpen] = useState(false);
  const [editingCustomer, setEditingCustomer] = useState<Customer | null>(null);
  const [editCustomerName, setEditCustomerName] = useState('');
  const [editCustomerContact, setEditCustomerContact] = useState('');
  const [editCustomerEmail, setEditCustomerEmail] = useState('');
  const [editCustomerAddress, setEditCustomerAddress] = useState('');
  const [editCustomerWorkZone, setEditCustomerWorkZone] = useState('');


  const [isDeleteConfirmDialogOpen, setIsDeleteConfirmDialogOpen] = useState(false);
  const [customerToDeleteId, setCustomerToDeleteId] = useState<string | null>(null);

  const [isStatsDialogOpen, setIsStatsDialogOpen] = useState(false);
  const [selectedCustomerForStats, setSelectedCustomerForStats] = useState<Customer | null>(null);
  const [productSalesStats, setProductSalesStats] = useState<ProductStat[]>([]);
  const [productChangesStats, setProductChangesStats] = useState<ProductStat[]>([]);
  const [combinedProductStats, setCombinedProductStats] = useState<CombinedProductStat[]>([]);
  const [productsWithHighChangeRate, setProductsWithHighChangeRate] = useState<string[]>([]);
  const [statsDateRangeFilter, setStatsDateRangeFilter] = useState<DateRange | undefined>(undefined);


  const [isInvoiceHistoryDialogOpen, setIsInvoiceHistoryDialogOpen] = useState(false);
  const [selectedCustomerForInvoices, setSelectedCustomerForInvoices] = useState<Customer | null>(null);
  const [customerInvoices, setCustomerInvoices] = useState<Sale[]>([]);
  const [invoiceHistoryDateRangeFilter, setInvoiceHistoryDateRangeFilter] = useState<DateRange | undefined>(undefined);
  
  const [weeklySummaries, setWeeklySummaries] = useState<WeeklySummary[]>([]);


  const loadPageData = useCallback(() => {
    const allCustomers = [...initialCustomersDataGlobal];
    const calculatedCustomers = allCustomers.map(c => ({
      ...c,
      balance: calculateCustomerBalance(c.id)
    }));
    setCurrentCustomers(calculatedCustomers);
    setExchangeRate(loadExchangeRate());
  }, []);

  useEffect(() => {
    loadPageData();

    const handleDataUpdate = (event: Event) => {
      const customEvent = event as CustomEvent;
      if (customEvent.detail?.key === KEYS.CUSTOMERS || 
          customEvent.detail?.key === KEYS.SALES || 
          customEvent.detail?.key === KEYS.PAYMENTS ||
          customEvent.detail?.key === KEYS.EXCHANGE_RATE) {
        loadPageData();
      }
    };
    window.addEventListener('data-updated', handleDataUpdate);
    return () => {
      window.removeEventListener('data-updated', handleDataUpdate);
    };
  }, [loadPageData]);

  const resetAddForm = () => {
    setNewCustomerName('');
    setNewCustomerContact('');
    setNewCustomerEmail('');
    setNewCustomerAddress('');
    setNewCustomerWorkZone('');
  };

  const handleAddCustomer = () => {
    if (!newCustomerName || !newCustomerContact) {
      toast({ title: "Error", description: "Nombre y contacto son obligatorios.", variant: "destructive" });
      return;
    }
    const newCustomer: Customer = {
      id: `CUST${Date.now().toString().slice(-4)}${Math.floor(Math.random()*100)}`,
      name: newCustomerName,
      contact: newCustomerContact,
      email: newCustomerEmail,
      address: newCustomerAddress,
      workZone: newCustomerWorkZone,
      lastOrder: undefined, 
    };
    const updatedCustomers = [newCustomer, ...initialCustomersDataGlobal]; 
    saveCustomersData(updatedCustomers); 
    toast({ title: "Éxito", description: "Cliente añadido correctamente." });
    setIsAddCustomerDialogOpen(false);
    resetAddForm();
  };

  const handleOpenEditDialog = (customer: Customer) => {
    setEditingCustomer(customer);
    setEditCustomerName(customer.name);
    setEditCustomerContact(customer.contact);
    setEditCustomerEmail(customer.email || '');
    setEditCustomerAddress(customer.address || '');
    setEditCustomerWorkZone(customer.workZone || '');
    setIsEditCustomerDialogOpen(true);
  };

  const handleUpdateCustomer = () => {
    if (!editingCustomer || !editCustomerName || !editCustomerContact) {
      toast({ title: "Error", description: "Nombre y contacto son obligatorios.", variant: "destructive" });
      return;
    }
    const updatedCustomers = initialCustomersDataGlobal.map(c => 
      c.id === editingCustomer.id 
      ? {
          ...c,
          name: editCustomerName,
          contact: editCustomerContact,
          email: editCustomerEmail,
          address: editCustomerAddress,
          workZone: editCustomerWorkZone,
        }
      : c
    );
    saveCustomersData(updatedCustomers); 
    toast({ title: "Éxito", description: "Cliente actualizado correctamente." });
    setIsEditCustomerDialogOpen(false);
    setEditingCustomer(null);
  };

  const handleOpenDeleteDialog = (customerId: string) => {
    setCustomerToDeleteId(customerId);
    setIsDeleteConfirmDialogOpen(true);
  };

  const handleConfirmDelete = () => {
    if (customerToDeleteId) {
      const updatedCustomers = initialCustomersDataGlobal.filter(c => c.id !== customerToDeleteId); 
      saveCustomersData(updatedCustomers); 
      toast({ title: "Éxito", description: "Cliente eliminado correctamente." });
      setIsDeleteConfirmDialogOpen(false);
      setCustomerToDeleteId(null);
    }
  };

  const calculateCustomerStats = useCallback((customer: Customer | null, dateRange: DateRange | undefined) => {
    if (!customer) {
      setProductSalesStats([]);
      setProductChangesStats([]);
      setCombinedProductStats([]);
      setProductsWithHighChangeRate([]);
      return;
    }

    let customerSales = initialSalesDataGlobal.filter(sale => sale.customerId === customer.id);

    if (dateRange?.from) {
      const toDate = dateRange.to ? endOfDay(dateRange.to) : endOfDay(dateRange.from);
      customerSales = customerSales.filter(sale => {
        if (!sale.date || !isValid(parseISO(sale.date))) return false;
        return isWithinInterval(parseISO(sale.date), { start: startOfDay(dateRange.from!), end: toDate });
      });
    }

    const canonicalNames = new Map<string, string>();
    const salesAggregated: Record<string, number> = {};
    const changesNormalAggregated: Record<string, number> = {};
    const changesNonDispatchableAggregated: Record<string, number> = {};
    
    customerSales.forEach(sale => {
      if (sale.itemsPerBranch && Array.isArray(sale.itemsPerBranch)) {
        sale.itemsPerBranch.forEach(branchDetail => {
          if (branchDetail.items && Array.isArray(branchDetail.items)) {
            branchDetail.items.forEach(item => {
              if (item.productName && !item.productName.toLowerCase().startsWith('no despachable')) {
                const normalizedName = item.productName.toLowerCase().trim();
                if (!canonicalNames.has(normalizedName)) {
                  canonicalNames.set(normalizedName, item.productName.trim());
                }
                salesAggregated[normalizedName] = (salesAggregated[normalizedName] || 0) + item.quantity;
              }
            });
          }
        });
      }
    });
    
    customerSales.forEach(sale => {
      if (sale.changes) {
        sale.changes.forEach(item => {
          if (item.productName) {
            const trimmedProductName = item.productName.trim();
            const match = trimmedProductName.match(/^no\s*despachable\s+(.*)/i);

            if (match && match[1]) {
              const baseProductName = match[1].trim();
              const normalizedBaseName = baseProductName.toLowerCase().trim();

              if (!canonicalNames.has(normalizedBaseName)) {
                 canonicalNames.set(normalizedBaseName, baseProductName);
              }
              changesNonDispatchableAggregated[normalizedBaseName] = (changesNonDispatchableAggregated[normalizedBaseName] || 0) + item.quantity;
            } else {
              const normalizedName = trimmedProductName.toLowerCase().trim();
              if (!canonicalNames.has(normalizedName)) {
                canonicalNames.set(normalizedName, trimmedProductName);
              }
              changesNormalAggregated[normalizedName] = (changesNormalAggregated[normalizedName] || 0) + item.quantity;
            }
          }
        });
      }
    });

    const allProductKeys = new Set([
      ...Object.keys(salesAggregated),
      ...Object.keys(changesNormalAggregated),
      ...Object.keys(changesNonDispatchableAggregated)
    ]);

    const combinedStatsList: CombinedProductStat[] = [];
    allProductKeys.forEach(normalizedName => {
      const sold = salesAggregated[normalizedName] || 0;
      const changedNormal = changesNormalAggregated[normalizedName] || 0;
      const changedNonDispatchable = changesNonDispatchableAggregated[normalizedName] || 0;
      
      if (sold > 0 || changedNormal > 0 || changedNonDispatchable > 0) {
        const totalChanged = changedNormal + changedNonDispatchable;
        const changeRate = sold > 0 ? (totalChanged / sold) * 100 : (totalChanged > 0 ? Infinity : 0);
        combinedStatsList.push({
          name: canonicalNames.get(normalizedName) || normalizedName,
          sold,
          changedNormal,
          changedNonDispatchable,
          totalChanged,
          changeRate: parseFloat(changeRate.toFixed(2))
        });
      }
    });

    combinedStatsList.sort((a, b) => b.sold - a.sold);

    const salesStats: ProductStat[] = combinedStatsList
      .filter(s => s.sold > 0)
      .map(s => ({ name: s.name, quantity: s.sold }))
      .sort((a,b) => b.quantity - a.quantity);
      
    const changesStats: ProductStat[] = combinedStatsList
      .filter(s => s.totalChanged > 0)
      .map(s => ({ name: s.name, quantity: s.totalChanged }))
      .sort((a,b) => b.quantity - a.quantity);

    setProductSalesStats(salesStats);
    setProductChangesStats(changesStats);
    setCombinedProductStats(combinedStatsList);
    setProductsWithHighChangeRate(
      combinedStatsList
        .filter(stat => stat.changeRate > HIGH_CHANGE_RATE_THRESHOLD)
        .map(stat => stat.name)
    );
  }, []);

  const handleOpenStatsDialog = (customer: Customer) => {
    setSelectedCustomerForStats(customer);
    setStatsDateRangeFilter(undefined); 
    calculateCustomerStats(customer, undefined); 
    setIsStatsDialogOpen(true);
  };
  
  useEffect(() => {
    if (isStatsDialogOpen && selectedCustomerForStats) {
      calculateCustomerStats(selectedCustomerForStats, statsDateRangeFilter);
    }
  }, [selectedCustomerForStats, statsDateRangeFilter, isStatsDialogOpen, calculateCustomerStats]);


  const handleOpenInvoiceHistoryDialog = (customer: Customer) => {
    setSelectedCustomerForInvoices(customer);
    setInvoiceHistoryDateRangeFilter(undefined); 
    const invoices = initialSalesDataGlobal
      .filter(sale => sale.customerId === customer.id)
      .sort((a, b) => parseISO(b.date).getTime() - parseISO(a.date).getTime());
    setCustomerInvoices(invoices);
    setIsInvoiceHistoryDialogOpen(true);
  };

  useEffect(() => {
    if (selectedCustomerForInvoices) {
      let invoices = initialSalesDataGlobal.filter(sale => sale.customerId === selectedCustomerForInvoices.id);
  
      if (invoiceHistoryDateRangeFilter?.from) {
        const toDate = invoiceHistoryDateRangeFilter.to ? endOfDay(invoiceHistoryDateRangeFilter.to) : endOfDay(invoiceHistoryDateRangeFilter.from);
        invoices = invoices.filter(invoice => {
          if (!invoice.date || !isValid(parseISO(invoice.date))) return false;
          return isWithinInterval(parseISO(invoice.date), { start: startOfDay(invoiceHistoryDateRangeFilter.from!), end: toDate });
        });
      }
      invoices.sort((a, b) => parseISO(b.date).getTime() - parseISO(a.date).getTime());
      setCustomerInvoices(invoices);
  
      const weeklySummariesMap = new Map<string, WeeklySummary>();
      
      invoices.forEach(sale => {
        if (!sale.date || !isValid(parseISO(sale.date))) return;
        const saleDate = parseISO(sale.date);
        const weekKey = `${getWeek(saleDate, { weekStartsOn: 1, locale: es })}-${saleDate.getFullYear()}`;
  
        if (!weeklySummariesMap.has(weekKey)) {
          weeklySummariesMap.set(weekKey, {
            weekKey,
            startDate: startOfWeek(saleDate, { weekStartsOn: 1, locale: es }),
            endDate: endOfWeek(saleDate, { weekStartsOn: 1, locale: es }),
            purchases: [],
            creditNotes: [],
            returns: [],
            totalPurchased: 0,
            totalReturned: 0,
            netTotal: 0,
          });
        }
        
        const summary = weeklySummariesMap.get(weekKey)!;
        
        if (sale.totalAmount >= 0) { 
            summary.purchases.push(sale);
            const itemsSubtotal = sale.itemsPerBranch.reduce((branchSum, branchDetail) =>
                branchSum + branchDetail.items.reduce((itemSum, item) => itemSum + item.subtotal, 0),
            0);
            summary.totalPurchased += itemsSubtotal;

            if (sale.changes && sale.changes.length > 0) {
                summary.returns.push({
                    saleId: sale.id,
                    saleDate: sale.date,
                    items: sale.changes,
                });
                const changesSubtotal = sale.changes.reduce((sum, item) => sum + item.subtotal, 0);
                summary.totalReturned += changesSubtotal;
            }
        } else { // It's a credit note
            summary.creditNotes.push(sale);
            summary.totalReturned += Math.abs(sale.totalAmount);
        }
      });
      
      for (const summary of weeklySummariesMap.values()) {
        summary.netTotal = summary.totalPurchased - summary.totalReturned;
      }
      
      setWeeklySummaries(Array.from(weeklySummariesMap.values()).sort((a,b) => b.startDate.getTime() - a.startDate.getTime()));
    }
  }, [selectedCustomerForInvoices, invoiceHistoryDateRangeFilter]);

  const handleGenerateWeeklyStatementPDF = (weekData: WeeklySummary) => {
    if (!selectedCustomerForInvoices) return;
    const doc = new jsPDF() as jsPDFWithAutoTable;

    const formatInvoiceTotalCell = (sale: Sale): string => {
        const appliedCreditNotes = initialPaymentsDataGlobal.filter(p => p.appliedToInvoiceId === sale.id && p.paymentMethod === 'Nota de Crédito');
        const totalCreditApplied = appliedCreditNotes.reduce((sum, cn) => sum + cn.amountAppliedToDebtUSD, 0);

        if (totalCreditApplied === 0) {
            return `$${sale.totalAmount.toFixed(2)}`;
        }

        const netTotal = sale.totalAmount - totalCreditApplied;
        let cellText = `$${sale.totalAmount.toFixed(2)}\n`;
        appliedCreditNotes.forEach(cn => {
            const ncId = cn.notes?.split(': ')[1] || cn.id;
            cellText += `- $${cn.amountAppliedToDebtUSD.toFixed(2)} (NC: ${ncId.slice(0,10)}..)\n`;
        });
        cellText += `-------------------\n$${netTotal.toFixed(2)}`;

        return cellText;
    };


    doc.setFontSize(14); 
    doc.text("Estado de Cuenta Semanal", 14, 22);
    doc.setFontSize(9); 
    doc.text(`Cliente: ${selectedCustomerForInvoices.name}`, 14, 32);
    doc.text(`Semana del ${format(weekData.startDate, "dd/MM/yyyy", { locale: es })} al ${format(weekData.endDate, "dd/MM/yyyy", { locale: es })}`, 14, 38);
    
    let currentY = 48;

    if (weekData.purchases.length > 0) {
        doc.setFontSize(11); 
        doc.text("Facturas de la Semana:", 14, currentY);
        currentY += 6;
        const purchaseHead = [['Fecha', 'ID Factura', 'Productos Comprados', 'Monto Total (USD)']];
        const purchaseBody = weekData.purchases.map(sale => {
            const itemsString = sale.itemsPerBranch.flatMap(b => b.items).map(i => `${i.productName} (x${i.quantity})`).join(', ');
            const appliedCreditNotes = initialPaymentsDataGlobal.filter(p => p.appliedToInvoiceId === sale.id && p.paymentMethod === 'Nota de Crédito');
            let creditNoteDetails = '';
            if (appliedCreditNotes.length > 0) {
              creditNoteDetails = '\nNotas de Crédito Aplicadas:\n' + appliedCreditNotes.map(cn => `  - NC ${cn.notes?.split(': ')[1] || cn.id}: -$${cn.amountAppliedToDebtUSD.toFixed(2)} (${format(parseISO(cn.paymentDate), "dd/MM/yy", { locale: es })})`).join('\n');
            }
            return [
                format(parseISO(sale.date), "dd/MM/yy", { locale: es }),
                sale.id,
                itemsString + creditNoteDetails,
                formatInvoiceTotalCell(sale)
            ];
        });
        doc.autoTable({ 
            startY: currentY, 
            head: purchaseHead, 
            body: purchaseBody, 
            theme: 'grid',
            headStyles: { fillColor: [52, 152, 219], fontSize: 8 }, 
            bodyStyles: { fontSize: 7, cellPadding: 1.5, minCellHeight: 10 }, 
            columnStyles: { 2: { cellWidth: 'auto' }, 3: { halign: 'right' } }
        });
        currentY = (doc as any).lastAutoTable.finalY + 8;
    }

    if (weekData.creditNotes.length > 0) {
        doc.setFontSize(11); 
        doc.text("Notas de Crédito en la Semana:", 14, currentY);
        currentY += 6;
        const creditNoteHead = [['Fecha NC', 'NC ID', 'Factura Afectada', 'Detalle Devolución', 'Monto Crédito (USD)']];
        const creditNoteBody = weekData.creditNotes.map(creditNote => {
            const creditNoteItemsString = creditNote.changes?.map(c => `${c.productName} (x${c.quantity})`).join(', ') || 'N/A';
            return [
                format(parseISO(creditNote.date), "dd/MM/yy", { locale: es }),
                creditNote.id,
                creditNote.creditNoteTargetInvoiceId || 'N/A',
                creditNoteItemsString,
                `-${Math.abs(creditNote.totalAmount).toFixed(2)}`
            ];
        });
        doc.autoTable({
            startY: currentY,
            head: creditNoteHead,
            body: creditNoteBody,
            theme: 'grid',
            headStyles: { fillColor: [243, 156, 18], fontSize: 8 }, 
            bodyStyles: { fontSize: 7, cellPadding: 1.5 }, 
            columnStyles: { 3: { cellWidth: 'auto' } }
        });
        currentY = (doc as any).lastAutoTable.finalY + 8;
    } else if (weekData.returns.length > 0) {
        doc.setFontSize(11); 
        doc.text("Devoluciones/Cambios de la Semana:", 14, currentY);
        currentY += 6;
        const returnHead = [['Fecha', 'Factura Afectada', 'Producto Devuelto', 'Cant.', 'P. Unitario (USD)', 'Subtotal (USD)']];
        const returnBody = weekData.returns.flatMap(ret => 
            ret.items.map(item => [
                format(parseISO(ret.saleDate), "dd/MM/yy", { locale: es }),
                ret.saleId,
                item.productName, 
                item.quantity, 
                item.unitPrice.toFixed(2), 
                `-${item.subtotal.toFixed(2)}`
            ])
        );
        doc.autoTable({ 
            startY: currentY, 
            head: returnHead, 
            body: returnBody, 
            theme: 'grid',
            headStyles: { fillColor: [231, 76, 60], fontSize: 8 }, 
            bodyStyles: { fontSize: 7, cellPadding: 1.5 } 
        });
        currentY = (doc as any).lastAutoTable.finalY + 8;
    }
    
    doc.setFontSize(11); 
    doc.text(`Total Comprado: $${weekData.totalPurchased.toFixed(2)}`, 14, currentY);
    currentY += 6;
    doc.text(`Total Devuelto (por cambios/NC): -$${weekData.totalReturned.toFixed(2)}`, 14, currentY);
    currentY += 6;
    doc.setFontSize(12); 
    doc.setFont("helvetica", "bold");
    doc.text(`Neto a Pagar por la Semana: $${weekData.netTotal.toFixed(2)}`, 14, currentY);
    
    doc.save(`estado_cuenta_${selectedCustomerForInvoices.name.replace(/\s/g, '_')}_${weekData.weekKey}.pdf`);
    toast({ title: "Estado de cuenta semanal generado.", description: `Se ha descargado el PDF.` });
  };


  return (
    <div className="space-y-6">
      <PageHeader
        title="Gestión de Clientes"
        description="Gestiona la información y relaciones con tus clientes. Analiza sus patrones de compra y devoluciones (global)."
        icon={Users}
        actions={
          <Button onClick={() => { resetAddForm(); setIsAddCustomerDialogOpen(true); }}>
            <PlusCircle className="mr-2 h-4 w-4" />
            Añadir Nuevo Cliente
          </Button>
        }
      />

      <Card className="shadow-lg">
        <CardHeader>
          <CardTitle>Todos los Clientes (Global)</CardTitle>
          <CardDescription>Una lista de todos tus valiosos clientes, sus saldos y acceso a estadísticas de compra.</CardDescription>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Nombre</TableHead>
                <TableHead>Contacto</TableHead>
                <TableHead>Correo Electrónico</TableHead>
                <TableHead>Zona donde trabaja</TableHead>
                <TableHead>Último Pedido</TableHead>
                <TableHead className="text-right">Saldo (USD)</TableHead>
                <TableHead className="text-center">Acciones</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {currentCustomers.map((customer) => {
                const balance = (customer as any).balance;
                const isDebt = balance > 0;
                const balanceValue = Math.abs(balance);
                const balanceColor = balance < 0 ? 'text-green-600 dark:text-green-500' : balance > 0 ? 'text-destructive' : '';
                const balancePrefix = balance < 0 ? 'Saldo a Favor: $' : '$';

                return (
                <TableRow key={customer.id}>
                  <TableCell className="font-medium">{customer.name}</TableCell>
                  <TableCell>{customer.contact}</TableCell>
                  <TableCell>{customer.email || '-'}</TableCell>
                  <TableCell>{customer.workZone || '-'}</TableCell>
                  <TableCell>{customer.lastOrder && isValid(parseISO(customer.lastOrder)) ? format(parseISO(customer.lastOrder), "dd/MM/yyyy", { locale: es }) : '-'}</TableCell>
                  <TableCell className={cn("text-right font-semibold", balanceColor)}>
                     <FormattedNumber value={balanceValue} prefix={balancePrefix} />
                  </TableCell>
                  <TableCell className="text-center">
                    <div className="flex justify-center items-center space-x-1">
                       <Button variant="ghost" size="icon" title="Ver Estadísticas de Compras" onClick={() => handleOpenStatsDialog(customer)}>
                         <BarChartHorizontal className="h-4 w-4" />
                       </Button>
                       <Button variant="ghost" size="icon" title="Ver Estado de Cuenta" onClick={() => handleOpenInvoiceHistoryDialog(customer)}>
                         <InvoiceHistoryIcon className="h-4 w-4" />
                       </Button>
                      <DropdownMenu>
                        <DropdownMenuTrigger asChild>
                          <Button variant="ghost" size="icon" title="Más Acciones">
                            <MoreHorizontal className="h-4 w-4" />
                          </Button>
                        </DropdownMenuTrigger>
                        <DropdownMenuContent align="end">
                          <DropdownMenuItem onClick={() => handleOpenEditDialog(customer)}>
                            <Edit className="mr-2 h-4 w-4" />
                            Editar Cliente
                          </DropdownMenuItem>
                          <DropdownMenuItem 
                            onClick={() => handleOpenDeleteDialog(customer.id)}
                            className="text-destructive focus:text-destructive-foreground focus:bg-destructive"
                          >
                            <Trash2 className="mr-2 h-4 w-4" />
                            Eliminar Cliente
                          </DropdownMenuItem>
                        </DropdownMenuContent>
                      </DropdownMenu>
                    </div>
                  </TableCell>
                </TableRow>
              )})}
            </TableBody>
          </Table>
          {currentCustomers.length === 0 && <p className="text-center text-muted-foreground py-8">No hay clientes registrados.</p>}
        </CardContent>
      </Card>

      {/* Add Customer Dialog */}
      <Dialog open={isAddCustomerDialogOpen} onOpenChange={setIsAddCustomerDialogOpen}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Añadir Nuevo Cliente</DialogTitle>
            <DialogDescription>
              Ingresa los detalles del nuevo cliente.
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="space-y-1">
              <Label htmlFor="new_customer_name">Nombre Completo</Label>
              <Input id="new_customer_name" value={newCustomerName} onChange={(e) => setNewCustomerName(e.target.value)} placeholder="ej., Juan Pérez" />
            </div>
            <div className="space-y-1">
              <Label htmlFor="new_contact_phone">Número de Teléfono</Label>
              <Input id="new_contact_phone" type="tel" value={newCustomerContact} onChange={(e) => setNewCustomerContact(e.target.value)} placeholder="ej., 555-123-4567" />
            </div>
            <div className="space-y-1">
              <Label htmlFor="new_email_address">Correo Electrónico (Opcional)</Label>
              <Input id="new_email_address" type="email" value={newCustomerEmail} onChange={(e) => setNewCustomerEmail(e.target.value)} placeholder="ej., juan.perez@example.com" />
            </div>
            <div className="space-y-1">
              <Label htmlFor="new_address">Dirección (Opcional)</Label>
              <Input id="new_address" value={newCustomerAddress} onChange={(e) => setNewCustomerAddress(e.target.value)} placeholder="ej., Calle Principal 123, Ciudad" />
            </div>
            <div className="space-y-1">
              <Label htmlFor="new_work_zone">Zona donde trabaja (Opcional)</Label>
              <Input id="new_work_zone" value={newCustomerWorkZone} onChange={(e) => setNewCustomerWorkZone(e.target.value)} placeholder="ej., Oficina Central, Ruta Norte" />
            </div>
          </div>
          <DialogFooter>
            <DialogClose asChild>
              <Button variant="outline" onClick={() => setIsAddCustomerDialogOpen(false)}>Cancelar</Button>
            </DialogClose>
            <Button type="button" onClick={handleAddCustomer}>Guardar Cliente</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Edit Customer Dialog */}
      <Dialog open={isEditCustomerDialogOpen} onOpenChange={setIsEditCustomerDialogOpen}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Editar Cliente</DialogTitle>
            <DialogDescription>
              Actualiza los detalles del cliente.
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="space-y-1">
              <Label htmlFor="edit_customer_name">Nombre Completo</Label>
              <Input id="edit_customer_name" value={editCustomerName} onChange={(e) => setEditCustomerName(e.target.value)} />
            </div>
            <div className="space-y-1">
              <Label htmlFor="edit_contact_phone">Número de Teléfono</Label>
              <Input id="edit_contact_phone" type="tel" value={editCustomerContact} onChange={(e) => setEditCustomerContact(e.target.value)} />
            </div>
            <div className="space-y-1">
              <Label htmlFor="edit_email_address">Correo Electrónico (Opcional)</Label>
              <Input id="edit_email_address" type="email" value={editCustomerEmail} onChange={(e) => setEditCustomerEmail(e.target.value)} />
            </div>
            <div className="space-y-1">
              <Label htmlFor="edit_address">Dirección (Opcional)</Label>
              <Input id="edit_address" value={editCustomerAddress} onChange={(e) => setEditCustomerAddress(e.target.value)} />
            </div>
             <div className="space-y-1">
              <Label htmlFor="edit_work_zone">Zona donde trabaja (Opcional)</Label>
              <Input id="edit_work_zone" value={editCustomerWorkZone} onChange={(e) => setEditCustomerWorkZone(e.target.value)} />
            </div>
          </div>
          <DialogFooter>
            <DialogClose asChild>
              <Button variant="outline" onClick={() => {setIsEditCustomerDialogOpen(false); setEditingCustomer(null);}}>Cancelar</Button>
            </DialogClose>
            <Button type="button" onClick={handleUpdateCustomer}>Guardar Cambios</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Delete Confirm Dialog */}
      <Dialog open={isDeleteConfirmDialogOpen} onOpenChange={setIsDeleteConfirmDialogOpen}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Confirmar Eliminación</DialogTitle>
            <DialogDescription>
              ¿Estás seguro de que quieres eliminar a este cliente? Esta acción no se puede deshacer.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter className="sm:justify-end">
            <DialogClose asChild>
              <Button variant="outline" onClick={() => {setIsDeleteConfirmDialogOpen(false); setCustomerToDeleteId(null)}}>Cancelar</Button>
            </DialogClose>
            <Button variant="destructive" onClick={handleConfirmDelete}>Eliminar Cliente</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Customer Statistics Dialog */}
      <Dialog open={isStatsDialogOpen} onOpenChange={setIsStatsDialogOpen}>
        <DialogContent className="sm:max-w-3xl">
          <DialogHeader>
            <DialogTitle>Estadísticas de Cliente: {selectedCustomerForStats?.name}</DialogTitle>
            <DialogDescription>Patrones de compra y devoluciones del cliente (filtrado por fecha si se aplica).</DialogDescription>
          </DialogHeader>
          <div className="flex flex-col sm:flex-row items-center gap-2 py-2 border-b mb-2">
              <Popover>
                <PopoverTrigger asChild>
                  <Button
                    id="date-filter-stats-customers"
                    variant={"outline"}
                    className={cn(
                      "w-full sm:w-auto min-w-[200px] justify-start text-left font-normal",
                      !statsDateRangeFilter && "text-muted-foreground"
                    )}
                  >
                    <CalendarIcon className="mr-2 h-4 w-4" />
                    {statsDateRangeFilter?.from ? (
                      statsDateRangeFilter.to ? (
                        <>
                          {format(statsDateRangeFilter.from, "LLL dd, y", { locale: es })} -{" "}
                          {format(statsDateRangeFilter.to, "LLL dd, y", { locale: es })}
                        </>
                      ) : (
                        format(statsDateRangeFilter.from, "LLL dd, y", { locale: es })
                      )
                    ) : (
                      <span>Filtrar por Fecha de Ventas</span>
                    )}
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0" align="start">
                  <Calendar
                    initialFocus
                    mode="range"
                    defaultMonth={statsDateRangeFilter?.from}
                    selected={statsDateRangeFilter}
                    onSelect={setStatsDateRangeFilter}
                    numberOfMonths={2}
                    locale={es}
                  />
                </PopoverContent>
              </Popover>
              <Button onClick={() => setStatsDateRangeFilter(undefined)} variant="outline" className="w-full sm:w-auto" disabled={!statsDateRangeFilter?.from}>Limpiar Filtro Fecha</Button>
            </div>
          <ScrollArea className="max-h-[60vh] p-1 pr-4">
            {productsWithHighChangeRate.length > 0 && (
                <Alert variant="destructive" className="mb-4">
                    <AlertTriangle className="h-4 w-4" />
                    <AlertTitle>¡Atención!</AlertTitle>
                    <AlertDescription>
                        Se ha detectado una alta tasa de cambio/devolución (&gt;{HIGH_CHANGE_RATE_THRESHOLD}%) para los siguientes productos:
                        <ul className="list-disc list-inside ml-4 mt-1">
                            {productsWithHighChangeRate.map(productName => (
                                <li key={productName}>{productName}</li>
                            ))}
                        </ul>
                        Considera revisar estos casos.
                    </AlertDescription>
                </Alert>
            )}
            <div className="space-y-6 py-4">
              <Card>
                <CardHeader>
                  <CardTitle>Productos Más Comprados (Top 10)</CardTitle>
                </CardHeader>
                <CardContent className="h-[300px] w-full">
                  {productSalesStats.length > 0 ? (
                    <ChartContainer config={salesChartConfig} className="h-full w-full">
                      <BarChart data={productSalesStats.slice(0, 10)} layout="vertical" margin={{ left: 20, right:20 }}>
                        <CartesianGrid strokeDasharray="3 3" />
                        <XAxis type="number" allowDecimals={false} />
                        <YAxis dataKey="name" type="category" width={150} interval={0} />
                        <RechartsTooltip content={<ChartTooltipContent />} />
                        <RechartsLegend content={<ChartLegendContent />} />
                        <Bar dataKey="quantity" fill="var(--color-quantity)" radius={4} nameKey="name" />
                      </BarChart>
                    </ChartContainer>
                  ) : (
                    <p className="text-center text-muted-foreground">No hay datos de ventas para este cliente {statsDateRangeFilter?.from ? "en el rango seleccionado" : ""}.</p>
                  )}
                </CardContent>
              </Card>

              <Card>
                <CardHeader>
                  <CardTitle>Productos Más Cambiados/Devueltos (Top 10)</CardTitle>
                </CardHeader>
                <CardContent className="h-[300px] w-full">
                  {productChangesStats.length > 0 ? (
                    <ChartContainer config={changesChartConfig} className="h-full w-full">
                       <BarChart data={productChangesStats.slice(0, 10)} layout="vertical" margin={{ left: 20, right:20 }}>
                        <CartesianGrid strokeDasharray="3 3" />
                        <XAxis type="number" allowDecimals={false} />
                        <YAxis dataKey="name" type="category" width={150} interval={0} />
                        <RechartsTooltip content={<ChartTooltipContent />} />
                        <RechartsLegend content={<ChartLegendContent />} />
                        <Bar dataKey="quantity" fill="var(--color-quantity)" radius={4} nameKey="name" />
                      </BarChart>
                    </ChartContainer>
                  ) : (
                    <p className="text-center text-muted-foreground">No hay datos de cambios/devoluciones para este cliente {statsDateRangeFilter?.from ? "en el rango seleccionado" : ""}.</p>
                  )}
                </CardContent>
              </Card>

              <Card>
                <CardHeader>
                  <CardTitle>Resumen de Ventas vs. Cambios por Producto</CardTitle>
                </CardHeader>
                <CardContent>
                  {combinedProductStats.length > 0 ? (
                    <Table>
                      <TableHeader>
                        <TableRow>
                          <TableHead>Producto</TableHead>
                          <TableHead className="text-right">Cant. Vendida</TableHead>
                          <TableHead className="text-right">Devoluciones (Total)</TableHead>
                          <TableHead className="text-right">Tasa de Cambio (%)</TableHead>
                        </TableRow>
                      </TableHeader>
                      <TableBody>
                        {combinedProductStats.map(stat => (
                          <TableRow key={stat.name}>
                            <TableCell>{stat.name}</TableCell>
                            <TableCell className="text-right">{stat.sold}</TableCell>
                            <TableCell className="text-right">
                              <TooltipProvider>
                                <Tooltip>
                                  <TooltipTrigger asChild>
                                    <span className={cn(stat.totalChanged > 0 && "underline decoration-dashed cursor-help")}>
                                      {stat.totalChanged}
                                    </span>
                                  </TooltipTrigger>
                                  {stat.totalChanged > 0 && (
                                  <TooltipContent>
                                    <p>En buen estado: {stat.changedNormal}</p>
                                    <p>No despachable: {stat.changedNonDispatchable}</p>
                                  </TooltipContent>
                                  )}
                                </Tooltip>
                              </TooltipProvider>
                            </TableCell>
                            <TableCell className={cn("text-right", stat.changeRate > HIGH_CHANGE_RATE_THRESHOLD ? "text-destructive font-semibold" : stat.changeRate > 5 ? "text-yellow-600" : "")}>
                              {stat.changeRate.toFixed(2)}%
                            </TableCell>
                          </TableRow>
                        ))}
                      </TableBody>
                    </Table>
                  ) : (
                     <p className="text-center text-muted-foreground">No hay datos combinados para mostrar {statsDateRangeFilter?.from ? "en el rango seleccionado" : ""}.</p>
                  )}
                </CardContent>
              </Card>
            </div>
          </ScrollArea>
          <DialogFooter>
            <DialogClose asChild>
              <Button variant="outline" onClick={() => {setIsStatsDialogOpen(false); setSelectedCustomerForStats(null); setStatsDateRangeFilter(undefined); setProductsWithHighChangeRate([]);}}>Cerrar</Button>
            </DialogClose>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      
      <Dialog open={isInvoiceHistoryDialogOpen} onOpenChange={setIsInvoiceHistoryDialogOpen}>
        <DialogContent className="sm:max-w-4xl lg:max-w-7xl">
            <DialogHeader>
                <DialogTitle>Estado de Cuenta: {selectedCustomerForInvoices?.name}</DialogTitle>
                <DialogDescription>Resumen de facturas pendientes y desglose de actividad semanal.</DialogDescription>
            </DialogHeader>
             <div className="flex flex-col sm:flex-row items-center gap-2 py-2 border-b mb-2">
                <Popover><PopoverTrigger asChild><Button id="date-filter-invoice-history" variant={"outline"} className={cn("w-full sm:w-auto min-w-[200px] justify-start text-left font-normal", !invoiceHistoryDateRangeFilter && "text-muted-foreground")}><CalendarIcon className="mr-2 h-4 w-4" />{invoiceHistoryDateRangeFilter?.from ? (invoiceHistoryDateRangeFilter.to ? (<>{format(invoiceHistoryDateRangeFilter.from, "LLL dd, y", { locale: es })} - {format(invoiceHistoryDateRangeFilter.to, "LLL dd, y", { locale: es })}</>) : (format(invoiceHistoryDateRangeFilter.from, "LLL dd, y", { locale: es }))) : (<span>Filtrar por Fecha</span>)}</Button></PopoverTrigger>
                    <PopoverContent className="w-auto p-0" align="start"><Calendar initialFocus mode="range" defaultMonth={invoiceHistoryDateRangeFilter?.from} selected={invoiceHistoryDateRangeFilter} onSelect={setInvoiceHistoryDateRangeFilter} numberOfMonths={2} locale={es} /></PopoverContent>
                </Popover>
                <Button onClick={() => setInvoiceHistoryDateRangeFilter(undefined)} variant="outline" className="w-full sm:w-auto" disabled={!invoiceHistoryDateRangeFilter?.from}>Limpiar Filtro</Button>
            </div>

            <ScrollArea className="max-h-[60vh] p-1 pr-4">
                 <Card className="mb-4">
                    <CardHeader><CardTitle>Facturas con Saldo Pendiente</CardTitle></CardHeader>
                    <CardContent>
                      <Accordion type="multiple" className="w-full space-y-2">
                          {customerInvoices
                            .filter(inv => calculateInvoiceBalance(inv.id, initialPaymentsDataGlobal, customerInvoices) > 0.01)
                            .map((invoice) => {
                              const status = getInvoiceStatus(invoice, initialPaymentsDataGlobal);
                              const balance = calculateInvoiceBalance(invoice.id, initialPaymentsDataGlobal, customerInvoices);
                              const appliedPayments = initialPaymentsDataGlobal.filter(p => p.appliedToInvoiceId === invoice.id);

                              return (
                                  <AccordionItem value={invoice.id} key={invoice.id} className="border rounded-md shadow-sm">
                                      <AccordionTrigger className="px-4 py-3 hover:bg-muted/50 rounded-t-md text-left">
                                          <div className="flex flex-col sm:flex-row justify-between w-full items-start sm:items-center gap-2">
                                              <div className="flex-1"><p className="font-semibold text-sm">Factura ID: <span className="font-mono">{invoice.id}</span></p><p className="text-xs text-muted-foreground">Fecha: {invoice.date ? format(parseISO(invoice.date), "dd/MM/yyyy") : 'N/A'}</p></div>
                                              <div className="flex-1 text-right sm:text-left"><p className="text-xs">Monto Original: <FormattedNumber value={invoice.totalAmount} prefix="$" /></p><p className="text-xs font-semibold">Saldo Pendiente: <span className="text-destructive"><FormattedNumber value={balance} prefix="$" /></span></p></div>
                                              <div className="flex-1 text-right"><Badge variant={status === 'Vencida' ? 'destructive' : 'secondary'} className="whitespace-nowrap">{status}</Badge></div>
                                          </div>
                                      </AccordionTrigger>
                                      <AccordionContent className="px-4 py-3 border-t">
                                        {appliedPayments.length > 0 ? (
                                          <div>
                                            <h4 className="text-xs font-semibold mb-1.5">Pagos y Créditos Aplicados:</h4>
                                            <ul className="space-y-1">
                                              {appliedPayments.map(p => {
                                                const creditNote = p.paymentMethod === 'Nota de Crédito' ? initialSalesDataGlobal.find(s => s.id === p.notes?.split(': ')[1]) : null;
                                                return (
                                                  <li key={p.id} className="text-xs p-2 border rounded-md bg-muted/30">
                                                    <p>
                                                      {format(parseISO(p.paymentDate), 'dd/MM/yy')}: <strong>{p.paymentMethod}</strong> por <strong className="text-green-600"><FormattedNumber value={p.amountAppliedToDebtUSD} prefix="$" /></strong>.
                                                    </p>
                                                    {creditNote && creditNote.changes && (
                                                      <div className="pl-4 mt-1">
                                                        <p className="font-medium">Detalle Devolución (NC):</p>
                                                        <ul className="list-disc list-inside text-muted-foreground">
                                                          {creditNote.changes.map((item, idx) => (
                                                            <li key={idx}>{item.productName} (x{item.quantity})</li>
                                                          ))}
                                                        </ul>
                                                      </div>
                                                    )}
                                                  </li>
                                                )
                                              })}
                                            </ul>
                                          </div>
                                        ) : (
                                          <p className="text-xs text-muted-foreground text-center py-2">No hay pagos ni notas de crédito aplicados a esta factura.</p>
                                        )}
                                      </AccordionContent>
                                  </AccordionItem>
                              );
                          })}
                          {customerInvoices.filter(inv => calculateInvoiceBalance(inv.id, initialPaymentsDataGlobal, customerInvoices) > 0.01).length === 0 && (
                            <p className="text-center text-muted-foreground py-8">Este cliente no tiene facturas pendientes.</p>
                          )}
                      </Accordion>
                    </CardContent>
                </Card>
                <Separator className="my-4" />
                 {weeklySummaries.map(week => {
                    const hasCreditNotes = week.creditNotes.length > 0;
                    const hasReturns = week.returns.length > 0;

                    return (
                        <Card key={week.weekKey} className="mb-4">
                            <CardHeader className="flex flex-row justify-between items-center bg-muted/50 p-3 rounded-t-md">
                                <div>
                                    <CardTitle className="text-base">Resumen Semanal</CardTitle>
                                    <CardDescription className="text-sm">{format(week.startDate, "dd/MM/yyyy")} - {format(week.endDate, "dd/MM/yyyy")}</CardDescription>
                                </div>
                                <Button variant="outline" size="sm" onClick={() => handleGenerateWeeklyStatementPDF(week)}><Download className="mr-2 h-4 w-4" />Generar PDF</Button>
                            </CardHeader>
                            <CardContent className="space-y-4 p-3">
                                {week.purchases.length > 0 && (
                                    <div>
                                        <h4 className="font-semibold mb-2 p-2 bg-blue-500/10 text-blue-800 dark:text-blue-200 rounded-md text-sm">Facturas de la Semana</h4>
                                        <Table>
                                            <TableHeader><TableRow><TableHead>Fecha</TableHead><TableHead>ID Factura</TableHead><TableHead>Productos Comprados</TableHead><TableHead className="text-right">Monto (USD)</TableHead></TableRow></TableHeader>
                                            <TableBody>
                                                {week.purchases.map((sale, i) => {
                                                    const appliedCreditNotes = initialPaymentsDataGlobal.filter(p => p.appliedToInvoiceId === sale.id && p.paymentMethod === 'Nota de Crédito');
                                                    const totalCreditApplied = appliedCreditNotes.reduce((sum, cn) => sum + cn.amountAppliedToDebtUSD, 0);
                                                    const netTotal = sale.totalAmount - totalCreditApplied;
                                                    
                                                    return (
                                                    <TableRow key={`buy-${i}`}>
                                                        <TableCell className="text-xs">{format(parseISO(sale.date), "dd/MM/yy", { locale: es })}</TableCell>
                                                        <TableCell className="text-xs">{sale.id}</TableCell>
                                                        <TableCell className="text-xs">{sale.itemsPerBranch.flatMap(b => b.items).map(item => `${item.productName} (x${item.quantity})`).join(', ')}</TableCell>
                                                        <TableCell className="text-right text-xs">
                                                            {totalCreditApplied > 0 ? (
                                                                <div className="flex flex-col items-end">
                                                                    <span><FormattedNumber value={sale.totalAmount} prefix="$" /></span>
                                                                    <span className="text-destructive">- <FormattedNumber value={totalCreditApplied} prefix="$" /> (NC)</span>
                                                                    <hr className="w-16 my-0.5 border-foreground/50"/>
                                                                    <span className="font-bold"><FormattedNumber value={netTotal} prefix="$" /></span>
                                                                </div>
                                                            ) : (
                                                                <FormattedNumber value={sale.totalAmount} prefix="$" />
                                                            )}
                                                        </TableCell>
                                                    </TableRow>
                                                )})}
                                            </TableBody>
                                        </Table>
                                    </div>
                                )}
                                {hasCreditNotes ? (
                                    <div>
                                        <h4 className="font-semibold mb-2 p-2 bg-amber-500/10 text-amber-800 dark:text-amber-200 rounded-md text-sm">Notas de Crédito</h4>
                                        <Table>
                                          <TableHeader><TableRow><TableHead>Fecha</TableHead><TableHead>ID Nota Crédito</TableHead><TableHead>Factura Afectada</TableHead><TableHead>Productos Devueltos</TableHead><TableHead className="text-right">Monto (USD)</TableHead></TableRow></TableHeader>
                                          <TableBody>
                                              {week.creditNotes.map(cn => (
                                                <TableRow key={cn.id}>
                                                  <TableCell className="text-xs">{format(parseISO(cn.date), "dd/MM/yy")}</TableCell>
                                                  <TableCell className="text-xs">{cn.id}</TableCell>
                                                  <TableCell className="text-xs">{cn.creditNoteTargetInvoiceId || 'N/A'}</TableCell>
                                                  <TableCell className="text-xs">{cn.changes?.map(c => `${c.productName} (x${c.quantity})`).join(', ') || 'N/A'}</TableCell>
                                                  <TableCell className="text-right text-destructive text-xs"><FormattedNumber value={Math.abs(cn.totalAmount)} prefix="-$" /></TableCell>
                                                </TableRow>
                                              ))}
                                          </TableBody>
                                        </Table>
                                    </div>
                                ) : hasReturns ? (
                                     <div>
                                        <h4 className="font-semibold mb-2 p-2 bg-red-500/10 text-red-800 dark:text-red-200 rounded-md text-sm">Devoluciones/Cambios</h4>
                                        <Table>
                                          <TableHeader><TableRow><TableHead>Fecha</TableHead><TableHead>Factura Afectada</TableHead><TableHead>Producto Devuelto</TableHead><TableHead className="text-right">Cantidad</TableHead><TableHead className="text-right">Subtotal (USD)</TableHead></TableRow></TableHeader>
                                          <TableBody>
                                              {week.returns.flatMap(ret => ret.items.map((item, idx) => (
                                                <TableRow key={`return-${ret.saleId}-${idx}`}>
                                                  <TableCell className="text-xs">{format(parseISO(ret.saleDate), "dd/MM/yy")}</TableCell>
                                                  <TableCell className="text-xs">{ret.saleId}</TableCell>
                                                  <TableCell className="text-xs">{item.productName}</TableCell>
                                                  <TableCell className="text-right text-xs">{item.quantity}</TableCell>
                                                  <TableCell className="text-right text-destructive text-xs"><FormattedNumber value={item.subtotal} prefix="-$" /></TableCell>
                                                </TableRow>
                                              )))}
                                          </TableBody>
                                        </Table>
                                    </div>
                                ) : null}
                            </CardContent>
                            <CardFooter className="flex justify-end font-bold text-lg bg-muted/50 p-3 rounded-b-md">
                                <p>Total Semana: <FormattedNumber value={week.netTotal} prefix="$" /></p>
                            </CardFooter>
                        </Card>
                    )
                 })}
                {weeklySummaries.length === 0 && <p className="text-center text-muted-foreground py-8">No hay actividad de ventas para este cliente en el período seleccionado.</p>}
            </ScrollArea>
            <DialogFooter>
                <DialogClose asChild><Button variant="outline" onClick={() => { setIsInvoiceHistoryDialogOpen(false); setSelectedCustomerForInvoices(null); setCustomerInvoices([]); }}>Cerrar</Button></DialogClose>
            </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}

// --- data-management ---


"use client";

import React, { useState, useCallback, ChangeEvent } from 'react';
import { PageHeader } from '@/components/page-header';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { ArchiveRestore, Upload, Download, AlertTriangle, Loader2, Trash2, ShoppingCart, Users, Package, Settings, Archive, CreditCard, Landmark, Target, Utensils, Receipt, CheckCircle2, ArrowRightLeft, ListFilter, Shuffle, FileText, DollarSign } from 'lucide-react';
import { useToast } from "@/hooks/use-toast";
import { KEYS, availableBranches, getActiveBranchId, dispatchDataUpdateEvent, type Branch } from '@/lib/data-storage';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from '@/components/ui/alert-dialog';
import { cn } from '@/lib/utils';
import { format } from 'date-fns';
import { Checkbox } from '@/components/ui/checkbox';
import { Separator } from '@/components/ui/separator';

const dataModules = [
  { id: KEYS.CUSTOMERS, name: 'Clientes (Global)', keys: [KEYS.CUSTOMERS], icon: Users },
  { id: KEYS.SALES, name: 'Ventas (Global)', keys: [KEYS.SALES], icon: ShoppingCart },
  { id: KEYS.PAYMENTS, name: 'Pagos (Global)', keys: [KEYS.PAYMENTS], icon: CreditCard },
  { id: KEYS.PENDING_FUND_TRANSFERS, name: 'Transf. Fondos Pendientes (Global)', keys: [KEYS.PENDING_FUND_TRANSFERS], icon: Shuffle },
  { id: KEYS.INVENTORY_TRANSFERS, name: 'Transf. de Inventario MP (Global)', keys: [KEYS.INVENTORY_TRANSFERS], icon: ArrowRightLeft },
  { id: KEYS.SUPPLIERS, name: 'Proveedores (Global)', keys: [KEYS.SUPPLIERS], icon: Users },
  { id: KEYS.RAW_MATERIAL_OPTIONS, name: 'Opciones de Materia Prima (Global)', keys: [KEYS.RAW_MATERIAL_OPTIONS], icon: ListFilter },
  { id: KEYS.EXCHANGE_RATE_HISTORY, name: 'Historial Tasa de Cambio (Global)', keys: [KEYS.EXCHANGE_RATE_HISTORY], icon: Landmark },
  { id: KEYS.USER_PROFILE, name: 'Perfil de Usuario (Global)', keys: [KEYS.USER_PROFILE], icon: Settings },
  { id: KEYS.CUSTOM_CONVERSION_RULES, name: 'Reglas de Conversión (Global)', keys: [KEYS.CUSTOM_CONVERSION_RULES], icon: Settings },
  { id: KEYS.WEEKLY_LOSS_REPORTS, name: 'Reportes Semanales Pérdida (Global)', keys: [KEYS.WEEKLY_LOSS_REPORTS], icon: FileText },
  { id: KEYS.WEEKLY_PROFIT_REPORTS, name: 'Reportes Semanales Ganancia (Global)', keys: [KEYS.WEEKLY_PROFIT_REPORTS], icon: FileText },
  
  { id: 'separator-branch', name: 'Datos por Sede', type: 'separator' },
  
  { id: KEYS.PRODUCTS, name: 'Stock de Productos Terminados (por Sede)', keys: [KEYS.PRODUCTS], icon: Package },
  { id: KEYS.RAW_MATERIAL_INVENTORY, name: 'Inventario Materia Prima (por Sede)', keys: [KEYS.RAW_MATERIAL_INVENTORY], icon: Archive },
  { id: KEYS.PRODUCTION_LOG, name: 'Logs de Producción (por Sede)', keys: [KEYS.PRODUCTION_LOG], icon: Package },
  { id: KEYS.RECIPES, name: 'Recetas (por Sede)', keys: [KEYS.RECIPES], icon: Utensils },
  { id: KEYS.PURCHASE_ORDERS, name: 'Órdenes de Compra (por Sede)', keys: [KEYS.PURCHASE_ORDERS], icon: Receipt },
  { id: KEYS.WEEKLY_GOALS, name: 'Metas Semanales (por Sede)', keys: [KEYS.WEEKLY_GOALS], icon: Target },
  { id: KEYS.MONTHLY_GOALS, name: 'Metas Mensuales (por Sede)', keys: [KEYS.MONTHLY_GOALS], icon: Target },
  { id: KEYS.EMPLOYEES, name: 'Empleados (por Sede)', keys: [KEYS.EMPLOYEES], icon: Users },
  { id: KEYS.EXPENSES, name: 'Gastos (por Sede)', keys: [KEYS.EXPENSES], icon: DollarSign },
  { id: KEYS.COMPANY_ACCOUNTS, name: 'Cuentas de la Empresa (por Sede)', keys: [KEYS.COMPANY_ACCOUNTS], icon: Landmark },
  { id: KEYS.ACCOUNT_TRANSACTIONS, name: 'Movimientos de Cuenta (por Sede)', keys: [KEYS.ACCOUNT_TRANSACTIONS], icon: Landmark },
  { id: KEYS.EXPENSE_FIXED_CATEGORIES, name: 'Categorías de Gastos Fijos (por Sede)', keys: [KEYS.EXPENSE_FIXED_CATEGORIES], icon: Settings },
  { id: KEYS.EXPENSE_VARIABLE_CATEGORIES, name: 'Categorías de Gastos Variables (por Sede)', keys: [KEYS.EXPENSE_VARIABLE_CATEGORIES], icon: Settings },
];


export default function DataManagementPage() {
  const { toast } = useToast();
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [isProcessing, setIsProcessing] = useState(false);
  const [selectedModules, setSelectedModules] = useState<Set<string>>(new Set());

  const handleModuleSelection = (moduleId: string) => {
    setSelectedModules(prev => {
      const newSelection = new Set(prev);
      if (newSelection.has(moduleId)) {
        newSelection.delete(moduleId);
      } else {
        newSelection.add(moduleId);
      }
      return newSelection;
    });
  };

  const handleSelectAllModules = () => {
    setSelectedModules(new Set(dataModules.filter(m => m.type !== 'separator').map(m => m.id)));
  };

  const handleDeselectAllModules = () => {
    setSelectedModules(new Set());
  };

  const handleExportSelectedData = useCallback(() => {
    if (selectedModules.size === 0) {
      toast({
        title: "Sin Selección",
        description: "Por favor, selecciona al menos un módulo para exportar.",
        variant: "destructive",
      });
      return;
    }

    setIsProcessing(true);
    try {
      const exportData: { [key: string]: any } = {};
      const modulesToExport = dataModules.filter(m => selectedModules.has(m.id));
      const keysToExport = [...new Set(modulesToExport.flatMap(m => m.keys || []))];
      const selectedModuleNames = modulesToExport.map(m => m.name).join(', ');
      
      keysToExport.forEach(baseKey => {
        const isGlobalKey = [
            KEYS.CUSTOMERS, KEYS.SALES, KEYS.PAYMENTS, KEYS.PENDING_FUND_TRANSFERS,
            KEYS.SUPPLIERS, KEYS.RAW_MATERIAL_OPTIONS, KEYS.EXCHANGE_RATE_HISTORY,
            KEYS.USER_PROFILE, KEYS.CUSTOM_CONVERSION_RULES, KEYS.INVENTORY_TRANSFERS,
            KEYS.ACTIVE_BRANCH_ID, KEYS.WEEKLY_LOSS_REPORTS, KEYS.WEEKLY_PROFIT_REPORTS
        ].includes(baseKey as any);

        if (isGlobalKey) {
          const data = localStorage.getItem(baseKey);
          if (data !== null) {
            try { exportData[baseKey] = JSON.parse(data); } catch (e) { exportData[baseKey] = data; }
          }
        } else {
          availableBranches.forEach(branch => {
            const branchSpecificKey = `${baseKey}_${branch.id}`;
            const data = localStorage.getItem(branchSpecificKey);
            if (data !== null) {
              try { exportData[branchSpecificKey] = JSON.parse(data); } catch (e) { exportData[branchSpecificKey] = data; }
            }
          });
        }
      });

      const fullExportObject = {
        metadata: {
          version: 2,
          moduleName: `Módulos Seleccionados: ${selectedModuleNames}`,
          exportDate: new Date().toISOString(),
          source: "PanaderiaProApp",
          activeBranchIdBeforeExport: getActiveBranchId(),
        },
        data: exportData
      };

      const jsonString = JSON.stringify(fullExportObject, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `respaldo_modulos_seleccionados_${format(new Date(), "dd-MM-yyyy")}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      toast({
        title: "Exportación Exitosa",
        description: `${selectedModules.size} módulo(s) exportado(s) correctamente.`,
      });
    } catch (error) {
      console.error("Error durante la exportación:", error);
      toast({
        title: "Error de Exportación",
        description: "Ocurrió un problema al exportar los datos.",
        variant: "destructive",
      });
    } finally {
      setIsProcessing(false);
    }
  }, [selectedModules, toast]);


  const handleExportAllData = useCallback(() => {
    const allKeys = Object.values(KEYS);
    
    setIsProcessing(true);
    try {
      const exportData: { [key: string]: any } = {};
      
      allKeys.forEach(baseKey => {
        const isGlobalKey = [
            KEYS.CUSTOMERS, KEYS.SALES, KEYS.PAYMENTS, KEYS.PENDING_FUND_TRANSFERS,
            KEYS.SUPPLIERS, KEYS.RAW_MATERIAL_OPTIONS, KEYS.EXCHANGE_RATE_HISTORY,
            KEYS.USER_PROFILE, KEYS.CUSTOM_CONVERSION_RULES, KEYS.INVENTORY_TRANSFERS,
            KEYS.ACTIVE_BRANCH_ID, KEYS.WEEKLY_LOSS_REPORTS, KEYS.WEEKLY_PROFIT_REPORTS
        ].includes(baseKey as any);

        if (isGlobalKey) {
          const data = localStorage.getItem(baseKey);
          if (data !== null) {
            try { exportData[baseKey] = JSON.parse(data); } catch (e) { exportData[baseKey] = data; }
          }
        } else {
          availableBranches.forEach(branch => {
            const branchSpecificKey = `${baseKey}_${branch.id}`;
            const data = localStorage.getItem(branchSpecificKey);
            if (data !== null) {
              try { exportData[branchSpecificKey] = JSON.parse(data); } catch (e) { exportData[branchSpecificKey] = data; }
            }
          });
        }
      });

      const fullExportObject = {
        metadata: {
          version: 2,
          moduleName: 'Todos los Datos',
          exportDate: new Date().toISOString(),
          source: "PanaderiaProApp",
          activeBranchIdBeforeExport: getActiveBranchId(),
        },
        data: exportData
      };

      const jsonString = JSON.stringify(fullExportObject, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `respaldo_completo_Panificadora_Valladares_${format(new Date(), "dd-MM-yyyy")}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      toast({
        title: "Exportación Completa Exitosa",
        description: `Todos los datos han sido exportados.`,
      });
    } catch (error) {
      console.error("Error durante la exportación completa:", error);
      toast({
        title: "Error de Exportación",
        description: "Ocurrió un problema al exportar los datos.",
        variant: "destructive",
      });
    } finally {
      setIsProcessing(false);
    }
  }, [toast]);


  const handleFileChange = (event: ChangeEvent<HTMLInputElement>) => {
    if (event.target.files && event.target.files[0]) {
      setSelectedFile(event.target.files[0]);
    } else {
      setSelectedFile(null);
    }
  };

  const handleImportData = useCallback(() => {
    if (!selectedFile) {
      toast({
        title: "Sin Archivo",
        description: "Por favor, selecciona un archivo JSON para importar.",
        variant: "destructive",
      });
      return;
    }
    setIsProcessing(true);
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const text = e.target?.result as string;
        const importedObject = JSON.parse(text);

        if (!importedObject || typeof importedObject.data !== 'object' || !importedObject.metadata || importedObject.metadata.source !== "PanaderiaProApp") {
          toast({
            title: "Archivo Inválido",
            description: "El archivo seleccionado no parece ser un archivo de datos válido de Panadería Pro.",
            variant: "destructive",
          });
          setIsProcessing(false);
          return;
        }
        
        const isFullBackup = importedObject.metadata?.moduleName === 'Todos los Datos';
        
        if (isFullBackup) {
            const allAppKeys = Object.values(KEYS);
            allAppKeys.forEach(baseKey => {
              const isGlobalKey = [
                  KEYS.CUSTOMERS, KEYS.SALES, KEYS.PAYMENTS, KEYS.PENDING_FUND_TRANSFERS,
                  KEYS.SUPPLIERS, KEYS.RAW_MATERIAL_OPTIONS, KEYS.EXCHANGE_RATE_HISTORY,
                  KEYS.USER_PROFILE, KEYS.CUSTOM_CONVERSION_RULES, KEYS.INVENTORY_TRANSFERS,
                  KEYS.ACTIVE_BRANCH_ID, KEYS.WEEKLY_LOSS_REPORTS, KEYS.WEEKLY_PROFIT_REPORTS
              ].includes(baseKey as any);

              if (isGlobalKey) {
                  localStorage.removeItem(baseKey);
              } else {
                  availableBranches.forEach(branch => {
                      localStorage.removeItem(`${baseKey}_${branch.id}`);
                  });
              }
            });
        }
        
        Object.entries(importedObject.data).forEach(([key, value]) => {
          if (key !== KEYS.ACTIVE_BRANCH_ID && key !== 'isUserLoggedIn') {
             localStorage.setItem(key, JSON.stringify(value));
          }
        });

        const importedActiveBranch = importedObject.metadata?.activeBranchIdBeforeExport;
        if (importedActiveBranch && availableBranches.some(b => b.id === importedActiveBranch)) {
            localStorage.setItem(KEYS.ACTIVE_BRANCH_ID, importedActiveBranch);
        }
        
        Object.values(KEYS).forEach(key => dispatchDataUpdateEvent(key));
        
        toast({
          title: "Importación Exitosa",
          description: "Datos importados. Se recomienda recargar la aplicación para asegurar que todos los cambios se apliquen.",
        });

        setTimeout(() => {
           if (localStorage.getItem(KEYS.ACTIVE_BRANCH_ID)) {
             window.location.href = '/';
           } else {
             window.location.href = '/select-branch';
           }
        }, 1500);

      } catch (error) {
        console.error("Error durante la importación:", error);
        toast({
          title: "Error de Importación",
          description: "Ocurrió un problema al leer o procesar el archivo JSON. Asegúrate de que el formato es correcto.",
          variant: "destructive",
        });
      } finally {
        setIsProcessing(false);
        setSelectedFile(null);
        const fileInput = document.getElementById('import-file-input') as HTMLInputElement;
        if (fileInput) fileInput.value = '';
      }
    };
    reader.readAsText(selectedFile);
  }, [selectedFile, toast]);

  const handleClearAllData = useCallback(() => {
    setIsProcessing(true);
    try {
      const allBaseKeys = Object.values(KEYS);
      allBaseKeys.forEach(baseKey => {
        const isGlobalKey = [
          KEYS.EXCHANGE_RATE, KEYS.EXCHANGE_RATE_HISTORY, KEYS.USER_PROFILE,
          KEYS.INVENTORY_TRANSFERS, KEYS.CUSTOMERS, KEYS.SALES, KEYS.PAYMENTS,
          KEYS.PENDING_FUND_TRANSFERS, KEYS.SUPPLIERS, KEYS.RAW_MATERIAL_OPTIONS,
          KEYS.CUSTOM_CONVERSION_RULES, KEYS.WEEKLY_LOSS_REPORTS, KEYS.WEEKLY_PROFIT_REPORTS,
          KEYS.ACTIVE_BRANCH_ID,
        ].includes(baseKey as any);

        if (isGlobalKey) {
          localStorage.removeItem(baseKey);
        } else {
          availableBranches.forEach(branch => {
            localStorage.removeItem(`${baseKey}_${branch.id}`);
          });
        }
      });
      
      localStorage.removeItem('isUserLoggedIn');

      toast({
        title: "Datos Eliminados",
        description: "Todos los datos de la aplicación han sido eliminados. Serás redirigido al login.",
      });

      setTimeout(() => {
        window.location.href = '/login';
      }, 1500);

    } catch (error) {
      console.error("Error durante la limpieza de datos:", error);
      toast({
        title: "Error de Limpieza",
        description: "Ocurrió un problema al eliminar los datos.",
        variant: "destructive",
      });
    } finally {
      setIsProcessing(false);
    }
  }, [toast]);


  return (
    <div className="space-y-8">
      <PageHeader
        title="Gestión de Datos de la Aplicación"
        description="Exporta tus datos para crear una copia de seguridad o transferirlos, o importa datos desde un archivo previamente exportado. También puedes limpiar todos los datos de la aplicación."
        icon={ArchiveRestore}
      />

      <Card className="shadow-lg">
        <CardHeader>
          <CardTitle>Exportar Datos</CardTitle>
          <CardDescription>
            Selecciona los módulos que deseas exportar o exporta toda la información de la aplicación.
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
            <div>
              <Label className="text-base font-semibold">Exportar por Módulo</Label>
              <p className="text-sm text-muted-foreground mb-4">Selecciona los módulos y haz clic en "Exportar Selección" para descargar un archivo JSON con su información.</p>
              
              <div className="space-y-3 rounded-md border p-4">
                {dataModules.map(module => {
                  if (module.type === 'separator') {
                    return <Separator key={module.id} className="my-4" />;
                  }
                  const Icon = module.icon;
                  return (
                    <div key={module.id} className="flex items-start space-x-3">
                      <Checkbox
                        id={`module-${module.id}`}
                        checked={selectedModules.has(module.id)}
                        onCheckedChange={() => handleModuleSelection(module.id)}
                        disabled={isProcessing}
                      />
                      <div className="grid gap-1.5 leading-none">
                        <label htmlFor={`module-${module.id}`} className="font-medium cursor-pointer flex items-center">
                          {Icon && <Icon className="mr-2 h-4 w-4 text-muted-foreground" />}
                          {module.name}
                        </label>
                      </div>
                    </div>
                  );
                })}
              </div>
              <div className="flex flex-col sm:flex-row gap-2 mt-4">
                  <Button onClick={handleSelectAllModules} variant="outline" disabled={isProcessing}>Seleccionar Todo</Button>
                  <Button onClick={handleDeselectAllModules} variant="outline" disabled={isProcessing || selectedModules.size === 0}>Deseleccionar Todo</Button>
                  <Button onClick={handleExportSelectedData} disabled={isProcessing || selectedModules.size === 0} className="flex-grow sm:flex-grow-0">
                      <Download className="mr-2 h-4 w-4" /> Exportar Selección ({selectedModules.size})
                  </Button>
              </div>
            </div>

            <Separator />
            
            <div>
                <Label className="text-base font-semibold">Exportar Todos los Datos</Label>
                <p className="text-sm text-muted-foreground mb-2">Descarga un archivo JSON con absolutamente toda la información de la aplicación.</p>
                <Button onClick={handleExportAllData} disabled={isProcessing} className="w-full sm:w-auto">
                    {isProcessing ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Archive className="mr-2 h-4 w-4" />}
                    Exportar Todo
                </Button>
            </div>
        </CardContent>
      </Card>
      
      <Card className="shadow-lg">
        <CardHeader>
          <CardTitle>Importar Datos</CardTitle>
          <CardDescription>
            Acciones para restaurar datos desde un archivo. La importación puede sobrescribir datos existentes.
          </CardDescription>
        </CardHeader>
        <CardContent>
           <div>
                <p className="text-sm text-muted-foreground mb-2">Selecciona un archivo JSON (exportado previamente) para restaurar datos. La importación de un módulo solo sobrescribirá las claves de ese módulo. La importación completa reemplaza todo.</p>
                <div className="flex flex-col sm:flex-row items-start sm:items-center gap-2">
                    <Input 
                    id="import-file-input" 
                    type="file" 
                    accept=".json" 
                    onChange={handleFileChange} 
                    disabled={isProcessing}
                    className="file:border-0 file:px-4 file:py-1 file:mr-4 file:text-sm file:font-semibold file:cursor-pointer file:rounded-md file:bg-primary file:text-primary-foreground file:hover:bg-primary/80 file:flex file:items-center"
                    />
                    <AlertDialog>
                        <AlertDialogTrigger asChild>
                        <Button 
                            variant="destructive" 
                            disabled={!selectedFile || isProcessing} 
                            className="w-full sm:w-auto"
                        >
                            {isProcessing ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Upload className="mr-2 h-4 w-4" />}
                            Importar Datos
                        </Button>
                        </AlertDialogTrigger>
                        <AlertDialogContent>
                        <AlertDialogHeader>
                            <AlertDialogTitle className="flex items-center"><AlertTriangle className="h-6 w-6 text-destructive mr-2" />¡Atención!</AlertDialogTitle>
                            <AlertDialogDescription>
                            Estás a punto de importar datos desde el archivo "{selectedFile?.name || 'seleccionado'}".
                            Esta acción <strong>SOBREESCRIBIRÁ LOS DATOS</strong> correspondientes en la aplicación. Si es un respaldo completo, todos los datos serán reemplazados. Si es un módulo, solo los datos de ese módulo.
                            ¿Estás seguro de que quieres continuar?
                            </AlertDialogDescription>
                        </AlertDialogHeader>
                        <AlertDialogFooter>
                            <AlertDialogCancel disabled={isProcessing}>Cancelar</AlertDialogCancel>
                            <AlertDialogAction onClick={handleImportData} disabled={isProcessing}>
                            {isProcessing ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : "Sí, Importar y Sobrescribir"}
                            </AlertDialogAction>
                        </AlertDialogFooter>
                        </AlertDialogContent>
                    </AlertDialog>
                </div>
                 {selectedFile && <p className="text-sm text-muted-foreground mt-2">Archivo seleccionado: {selectedFile.name}</p>}
            </div>
        </CardContent>
      </Card>
      
      <Card className="shadow-lg border-destructive/50">
        <CardHeader>
          <CardTitle className="text-destructive flex items-center"><AlertTriangle className="mr-2 h-5 w-5" />Limpiar Todos los Datos</CardTitle>
          <CardDescription>
            Elimina permanentemente todos los datos de la aplicación almacenados en este navegador. Esta acción no se puede deshacer.
          </CardDescription>
        </CardHeader>
        <CardContent>
           <AlertDialog>
            <AlertDialogTrigger asChild>
              <Button 
                variant="destructive" 
                disabled={isProcessing} 
                className="w-full sm:w-auto"
              >
                {isProcessing ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Trash2 className="mr-2 h-4 w-4" />}
                Limpiar Todos los Datos de la Aplicación
              </Button>
            </AlertDialogTrigger>
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle className="flex items-center"><AlertTriangle className="h-6 w-6 text-destructive mr-2" />¡ACCIÓN IRREVERSIBLE!</AlertDialogTitle>
                <AlertDialogDescription>
                  ¿Estás absolutamente seguro de que quieres eliminar <strong>TODOS LOS DATOS</strong> de la aplicación de este navegador?
                  Serás redirigido a la página de inicio de sesión.
                </AlertDialogDescription>
              </AlertDialogHeader>
              <AlertDialogFooter>
                <AlertDialogCancel disabled={isProcessing}>Cancelar</AlertDialogCancel>
                <AlertDialogAction onClick={handleClearAllData} disabled={isProcessing} className={cn("bg-destructive hover:bg-destructive/90 text-destructive-foreground")}>
                  {isProcessing ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : "Sí, Eliminar Todo y Reiniciar"}
                </AlertDialogAction>
              </AlertDialogFooter>
            </AlertDialogContent>
          </AlertDialog>
        </CardContent>
      </Card>
    </div>
  );
}


// --- employees ---



"use client";

import { useState, useEffect, useCallback } from 'react';
import { PageHeader } from '@/components/page-header';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogClose } from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Users, PlusCircle, MoreHorizontal, Briefcase, Edit, Trash2, Calendar as CalendarIcon, Loader2 } from 'lucide-react';
import { useToast } from "@/hooks/use-toast";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Calendar } from "@/components/ui/calendar";
import { format, parseISO } from "date-fns";
import { es } from "date-fns/locale";
import { cn } from "@/lib/utils";
import { saveEmployeesData, type Employee, KEYS, loadFromLocalStorageForBranch, getActiveBranchId, availableBranches } from '@/lib/data-storage';
import { FormattedNumber } from '@/components/ui/formatted-number';

export default function EmployeesPage() {
  const { toast } = useToast();
  const [currentEmployees, setCurrentEmployees] = useState<Employee[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [activeBranchName, setActiveBranchName] = useState<string>('');

  const [isAddEmployeeDialogOpen, setIsAddEmployeeDialogOpen] = useState(false);
  const [newEmployeeName, setNewEmployeeName] = useState('');
  const [newEmployeeRole, setNewEmployeeRole] = useState('');
  const [newEmployeeContact, setNewEmployeeContact] = useState('');
  const [newEmployeeHireDate, setNewEmployeeHireDate] = useState<Date | undefined>(undefined);
  const [newEmployeeSalary, setNewEmployeeSalary] = useState('');

  const [isEditEmployeeDialogOpen, setIsEditEmployeeDialogOpen] = useState(false);
  const [editingEmployee, setEditingEmployee] = useState<Employee | null>(null);
  const [editEmployeeName, setEditEmployeeName] = useState('');
  const [editEmployeeRole, setEditEmployeeRole] = useState('');
  const [editEmployeeContact, setEditEmployeeContact] = useState('');
  const [editEmployeeHireDate, setEditEmployeeHireDate] = useState<Date | undefined>(undefined);
  const [editEmployeeSalary, setEditEmployeeSalary] = useState('');

  const [isDeleteConfirmDialogOpen, setIsDeleteConfirmDialogOpen] = useState(false);
  const [employeeToDeleteId, setEmployeeToDeleteId] = useState<string | null>(null);
  const [isAddHireDatePickerOpen, setIsAddHireDatePickerOpen] = useState(false);
  const [isEditHireDatePickerOpen, setIsEditHireDatePickerOpen] = useState(false);

  const loadPageData = useCallback(() => {
    setIsLoading(true);
    const currentActiveBranchId = getActiveBranchId();
    const branchInfo = availableBranches.find(b => b.id === currentActiveBranchId);
    setActiveBranchName(branchInfo ? branchInfo.name : 'Desconocida');

    if (currentActiveBranchId) {
      setCurrentEmployees([...loadFromLocalStorageForBranch<Employee[]>(KEYS.EMPLOYEES, currentActiveBranchId)]);
    } else {
      setCurrentEmployees([]);
      toast({ title: "Error de Sede", description: "No se pudo determinar la sede activa para cargar los empleados.", variant: "destructive" });
    }
    setNewEmployeeHireDate(new Date());
    setIsLoading(false);
  }, [toast]);

  useEffect(() => {
    loadPageData();
    const handleDataUpdate = (event: Event) => {
      const customEvent = event as CustomEvent;
      if (customEvent.detail?.key === KEYS.EMPLOYEES || customEvent.detail?.key === KEYS.ACTIVE_BRANCH_ID) {
        loadPageData();
      }
    };
    window.addEventListener('data-updated', handleDataUpdate);
    return () => {
      window.removeEventListener('data-updated', handleDataUpdate);
    };
  }, [loadPageData]);

  const resetAddForm = () => {
    setNewEmployeeName('');
    setNewEmployeeRole('');
    setNewEmployeeContact('');
    setNewEmployeeHireDate(new Date());
    setNewEmployeeSalary('');
  };

  const handleAddEmployee = () => {
    setIsSubmitting(true);
    const activeBranchId = getActiveBranchId();
    if (!activeBranchId) {
      toast({ title: "Error de Sede", description: "No se puede añadir empleado sin sede activa.", variant: "destructive" });
      setIsSubmitting(false); return;
    }
    if (!newEmployeeName || !newEmployeeRole || !newEmployeeContact || !newEmployeeHireDate || !newEmployeeSalary) {
      toast({ title: "Error", description: "Todos los campos son obligatorios.", variant: "destructive" });
      setIsSubmitting(false); return;
    }
    const salaryNum = parseFloat(newEmployeeSalary);
    if (isNaN(salaryNum) || salaryNum <= 0) {
        toast({ title: "Error", description: "El salario debe ser un número positivo.", variant: "destructive" });
        setIsSubmitting(false); return;
    }

    const newEmployee: Employee = {
      id: `EMP${Date.now().toString().slice(-4)}${Math.floor(Math.random()*100)}`,
      name: newEmployeeName,
      role: newEmployeeRole,
      contact: newEmployeeContact,
      hireDate: format(newEmployeeHireDate, "yyyy-MM-dd"),
      status: 'Activo',
      salary: salaryNum,
    };
    const branchEmployees = loadFromLocalStorageForBranch<Employee[]>(KEYS.EMPLOYEES, activeBranchId);
    const updatedEmployees = [newEmployee, ...branchEmployees];
    saveEmployeesData(activeBranchId, updatedEmployees);
    setCurrentEmployees(updatedEmployees); // Actualizar estado local para UI
    toast({ title: "Éxito", description: `Empleado añadido a sede ${activeBranchName}.` });
    setIsAddEmployeeDialogOpen(false);
    resetAddForm();
    setIsSubmitting(false);
  };

  const handleOpenEditDialog = (employee: Employee) => {
    setEditingEmployee(employee);
    setEditEmployeeName(employee.name);
    setEditEmployeeRole(employee.role);
    setEditEmployeeContact(employee.contact);
    setEditEmployeeHireDate(parseISO(employee.hireDate));
    setEditEmployeeSalary(employee.salary?.toString() || '');
    setIsEditEmployeeDialogOpen(true);
  };

  const handleUpdateEmployee = () => {
    setIsSubmitting(true);
    const activeBranchId = getActiveBranchId();
    if (!activeBranchId) {
      toast({ title: "Error de Sede", description: "No se puede actualizar empleado sin sede activa.", variant: "destructive" });
      setIsSubmitting(false); return;
    }
    if (!editingEmployee || !editEmployeeName || !editEmployeeRole || !editEmployeeContact || !editEmployeeHireDate || !editEmployeeSalary) {
      toast({ title: "Error", description: "Todos los campos son obligatorios.", variant: "destructive" });
      setIsSubmitting(false); return;
    }
    const salaryNum = parseFloat(editEmployeeSalary);
    if (isNaN(salaryNum) || salaryNum <= 0) {
        toast({ title: "Error", description: "El salario debe ser un número positivo.", variant: "destructive" });
        setIsSubmitting(false); return;
    }
    const branchEmployees = loadFromLocalStorageForBranch<Employee[]>(KEYS.EMPLOYEES, activeBranchId);
    const updatedEmployees = branchEmployees.map(e =>
      e.id === editingEmployee.id
      ? {
          ...e,
          name: editEmployeeName,
          role: editEmployeeRole,
          contact: editEmployeeContact,
          hireDate: format(editEmployeeHireDate, "yyyy-MM-dd"),
          salary: salaryNum,
        }
      : e
    );
    saveEmployeesData(activeBranchId, updatedEmployees);
    setCurrentEmployees(updatedEmployees);
    toast({ title: "Éxito", description: `Empleado actualizado en sede ${activeBranchName}.` });
    setIsEditEmployeeDialogOpen(false);
    setEditingEmployee(null);
    setIsSubmitting(false);
  };

  const handleOpenDeleteDialog = (employeeId: string) => {
    setEmployeeToDeleteId(employeeId);
    setIsDeleteConfirmDialogOpen(true);
  };

  const handleConfirmDelete = () => {
    setIsSubmitting(true);
    const activeBranchId = getActiveBranchId();
    if (!activeBranchId) {
      toast({ title: "Error de Sede", description: "No se puede eliminar empleado sin sede activa.", variant: "destructive" });
      setIsSubmitting(false); return;
    }
    if (employeeToDeleteId) {
      const branchEmployees = loadFromLocalStorageForBranch<Employee[]>(KEYS.EMPLOYEES, activeBranchId);
      const updatedEmployees = branchEmployees.filter(e => e.id !== employeeToDeleteId);
      saveEmployeesData(activeBranchId, updatedEmployees);
      setCurrentEmployees(updatedEmployees);
      toast({ title: "Éxito", description: `Empleado eliminado de sede ${activeBranchName}.` });
      setIsDeleteConfirmDialogOpen(false);
      setEmployeeToDeleteId(null);
    }
    setIsSubmitting(false);
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[calc(100vh-10rem)]">
        <Loader2 className="h-12 w-12 animate-spin text-primary" />
        <p className="ml-4 text-lg">Cargando empleados de la sede {activeBranchName}...</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <PageHeader
        title={`Gestión de Empleados (Sede: ${activeBranchName})`}
        description="Gestiona la información de tu personal, roles y asistencia para la sede activa."
        icon={Users}
        actions={
          <Button onClick={() => { resetAddForm(); setIsAddEmployeeDialogOpen(true); }} disabled={isSubmitting || isLoading}>
            <PlusCircle className="mr-2 h-4 w-4" />
            Añadir Empleado (Sede Actual)
          </Button>
        }
      />

      <Card className="shadow-lg">
        <CardHeader>
          <CardTitle>Lista de Personal (Sede: {activeBranchName})</CardTitle>
          <CardDescription>Detalles de todos los empleados de la sede activa.</CardDescription>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Nombre</TableHead>
                <TableHead>Rol</TableHead>
                <TableHead>Contacto</TableHead>
                <TableHead>Fecha de Contratación</TableHead>
                <TableHead>Salario Semanal ($)</TableHead>
                <TableHead>Estado</TableHead>
                <TableHead className="text-right">Acciones</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {currentEmployees.map((employee) => (
                <TableRow key={employee.id}>
                  <TableCell className="font-medium">{employee.name}</TableCell>
                  <TableCell>
                    <div className="flex items-center gap-2">
                      <Briefcase className="h-4 w-4 text-muted-foreground" />
                      {employee.role}
                    </div>
                  </TableCell>
                  <TableCell>{employee.contact}</TableCell>
                  <TableCell>{format(parseISO(employee.hireDate), "dd/MM/yyyy", { locale: es })}</TableCell>
                  <TableCell><FormattedNumber value={employee.salary} prefix="$" /></TableCell>
                  <TableCell>{employee.status}</TableCell>
                  <TableCell className="text-right">
                    <DropdownMenu>
                      <DropdownMenuTrigger asChild>
                        <Button variant="ghost" size="icon" disabled={isSubmitting}>
                          <MoreHorizontal className="h-4 w-4" />
                        </Button>
                      </DropdownMenuTrigger>
                      <DropdownMenuContent align="end">
                        <DropdownMenuItem onClick={() => handleOpenEditDialog(employee)} disabled={isSubmitting}>
                          <Edit className="mr-2 h-4 w-4" />
                          Editar
                        </DropdownMenuItem>
                        <DropdownMenuItem
                          onClick={() => handleOpenDeleteDialog(employee.id)}
                          className="text-destructive focus:text-destructive-foreground focus:bg-destructive"
                          disabled={isSubmitting}
                        >
                          <Trash2 className="mr-2 h-4 w-4" />
                          Eliminar
                        </DropdownMenuItem>
                      </DropdownMenuContent>
                    </DropdownMenu>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
          {currentEmployees.length === 0 && !isLoading && <p className="text-center text-muted-foreground py-8">No hay empleados registrados para la sede {activeBranchName}.</p>}
        </CardContent>
      </Card>

      {/* Add Employee Dialog */}
      <Dialog open={isAddEmployeeDialogOpen} onOpenChange={(isOpen) => {if(!isSubmitting) setIsAddEmployeeDialogOpen(isOpen)}}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Añadir Nuevo Empleado (Sede: {activeBranchName})</DialogTitle>
            <DialogDescription>
              Ingresa los detalles del nuevo miembro del personal para la sede actual.
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="space-y-1">
              <Label htmlFor="add_employee_name">Nombre Completo</Label>
              <Input id="add_employee_name" value={newEmployeeName} onChange={(e) => setNewEmployeeName(e.target.value)} placeholder="ej., Ana López" disabled={isSubmitting}/>
            </div>
            <div className="space-y-1">
              <Label htmlFor="add_role">Rol</Label>
              <Input id="add_role" value={newEmployeeRole} onChange={(e) => setNewEmployeeRole(e.target.value)} placeholder="ej., Jefa de Panadería" disabled={isSubmitting}/>
            </div>
            <div className="space-y-1">
              <Label htmlFor="add_contact">Número de Contacto</Label>
              <Input id="add_contact" type="tel" value={newEmployeeContact} onChange={(e) => setNewEmployeeContact(e.target.value)} placeholder="ej., 555-0101" disabled={isSubmitting}/>
            </div>
            <div className="space-y-1">
              <Label htmlFor="add_hire_date">Fecha de Contratación</Label>
              <Popover open={isAddHireDatePickerOpen} onOpenChange={setIsAddHireDatePickerOpen}>
                <PopoverTrigger asChild>
                  <Button id="add_hire_date" variant={"outline"} className={cn("w-full justify-start text-left font-normal", !newEmployeeHireDate && "text-muted-foreground")} disabled={isSubmitting}>
                    <CalendarIcon className="mr-2 h-4 w-4" />
                    {newEmployeeHireDate ? format(newEmployeeHireDate, "PPP", { locale: es }) : <span>Elige una fecha</span>}
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0">
                  <Calendar mode="single" selected={newEmployeeHireDate} onSelect={(date) => { setNewEmployeeHireDate(date); setIsAddHireDatePickerOpen(false); }} initialFocus locale={es} disabled={isSubmitting}/>
                </PopoverContent>
              </Popover>
            </div>
            <div className="space-y-1">
              <Label htmlFor="add_salary">Salario Semanal ($)</Label>
              <Input id="add_salary" type="number" value={newEmployeeSalary} onChange={(e) => setNewEmployeeSalary(e.target.value)} placeholder="ej., 3000" disabled={isSubmitting}/>
            </div>
          </div>
          <DialogFooter>
            <DialogClose asChild>
              <Button variant="outline" onClick={() => {if(!isSubmitting) setIsAddEmployeeDialogOpen(false)}} disabled={isSubmitting}>Cancelar</Button>
            </DialogClose>
            <Button type="button" onClick={handleAddEmployee} disabled={isSubmitting}>
                {isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <PlusCircle className="mr-2 h-4 w-4" />}
                {isSubmitting ? "Guardando..." : "Guardar Empleado"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Edit Employee Dialog */}
      <Dialog open={isEditEmployeeDialogOpen} onOpenChange={(isOpen) => {if(!isSubmitting) setIsEditEmployeeDialogOpen(isOpen)}}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Editar Empleado (Sede: {activeBranchName})</DialogTitle>
            <DialogDescription>
              Actualiza los detalles del miembro del personal para la sede actual.
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="space-y-1">
              <Label htmlFor="edit_employee_name">Nombre Completo</Label>
              <Input id="edit_employee_name" value={editEmployeeName} onChange={(e) => setEditEmployeeName(e.target.value)} disabled={isSubmitting}/>
            </div>
            <div className="space-y-1">
              <Label htmlFor="edit_role">Rol</Label>
              <Input id="edit_role" value={editEmployeeRole} onChange={(e) => setEditEmployeeRole(e.target.value)} disabled={isSubmitting}/>
            </div>
            <div className="space-y-1">
              <Label htmlFor="edit_contact">Número de Contacto</Label>
              <Input id="edit_contact" type="tel" value={editEmployeeContact} onChange={(e) => setEditEmployeeContact(e.target.value)} disabled={isSubmitting}/>
            </div>
            <div className="space-y-1">
              <Label htmlFor="edit_hire_date">Fecha de Contratación</Label>
                <Popover open={isEditHireDatePickerOpen} onOpenChange={setIsEditHireDatePickerOpen}>
                  <PopoverTrigger asChild>
                    <Button id="edit_hire_date" variant={"outline"} className={cn("w-full justify-start text-left font-normal", !editEmployeeHireDate && "text-muted-foreground")} disabled={isSubmitting}>
                      <CalendarIcon className="mr-2 h-4 w-4" />
                      {editEmployeeHireDate ? format(editEmployeeHireDate, "PPP", { locale: es }) : <span>Elige una fecha</span>}
                    </Button>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0">
                    <Calendar mode="single" selected={editEmployeeHireDate} onSelect={(date) => { setEditEmployeeHireDate(date); setIsEditHireDatePickerOpen(false); }} initialFocus locale={es} disabled={isSubmitting}/>
                  </PopoverContent>
                </Popover>
            </div>
            <div className="space-y-1">
              <Label htmlFor="edit_salary">Salario Semanal ($)</Label>
              <Input id="edit_salary" type="number" value={editEmployeeSalary} onChange={(e) => setEditEmployeeSalary(e.target.value)} disabled={isSubmitting}/>
            </div>
          </div>
          <DialogFooter>
            <DialogClose asChild>
              <Button variant="outline" onClick={() => {if(!isSubmitting){setIsEditEmployeeDialogOpen(false); setEditingEmployee(null);}}} disabled={isSubmitting}>Cancelar</Button>
            </DialogClose>
            <Button type="button" onClick={handleUpdateEmployee} disabled={isSubmitting}>
                 {isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Edit className="mr-2 h-4 w-4" />}
                {isSubmitting ? "Guardando..." : "Guardar Cambios"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Delete Confirm Dialog */}
      <Dialog open={isDeleteConfirmDialogOpen} onOpenChange={(isOpen) => {if(!isSubmitting) setIsDeleteConfirmDialogOpen(isOpen)}}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Confirmar Eliminación</DialogTitle>
            <DialogDescription>
              ¿Estás seguro de que quieres eliminar a este empleado de la sede {activeBranchName}? Esta acción no se puede deshacer.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter className="sm:justify-end">
            <DialogClose asChild>
              <Button variant="outline" onClick={() => {if(!isSubmitting){setIsDeleteConfirmDialogOpen(false); setEmployeeToDeleteId(null)}}} disabled={isSubmitting}>Cancelar</Button>
            </DialogClose>
            <Button variant="destructive" onClick={handleConfirmDelete} disabled={isSubmitting}>
                {isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Trash2 className="mr-2 h-4 w-4" />}
                {isSubmitting ? "Eliminando..." : "Eliminar Empleado"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}
    
// --- expenses ---



"use client";

import React, { useState, useEffect, useCallback } from 'react';
import { PageHeader } from '@/components/page-header';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogClose } from '@/components/ui/dialog';
import { DollarSign, PlusCircle, Edit, Trash2, MoreHorizontal, Calendar as CalendarIcon, Filter, Loader2, Settings } from 'lucide-react';
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Calendar } from "@/components/ui/calendar";
import { format, parseISO, isWithinInterval, startOfDay, endOfDay, isValid } from "date-fns";
import type { DateRange } from "react-day-picker";
import { es } from "date-fns/locale";
import { cn } from "@/lib/utils";
import { useToast } from "@/hooks/use-toast";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';
import { Badge } from '@/components/ui/badge';
import {
  loadFromLocalStorageForBranch,
  saveExpensesData,
  type Expense,
  type ExpenseFixedCategory,
  loadExchangeRate,
  saveAccountTransactionsData,
  type AccountTransaction,
  loadCompanyAccountsData,
  saveCompanyAccountsData,
  type CompanyAccountsData,
  type AccountType,
  accountTypeNames,
  type Employee,
  KEYS,
  loadExpenseFixedCategories,
  loadExpenseVariableCategories,
  getActiveBranchId,
  availableBranches,
} from '@/lib/data-storage';
import { ExpenseFormDialog } from '@/components/expenses/expense-form-dialog';
import { ManageCategoriesDialog } from '@/components/expenses/manage-categories-dialog';
import { FormattedNumber } from '@/components/ui/formatted-number';

const mainExpenseCategoriesInternal = [
  { id: 'fijo', name: 'Gasto Fijo' },
  { id: 'variable', name: 'Gasto Variable' },
];

export default function ExpensesPage() {
  const { toast } = useToast();
  const [allExpenses, setAllExpenses] = useState<Expense[]>([]);
  const [filteredExpenses, setFilteredExpenses] = useState<Expense[]>([]);
  const [exchangeRate, setExchangeRate] = useState<number>(0);
  const [employees, setEmployees] = useState<Employee[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isPageSubmitting, setIsPageSubmitting] = useState(false);
  const [activeBranchName, setActiveBranchName] = useState<string>('');

  const [isExpenseFormDialogOpen, setIsExpenseFormDialogOpen] = useState(false);
  const [expenseToEdit, setExpenseToEdit] = useState<Expense | null>(null);
  const [originalExpenseForEdit, setOriginalExpenseForEdit] = useState<Expense | null>(null);

  const [isManageCategoriesDialogOpen, setIsManageCategoriesDialogOpen] = useState(false);
  const [fixedCategoriesListFromStorage, setFixedCategoriesListFromStorage] = useState<ExpenseFixedCategory[]>([]);
  const [variableCategoriesListFromStorage, setVariableCategoriesListFromStorage] = useState<string[]>([]);

  const [isDeleteConfirmDialogOpen, setIsDeleteConfirmDialogOpen] = useState(false);
  const [expenseToDeleteId, setExpenseToDeleteId] = useState<string | null>(null);

  const [dateRangeFilter, setDateRangeFilter] = useState<DateRange | undefined>(undefined);

  const refreshExpenseCategoriesLists = useCallback(() => {
    const activeBranch = getActiveBranchId();
    if(activeBranch) {
      setFixedCategoriesListFromStorage(loadExpenseFixedCategories(activeBranch));
      setVariableCategoriesListFromStorage(loadExpenseVariableCategories(activeBranch));
    } else {
      setFixedCategoriesListFromStorage([]);
      setVariableCategoriesListFromStorage([]);
    }
  }, []);

  const loadExpensesAndRate = useCallback(() => {
    setIsLoading(true);
    const currentActiveBranchId = getActiveBranchId();
    const branchInfo = availableBranches.find(b => b.id === currentActiveBranchId);
    setActiveBranchName(branchInfo ? branchInfo.name : 'Desconocida');

    if (currentActiveBranchId) {
      const currentExpenses = loadFromLocalStorageForBranch<Expense[]>(KEYS.EXPENSES, currentActiveBranchId);
      const sortedExpenses = [...currentExpenses].sort((a, b) => {
          const dateA = a.timestamp && isValid(parseISO(a.timestamp)) ? parseISO(a.timestamp).getTime() : (a.date && isValid(parseISO(a.date)) ? parseISO(a.date).getTime() : 0);
          const dateB = b.timestamp && isValid(parseISO(b.timestamp)) ? parseISO(b.timestamp).getTime() : (b.date && isValid(parseISO(b.date)) ? parseISO(b.date).getTime() : 0);
          return dateB - dateA;
      });
      setAllExpenses(sortedExpenses);
      setFilteredExpenses(sortedExpenses); 
      setEmployees(loadFromLocalStorageForBranch<Employee[]>(KEYS.EMPLOYEES, currentActiveBranchId).sort((a,b) => a.name.localeCompare(b.name)));
    } else {
      setAllExpenses([]);
      setFilteredExpenses([]);
      setEmployees([]);
      toast({ title: "Error de Sede", description: "No se pudo determinar la sede activa para cargar los gastos.", variant: "destructive" });
    }
    const rate = loadExchangeRate();
    setExchangeRate(rate);
    refreshExpenseCategoriesLists();
    setIsLoading(false);
  }, [refreshExpenseCategoriesLists, toast]);


  useEffect(() => {
    loadExpensesAndRate();
    const handleDataUpdate = (event: Event) => {
      const customEvent = event as CustomEvent;
      if (customEvent.detail?.key === KEYS.EXPENSES || 
          customEvent.detail?.key === KEYS.ACTIVE_BRANCH_ID ||
          customEvent.detail?.key === KEYS.EXPENSE_FIXED_CATEGORIES || 
          customEvent.detail?.key === KEYS.EXPENSE_VARIABLE_CATEGORIES ||
          customEvent.detail?.key === KEYS.EXCHANGE_RATE_HISTORY
         ) {
        loadExpensesAndRate();
      }
    };
    window.addEventListener('data-updated', handleDataUpdate);
    return () => {
      window.removeEventListener('data-updated', handleDataUpdate);
    };
  }, [loadExpensesAndRate]);

  const applyFilters = useCallback(() => {
    let expensesToFilter = [...allExpenses];
    if (dateRangeFilter?.from) {
      const toDate = dateRangeFilter.to ? endOfDay(dateRangeFilter.to) : endOfDay(dateRangeFilter.from);
      expensesToFilter = expensesToFilter.filter(expense =>
        expense.date && isValid(parseISO(expense.date)) && isWithinInterval(parseISO(expense.date), { start: startOfDay(dateRangeFilter.from!), end: toDate })
      );
    }
    setFilteredExpenses(expensesToFilter);
  }, [allExpenses, dateRangeFilter]);

  useEffect(() => {
    applyFilters();
  }, [dateRangeFilter, allExpenses, applyFilters]);

  const handleApplyFilters = () => { applyFilters(); };
  const handleClearFilters = () => { setDateRangeFilter(undefined); };

  const handleOpenExpenseFormDialog = (expense?: Expense) => {
    setExpenseToEdit(expense || null);
    if (expense) {
        setOriginalExpenseForEdit(JSON.parse(JSON.stringify(expense)));
    } else {
        setOriginalExpenseForEdit(null);
    }
    setIsExpenseFormDialogOpen(true);
  };

  const handleSubmitExpense = async (
    expenseData: Omit<Expense, 'id' | 'sourceModule' | 'sourceId'>,
    isEditing: boolean,
    originalExpenseId?: string
  ) => {
    const activeBranchId = getActiveBranchId();
    if (!activeBranchId) {
      toast({ title: "Error de Sede", description: "No se pudo determinar la sede activa para registrar el gasto.", variant: "destructive" });
      return;
    }

    const { date, mainCategoryType, category, description, amount, paidTo, paymentAccountId, timestamp } = expenseData;

    if (!date || !mainCategoryType || !category || !description || !amount || !paidTo || !paymentAccountId) {
      toast({ title: "Error", description: "Todos los campos son obligatorios.", variant: "destructive" });
      return;
    }
    if (category === "Compra de Materia Prima") {
        toast({ title: "Error", description: "Gastos por 'Compra de Materia Prima' deben registrarse vía Órdenes de Compra.", variant: "destructive", duration: 7000 });
        return;
    }
    const amountNumUSD = parseFloat(amount.toString());
    if (isNaN(amountNumUSD) || amountNumUSD <= 0) {
      toast({ title: "Error", description: "El monto debe ser un número positivo.", variant: "destructive" });
      return;
    }
    
    // Usar la tasa para la fecha del gasto, no la actual
    const currentGlobalRate = loadExchangeRate(expenseData.date ? parseISO(expenseData.date) : new Date());

    if ((paymentAccountId === 'vesElectronic' || paymentAccountId === 'vesCash') && currentGlobalRate <= 0) {
        toast({ title: "Error de Tasa", description: `No hay tasa de cambio configurada para la fecha ${expenseData.date} para procesar pagos en VES.`, variant: "destructive", duration: 7000 });
        return;
    }
    
    try {
      setIsPageSubmitting(true);

      let currentAllExpenses = loadFromLocalStorageForBranch<Expense[]>(KEYS.EXPENSES, activeBranchId);
      let currentCompanyAccounts = loadCompanyAccountsData(activeBranchId);
      let currentAccountTransactions = loadFromLocalStorageForBranch<AccountTransaction[]>(KEYS.ACCOUNT_TRANSACTIONS, activeBranchId);
      const paymentAccountDetails = currentCompanyAccounts[paymentAccountId];

      if (!paymentAccountDetails) {
          toast({ title: "Error de Cuenta", description: `La cuenta de pago ${accountTypeNames[paymentAccountId]} no fue encontrada para la sede ${activeBranchName}.`, variant: "destructive" });
          setIsPageSubmitting(false); 
          return;
      }

      let transactionAmountInAccountCurrency = amountNumUSD;
      let expenseCurrencyForTx: 'USD' | 'VES' = 'USD';
      let amountInOtherCurrencyForTx: number | undefined = undefined;

      if (paymentAccountDetails.currency === 'VES') {
          transactionAmountInAccountCurrency = amountNumUSD * currentGlobalRate;
          expenseCurrencyForTx = 'VES';
          amountInOtherCurrencyForTx = amountNumUSD;
      } else {
          transactionAmountInAccountCurrency = amountNumUSD;
          expenseCurrencyForTx = 'USD';
          if (currentGlobalRate > 0) {
              amountInOtherCurrencyForTx = amountNumUSD * currentGlobalRate;
          }
      }

      if (isEditing && originalExpenseForEdit && originalExpenseId) {
          currentAllExpenses = currentAllExpenses.filter(e => e.id !== originalExpenseId);
          const originalTxIndex = currentAccountTransactions.findIndex(tx => tx.sourceId === originalExpenseId && tx.sourceModule === 'Gastos Operativos');
          if (originalTxIndex !== -1) {
              const originalTx = currentAccountTransactions[originalTxIndex];
              const originalPaymentAccId = originalExpenseForEdit.paymentAccountId!;
              const accountToRevert = currentCompanyAccounts[originalPaymentAccId];
              if (accountToRevert) {
                  accountToRevert.balance = parseFloat((accountToRevert.balance + originalTx.amount).toFixed(2)); 
              }
              currentAccountTransactions.splice(originalTxIndex, 1);
          }
      }

      const newOrUpdatedExpense: Expense = {
        id: isEditing && originalExpenseId ? originalExpenseId : `EXP${Date.now().toString().slice(-4)}${Math.floor(Math.random() * 100)}`,
        date, mainCategoryType: mainCategoryType as 'Fijo' | 'Variable', category, description, amount: amountNumUSD, paidTo,
        sourceModule: 'Gastos Operativos', paymentAccountId,
        timestamp: timestamp || new Date().toISOString(),
      };

      const accountTransactionForStorage: AccountTransaction = {
        id: `TRN-EXP-${newOrUpdatedExpense.id.slice(-5)}-${Date.now().toString().slice(-3)}`,
        date: newOrUpdatedExpense.date,
        description: `Gasto${isEditing ? ' (actualizado)' : ''}: ${newOrUpdatedExpense.description} (Pagado a: ${newOrUpdatedExpense.paidTo})`,
        type: 'egreso',
        accountId: paymentAccountId,
        amount: parseFloat(transactionAmountInAccountCurrency.toFixed(2)),
        currency: expenseCurrencyForTx,
        exchangeRateOnTransactionDate: currentGlobalRate > 0 ? currentGlobalRate : undefined,
        amountInOtherCurrency: amountInOtherCurrencyForTx ? parseFloat(amountInOtherCurrencyForTx.toFixed(2)) : undefined,
        category: `${newOrUpdatedExpense.mainCategoryType} - ${newOrUpdatedExpense.category}`,
        sourceModule: 'Gastos Operativos',
        sourceId: newOrUpdatedExpense.id,
        timestamp: newOrUpdatedExpense.timestamp,
      };

      const accountToUpdate = currentCompanyAccounts[paymentAccountId];
      if (accountToUpdate) {
          accountToUpdate.balance = parseFloat((accountToUpdate.balance - accountTransactionForStorage.amount).toFixed(2));
          accountTransactionForStorage.balanceAfterTransaction = accountToUpdate.balance;
          accountToUpdate.lastTransactionDate = new Date().toISOString();
      }

      const finalExpenses = [newOrUpdatedExpense, ...currentAllExpenses].sort((a, b) => {
          const dateA = a.timestamp && isValid(parseISO(a.timestamp)) ? parseISO(a.timestamp).getTime() : (a.date && isValid(parseISO(a.date)) ? parseISO(a.date).getTime() : 0);
          const dateB = b.timestamp && isValid(parseISO(b.timestamp)) ? parseISO(b.timestamp).getTime() : (b.date && isValid(parseISO(b.date)) ? parseISO(b.date).getTime() : 0);
          return dateB - dateA;
      });
      saveExpensesData(activeBranchId, finalExpenses);

      const finalAccountTransactions = [accountTransactionForStorage, ...currentAccountTransactions];
      saveAccountTransactionsData(activeBranchId, finalAccountTransactions);
      saveCompanyAccountsData(activeBranchId, currentCompanyAccounts);

      toast({ title: "Éxito", description: `Gasto ${isEditing ? 'actualizado' : 'registrado'} y cuenta actualizada en sede ${activeBranchName}.` });
      setIsExpenseFormDialogOpen(false);
      setExpenseToEdit(null);
      setOriginalExpenseForEdit(null);
    } catch (error) {
      console.error("Error al procesar el gasto:", error);
      toast({ title: "Error Inesperado", description: "Ocurrió un error al procesar el gasto. Inténtalo de nuevo.", variant: "destructive" });
    } finally {
      setIsPageSubmitting(false);
    }
  };


  const handleOpenDeleteConfirmation = (expense: Expense) => {
    if (expense.sourceModule === 'Compra Materia Prima') {
        toast({ title: "Información", description: "Este gasto se originó desde una Orden de Compra y debe gestionarse allí.", variant: "default" });
        return;
    }
    setExpenseToDeleteId(expense.id);
    setIsDeleteConfirmDialogOpen(true);
  };

  const handleConfirmDeleteExpense = () => {
    const activeBranchId = getActiveBranchId();
    if (!activeBranchId) {
      toast({ title: "Error de Sede", description: "No se pudo determinar la sede activa para eliminar el gasto.", variant: "destructive" });
      return;
    }
    if (!expenseToDeleteId) {
        toast({ title: "Error", description: "ID de gasto a eliminar no especificado.", variant: "destructive" });
        return;
    }

    try {
      setIsPageSubmitting(true);
      let currentAllExpenses = loadFromLocalStorageForBranch<Expense[]>(KEYS.EXPENSES, activeBranchId);
      const expenseToDeleteDetails = currentAllExpenses.find(e => e.id === expenseToDeleteId);

      if (!expenseToDeleteDetails || expenseToDeleteDetails.sourceModule === 'Compra Materia Prima') {
        toast({ title: "Error", description: "Gasto no encontrado o no se puede eliminar desde aquí.", variant: "destructive" });
        return;
      }

      const updatedExpensesList = currentAllExpenses.filter(e => e.id !== expenseToDeleteId).sort((a, b) => {
        const dateA = a.timestamp && isValid(parseISO(a.timestamp)) ? parseISO(a.timestamp).getTime() : (a.date && isValid(parseISO(a.date)) ? parseISO(a.date).getTime() : 0);
        const dateB = b.timestamp && isValid(parseISO(b.timestamp)) ? parseISO(b.timestamp).getTime() : (b.date && isValid(parseISO(b.date)) ? parseISO(b.date).getTime() : 0);
        return dateB - dateA;
      });
      saveExpensesData(activeBranchId, updatedExpensesList);

      let currentCompanyAccounts = loadCompanyAccountsData(activeBranchId);
      let currentAccountTransactions = loadFromLocalStorageForBranch<AccountTransaction[]>(KEYS.ACCOUNT_TRANSACTIONS, activeBranchId);
      const txIndexToDelete = currentAccountTransactions.findIndex(tx => tx.sourceId === expenseToDeleteId && tx.sourceModule === 'Gastos Operativos');

      if (txIndexToDelete !== -1) {
        const txToDelete = currentAccountTransactions[txIndexToDelete];
        const paymentAccIdOfDeletedTx = expenseToDeleteDetails.paymentAccountId!;
        const accountToRevert = currentCompanyAccounts[paymentAccIdOfDeletedTx];
        if (accountToRevert) {
            accountToRevert.balance = parseFloat((accountToRevert.balance + txToDelete.amount).toFixed(2)); 
            accountToRevert.lastTransactionDate = new Date().toISOString();
        }
        currentAccountTransactions.splice(txIndexToDelete, 1);
        saveAccountTransactionsData(activeBranchId, currentAccountTransactions);
        saveCompanyAccountsData(activeBranchId, currentCompanyAccounts);
      }
      toast({ title: "Éxito", description: `Gasto eliminado y cuenta ajustada en sede ${activeBranchName}.` });
    } catch (error) {
      console.error("Error al eliminar el gasto:", error);
      toast({ title: "Error Inesperado", description: "Ocurrió un error al eliminar el gasto. Inténtalo de nuevo.", variant: "destructive" });
    } finally {
      setIsPageSubmitting(false);
      setIsDeleteConfirmDialogOpen(false);
      setExpenseToDeleteId(null);
    }
  };

  const formatVesPriceLocal = (usdPrice: number) => {
    if (exchangeRate > 0 && usdPrice) {
      return `Bs. ${(usdPrice * exchangeRate).toFixed(2)}`;
    }
    return "Bs. --";
  };

  if (isLoading) {
    return (<div className="flex items-center justify-center min-h-[calc(100vh-10rem)]"><Loader2 className="h-12 w-12 animate-spin text-primary" /><p className="ml-4 text-lg">Cargando gastos de la sede {activeBranchName}...</p></div>);
  }

  return (
    <div className="space-y-6">
      <PageHeader
        title={`Registro de Gastos (Sede: ${activeBranchName})`}
        description="Lleva un registro de todos los gastos de tu panadería para la sede actual. Cada gasto se reflejará como un egreso en la cuenta seleccionada de esta sede."
        icon={DollarSign}
        actions={
          <div className="flex space-x-2">
            <Button onClick={() => setIsManageCategoriesDialogOpen(true)} variant="outline" disabled={isPageSubmitting}><Settings className="mr-2 h-4 w-4" />Gestionar Categorías (Sede: {activeBranchName})</Button>
            <Button onClick={() => handleOpenExpenseFormDialog()} disabled={isPageSubmitting}><PlusCircle className="mr-2 h-4 w-4" />Registrar Gasto (Sede Actual)</Button>
          </div>
        }
      />

      <Card className="shadow-lg">
        <CardHeader>
          <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
            <div><CardTitle>Historial de Gastos (Sede: ${activeBranchName})</CardTitle><CardDescription>Un registro detallado de todos los gastos registrados para esta sede.</CardDescription></div>
            <div className="flex flex-col sm:flex-row items-center gap-2 w-full sm:w-auto">
              <Popover><PopoverTrigger asChild><Button id="date-filter-expenses" variant={"outline"} className={cn("w-full sm:w-[260px] justify-start text-left font-normal", !dateRangeFilter && "text-muted-foreground")} disabled={isPageSubmitting || isLoading}><CalendarIcon className="mr-2 h-4 w-4" />{dateRangeFilter?.from ? (dateRangeFilter.to ? (<>{format(dateRangeFilter.from, "LLL dd, y", { locale: es })} - {format(dateRangeFilter.to, "LLL dd, y", { locale: es })}</>) : (format(dateRangeFilter.from, "LLL dd, y", { locale: es }))) : (<span>Filtrar por Fecha</span>)}</Button></PopoverTrigger><PopoverContent className="w-auto p-0" align="end"><Calendar initialFocus mode="range" defaultMonth={dateRangeFilter?.from} selected={dateRangeFilter} onSelect={setDateRangeFilter} numberOfMonths={2} locale={es} disabled={isPageSubmitting || isLoading}/></PopoverContent></Popover>
              <Button onClick={handleApplyFilters} className="w-full sm:w-auto" disabled={isPageSubmitting || isLoading}><Filter className="mr-2 h-4 w-4" /> Aplicar Filtro</Button>
              <Button onClick={handleClearFilters} variant="outline" className="w-full sm:w-auto" disabled={isPageSubmitting || isLoading}>Limpiar</Button>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          <Table><TableHeader><TableRow><TableHead>Fecha/Hora Registro</TableHead><TableHead>Tipo Gasto</TableHead><TableHead>Categoría (Detalle)</TableHead><TableHead>Descripción</TableHead><TableHead className="text-right">Monto (USD)</TableHead><TableHead className="text-right">Monto (VES)</TableHead><TableHead>Pagado A</TableHead><TableHead>Pagado Desde</TableHead><TableHead>Origen</TableHead><TableHead className="text-right">Acciones</TableHead></TableRow></TableHeader>
            <TableBody>
              {filteredExpenses.map((expense, index) => (
                <TableRow key={`${expense.id}-${index}`}>
                  <TableCell>
                    {expense.date && isValid(parseISO(expense.date)) ? format(parseISO(expense.date), "dd/MM/yy", { locale: es }) : '-'}
                    {expense.timestamp && isValid(parseISO(expense.timestamp)) && (
                        <span className="block text-xs text-muted-foreground">
                            {format(parseISO(expense.timestamp), "hh:mm a", { locale: es })}
                        </span>
                    )}
                  </TableCell>
                  <TableCell>{expense.mainCategoryType || 'N/A'}</TableCell>
                  <TableCell>{expense.category}</TableCell>
                  <TableCell className="font-medium max-w-xs truncate" title={expense.description}>{expense.description}</TableCell>
                  <TableCell className="text-right"><FormattedNumber value={expense.amount} prefix="$" /></TableCell>
                  <TableCell className="text-right"><FormattedNumber value={exchangeRate > 0 ? expense.amount * exchangeRate : undefined} prefix="Bs. " /></TableCell>
                  <TableCell>{expense.paidTo}</TableCell>
                  <TableCell>{expense.paymentAccountId ? accountTypeNames[expense.paymentAccountId] : 'N/A'}</TableCell>
                  <TableCell>{expense.sourceModule === 'Compra Materia Prima' ? (<Badge variant="secondary">Orden Compra</Badge>) : (<Badge variant="outline">Manual</Badge>)}</TableCell>
                  <TableCell className="text-right">
                    <div key={`actions-wrapper-${expense.id}-${isPageSubmitting}`}>
                      <DropdownMenu>
                        <DropdownMenuTrigger asChild>
                          <Button variant="ghost" size="icon" disabled={isPageSubmitting || expense.sourceModule === 'Compra Materia Prima'}>
                            <MoreHorizontal className="h-4 w-4" />
                          </Button>
                        </DropdownMenuTrigger>
                        <DropdownMenuContent align="end">
                          <DropdownMenuItem 
                            onClick={() => handleOpenExpenseFormDialog(expense)} 
                            disabled={isPageSubmitting || expense.sourceModule === 'Compra Materia Prima'}
                          >
                            <Edit className="mr-2 h-4 w-4" />Editar
                          </DropdownMenuItem>
                          <DropdownMenuItem 
                            onClick={() => handleOpenDeleteConfirmation(expense)} 
                            className="text-destructive focus:text-destructive-foreground focus:bg-destructive" 
                            disabled={isPageSubmitting || expense.sourceModule === 'Compra Materia Prima'}
                          >
                            <Trash2 className="mr-2 h-4 w-4" />Eliminar
                          </DropdownMenuItem>
                        </DropdownMenuContent>
                      </DropdownMenu>
                    </div>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
          {filteredExpenses.length === 0 && !isLoading && <p className="text-center text-muted-foreground py-8">{dateRangeFilter?.from ? "No hay gastos para el rango de fechas seleccionado." : "No hay gastos registrados."}</p>}
        </CardContent>
      </Card>

      <ExpenseFormDialog
        isOpen={isExpenseFormDialogOpen}
        onOpenChange={(isOpen) => {
            if (!isPageSubmitting) {
                 setIsExpenseFormDialogOpen(isOpen);
                 if (!isOpen) {
                     setExpenseToEdit(null);
                     setOriginalExpenseForEdit(null);
                 }
            }
        }}
        expenseToEdit={expenseToEdit}
        onSubmit={handleSubmitExpense}
        fixedCategories={fixedCategoriesListFromStorage}
        variableCategories={variableCategoriesListFromStorage}
        mainExpenseCategories={mainExpenseCategoriesInternal}
        accountTypeNames={accountTypeNames}
        exchangeRate={exchangeRate}
      />

      <ManageCategoriesDialog
        isOpen={isManageCategoriesDialogOpen}
        onOpenChange={setIsManageCategoriesDialogOpen}
        onCategoriesUpdated={refreshExpenseCategoriesLists}
      />

      <Dialog open={isDeleteConfirmDialogOpen} onOpenChange={(isOpen) => { if (!isPageSubmitting) setIsDeleteConfirmDialogOpen(isOpen); }}>
        <DialogContent className="sm:max-w-md"><DialogHeader><DialogTitle>Confirmar Eliminación</DialogTitle><DialogDescription>¿Estás seguro de que quieres eliminar este gasto? Esta acción no se puede deshacer y afectará el saldo de la cuenta de la sede actual.</DialogDescription></DialogHeader><DialogFooter className="sm:justify-end"><DialogClose asChild><Button variant="outline" onClick={() => { if (!isPageSubmitting) { setIsDeleteConfirmDialogOpen(false); setExpenseToDeleteId(null); }}} disabled={isPageSubmitting}>Cancelar</Button></DialogClose><Button variant="destructive" onClick={handleConfirmDeleteExpense} disabled={isPageSubmitting}>{isPageSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Trash2 className="mr-2 h-4 w-4" />}{isPageSubmitting ? "Eliminando..." : "Eliminar Gasto"}</Button></DialogFooter></DialogContent>
      </Dialog>
    </div>
  );
}

// --- goals --- 


"use client";

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { PageHeader } from '@/components/page-header';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Progress } from "@/components/ui/progress";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogClose } from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Target, PlusCircle, Edit, Trash2, MoreHorizontal, Calendar as CalendarIcon, Loader2, Filter, PackageSearch, AlertTriangle } from 'lucide-react';
import { useToast } from "@/hooks/use-toast";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Calendar } from "@/components/ui/calendar";
import { format, parseISO, isWithinInterval, startOfDay, endOfDay } from "date-fns";
import type { DateRange } from "react-day-picker";
import { es } from "date-fns/locale";
import { cn } from "@/lib/utils";
import { ScrollArea } from '@/components/ui/scroll-area';
import { 
  weeklyGoalsData as initialWeeklyGoalsData, 
  monthlyGoalsData as initialMonthlyGoalsData, 
  saveWeeklyGoalsData, 
  saveMonthlyGoalsData, 
  type ProductionGoal,
  recipesData as allRecipesFromStorage,
  calculateGoalStatus,
  calculateTotalIngredientsAndCostForGoal,
  type GoalIngredientsAndCost,
  loadExchangeRate,
} from '@/lib/data-storage';
import { FormattedNumber } from '@/components/ui/formatted-number';


export default function GoalsPage() {
  const { toast } = useToast();
  const [allWeeklyGoals, setAllWeeklyGoals] = useState<ProductionGoal[]>([]);
  const [allMonthlyGoals, setAllMonthlyGoals] = useState<ProductionGoal[]>([]);
  const [filteredWeeklyGoals, setFilteredWeeklyGoals] = useState<ProductionGoal[]>([]);
  const [filteredMonthlyGoals, setFilteredMonthlyGoals] = useState<ProductionGoal[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [exchangeRate, setExchangeRate] = useState<number>(0);

  const productOptionsFromRecipes = useMemo(() => {
    return allRecipesFromStorage
      .filter(recipe => !recipe.isIntermediate) 
      .map(recipe => ({ id: recipe.id, name: recipe.name }));
  }, []); 

  const [isSetGoalDialogOpen, setIsSetGoalDialogOpen] = useState(false);
  const [newGoalProduct, setNewGoalProduct] = useState('');
  const [newGoalTarget, setNewGoalTarget] = useState('');
  const [newGoalPeriod, setNewGoalPeriod] = useState<'weekly' | 'monthly' | ''>('');
  const [newGoalStartDate, setNewGoalStartDate] = useState<Date | undefined>(undefined);
  const [newGoalAchieved, setNewGoalAchieved] = useState('0'); 


  const [isEditGoalDialogOpen, setIsEditGoalDialogOpen] = useState(false);
  const [editingGoal, setEditingGoal] = useState<ProductionGoal | null>(null);
  const [editGoalProduct, setEditGoalProduct] = useState('');
  const [editGoalTarget, setEditGoalTarget] = useState('');
  const [editGoalPeriod, setEditGoalPeriod] = useState<'weekly' | 'monthly' | ''>('');
  const [editGoalStartDate, setEditGoalStartDate] = useState<Date | undefined>(undefined);
  const [editGoalAchieved, setEditGoalAchieved] = useState('');


  const [isDeleteConfirmDialogOpen, setIsDeleteConfirmDialogOpen] = useState(false);
  const [goalToDelete, setGoalToDelete] = useState<{ id: string; period: 'weekly' | 'monthly' } | null>(null);

  const [dateRangeFilterWeekly, setDateRangeFilterWeekly] = useState<DateRange | undefined>(undefined);
  const [dateRangeFilterMonthly, setDateRangeFilterMonthly] = useState<DateRange | undefined>(undefined);
  
  const [isDetailsDialogOpen, setIsDetailsDialogOpen] = useState(false);
  const [selectedGoalForDetails, setSelectedGoalForDetails] = useState<ProductionGoal | null>(null);
  const [goalDetailsData, setGoalDetailsData] = useState<GoalIngredientsAndCost | null>(null);
  const [isCalculatingDetails, setIsCalculatingDetails] = useState(false);
  const [isGoalDatePickerOpen, setIsGoalDatePickerOpen] = useState(false);


  const loadGoals = useCallback(() => {
    setIsLoading(true);
    const weekly = [...initialWeeklyGoalsData].sort((a,b) => (b.startDate && a.startDate) ? parseISO(b.startDate).getTime() - parseISO(a.startDate).getTime() : 0);
    const monthly = [...initialMonthlyGoalsData].sort((a,b) => (b.startDate && a.startDate) ? parseISO(b.startDate).getTime() - parseISO(a.startDate).getTime() : 0);
    setAllWeeklyGoals(weekly);
    setFilteredWeeklyGoals(weekly);
    setAllMonthlyGoals(monthly);
    setFilteredMonthlyGoals(monthly);
    setExchangeRate(loadExchangeRate());
    
    if (productOptionsFromRecipes.length > 0) {
      setNewGoalProduct(productOptionsFromRecipes[0].name);
    } else {
      setNewGoalProduct('');
    }

    setIsLoading(false);
  }, [productOptionsFromRecipes]);

  useEffect(() => {
    loadGoals();
    setNewGoalStartDate(new Date());
  }, [loadGoals]);
  
  useEffect(() => {
    if (productOptionsFromRecipes.length > 0) {
      const currentProductStillValid = productOptionsFromRecipes.some(p => p.name === newGoalProduct);
      if (!currentProductStillValid || !newGoalProduct) { 
        setNewGoalProduct(productOptionsFromRecipes[0].name);
      }
    } else {
      setNewGoalProduct('');
    }
  }, [productOptionsFromRecipes, newGoalProduct]);


  const resetAddForm = () => {
    setNewGoalProduct(productOptionsFromRecipes.length > 0 ? productOptionsFromRecipes[0].name : '');
    setNewGoalTarget('');
    setNewGoalPeriod('');
    setNewGoalStartDate(new Date());
    setNewGoalAchieved('0');
  };

  const applyFilters = useCallback((period: 'weekly' | 'monthly') => {
    if (period === 'weekly') {
      let filtered = [...allWeeklyGoals];
      if (dateRangeFilterWeekly?.from) {
        const toDate = dateRangeFilterWeekly.to ? endOfDay(dateRangeFilterWeekly.to) : endOfDay(dateRangeFilterWeekly.from);
        filtered = filtered.filter(goal => goal.startDate && isWithinInterval(parseISO(goal.startDate), { start: startOfDay(dateRangeFilterWeekly.from!), end: toDate }));
      }
      setFilteredWeeklyGoals(filtered);
    } else {
      let filtered = [...allMonthlyGoals];
      if (dateRangeFilterMonthly?.from) {
        const toDate = dateRangeFilterMonthly.to ? endOfDay(dateRangeFilterMonthly.to) : endOfDay(dateRangeFilterMonthly.from);
        filtered = filtered.filter(goal => goal.startDate && isWithinInterval(parseISO(goal.startDate), { start: startOfDay(dateRangeFilterMonthly.from!), end: toDate }));
      }
      setFilteredMonthlyGoals(filtered);
    }
  }, [allWeeklyGoals, dateRangeFilterWeekly, allMonthlyGoals, dateRangeFilterMonthly]);
  
  const handleApplyFilters = (period: 'weekly' | 'monthly') => {
    applyFilters(period);
  };
  
  const handleClearFilters = (period: 'weekly' | 'monthly') => {
    if (period === 'weekly') {
      setDateRangeFilterWeekly(undefined);
    } else {
      setDateRangeFilterMonthly(undefined);
    }
  };

  useEffect(() => {
    applyFilters('weekly');
  }, [dateRangeFilterWeekly, allWeeklyGoals, applyFilters]);

  useEffect(() => {
    applyFilters('monthly');
  }, [dateRangeFilterMonthly, allMonthlyGoals, applyFilters]);


  const handleAddGoal = () => {
    if (!newGoalProduct || !newGoalTarget || !newGoalPeriod || !newGoalStartDate) {
      toast({ title: "Error", description: "Producto, objetivo, periodo y fecha de inicio son obligatorios.", variant: "destructive" });
      return;
    }
    const targetNum = parseInt(newGoalTarget, 10);
    const achievedNum = parseInt(newGoalAchieved, 10);

    if (isNaN(targetNum) || targetNum <= 0) {
       toast({ title: "Error", description: "La cantidad objetivo debe ser un número positivo.", variant: "destructive" });
       return;
    }
    if (isNaN(achievedNum) || achievedNum < 0) {
        toast({ title: "Error", description: "Las unidades logradas deben ser un número no negativo.", variant: "destructive" });
        return;
    }
    setIsSubmitting(true);

    const newGoal: ProductionGoal = {
      id: `${newGoalPeriod.toUpperCase()}${Date.now().toString().slice(-3)}${Math.floor(Math.random()*100)}`,
      product: newGoalProduct,
      target: targetNum,
      achieved: achievedNum,
      status: calculateGoalStatus(targetNum, achievedNum),
      period: newGoalPeriod as 'weekly' | 'monthly',
      startDate: format(newGoalStartDate, "yyyy-MM-dd"),
    };

    if (newGoal.period === 'weekly') {
      const updatedGoals = [newGoal, ...allWeeklyGoals].sort((a,b) => (b.startDate && a.startDate) ? parseISO(b.startDate).getTime() - parseISO(a.startDate).getTime() : 0);
      saveWeeklyGoalsData(updatedGoals);
      setAllWeeklyGoals(updatedGoals);
    } else {
      const updatedGoals = [newGoal, ...allMonthlyGoals].sort((a,b) => (b.startDate && a.startDate) ? parseISO(b.startDate).getTime() - parseISO(a.startDate).getTime() : 0);
      saveMonthlyGoalsData(updatedGoals);
      setAllMonthlyGoals(updatedGoals);
    }
    toast({ title: "Éxito", description: "Meta de producción añadida correctamente." });
    setIsSetGoalDialogOpen(false);
    resetAddForm();
    setIsSubmitting(false);
  };

  const handleOpenEditDialog = (goal: ProductionGoal) => {
    setEditingGoal(goal);
    setEditGoalProduct(goal.product);
    setEditGoalTarget(goal.target.toString());
    setEditGoalAchieved(goal.achieved.toString());
    setEditGoalPeriod(goal.period);
    setEditGoalStartDate(goal.startDate ? parseISO(goal.startDate) : undefined);
    setIsEditGoalDialogOpen(true);
  };

  const handleUpdateGoal = () => {
    if (!editingGoal || !editGoalProduct || !editGoalTarget || !editGoalPeriod || !editGoalStartDate) {
      toast({ title: "Error", description: "Todos los campos son obligatorios.", variant: "destructive" });
      return;
    }
    const targetNum = parseInt(editGoalTarget, 10);
    const achievedNum = parseInt(editGoalAchieved, 10);

    if (isNaN(targetNum) || targetNum <= 0) {
       toast({ title: "Error", description: "La cantidad objetivo debe ser un número positivo.", variant: "destructive" });
       return;
    }
     if (isNaN(achievedNum) || achievedNum < 0) {
        toast({ title: "Error", description: "Las unidades logradas deben ser un número no negativo.", variant: "destructive" });
        return;
    }
    setIsSubmitting(true);

    const updatedGoalData: ProductionGoal = {
      ...editingGoal,
      product: editGoalProduct,
      target: targetNum,
      achieved: achievedNum,
      status: calculateGoalStatus(targetNum, achievedNum),
      period: editGoalPeriod as 'weekly' | 'monthly',
      startDate: format(editGoalStartDate, "yyyy-MM-dd"),
    };

    if (updatedGoalData.period === 'weekly') {
      const updatedGoals = allWeeklyGoals.map(g => g.id === updatedGoalData.id ? updatedGoalData : g).sort((a,b) => (b.startDate && a.startDate) ? parseISO(b.startDate).getTime() - parseISO(a.startDate).getTime() : 0);
      saveWeeklyGoalsData(updatedGoals);
      setAllWeeklyGoals(updatedGoals);
    } else {
      const updatedGoals = allMonthlyGoals.map(g => g.id === updatedGoalData.id ? updatedGoalData : g).sort((a,b) => (b.startDate && a.startDate) ? parseISO(b.startDate).getTime() - parseISO(a.startDate).getTime() : 0);
      saveMonthlyGoalsData(updatedGoals);
      setAllMonthlyGoals(updatedGoals);
    }
    toast({ title: "Éxito", description: "Meta actualizada correctamente." });
    setIsEditGoalDialogOpen(false);
    setEditingGoal(null);
    setIsSubmitting(false);
  };

  const handleOpenDeleteDialog = (goalId: string, period: 'weekly' | 'monthly') => {
    setGoalToDelete({ id: goalId, period });
    setIsDeleteConfirmDialogOpen(true);
  };

  const handleConfirmDelete = () => {
    if (!goalToDelete) return;
    setIsSubmitting(true);
      
    if (goalToDelete.period === 'weekly') {
      const updatedGoals = allWeeklyGoals.filter(g => g.id !== goalToDelete.id).sort((a,b) => (b.startDate && a.startDate) ? parseISO(b.startDate).getTime() - parseISO(a.startDate).getTime() : 0);
      saveWeeklyGoalsData(updatedGoals);
      setAllWeeklyGoals(updatedGoals);
    } else {
      const updatedGoals = allMonthlyGoals.filter(g => g.id !== goalToDelete.id).sort((a,b) => (b.startDate && a.startDate) ? parseISO(b.startDate).getTime() - parseISO(a.startDate).getTime() : 0);
      saveMonthlyGoalsData(updatedGoals);
      setAllMonthlyGoals(updatedGoals);
    }
    toast({ title: "Éxito", description: "Meta eliminada correctamente." });
    setIsDeleteConfirmDialogOpen(false);
    setGoalToDelete(null);
    setIsSubmitting(false);
  };

  const handleOpenDetailsDialog = async (goal: ProductionGoal) => {
    setSelectedGoalForDetails(goal);
    setIsCalculatingDetails(true);
    setGoalDetailsData(null);
    setIsDetailsDialogOpen(true);

    try {
      await new Promise(resolve => setTimeout(resolve, 100));
      const details = calculateTotalIngredientsAndCostForGoal(
        goal,
        allRecipesFromStorage
      );
      setGoalDetailsData(details);
    } catch (error) {
      console.error("Error calculating goal details:", error);
      toast({ title: "Error", description: "No se pudieron calcular los detalles de la meta.", variant: "destructive" });
      setIsDetailsDialogOpen(false);
    } finally {
      setIsCalculatingDetails(false);
    }
  };

  const renderGoalsTable = (goals: ProductionGoal[], periodType: 'weekly' | 'monthly') => (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>Producto</TableHead>
          <TableHead className="text-right">Objetivo</TableHead>
          <TableHead className="text-right">Logrado</TableHead>
          <TableHead className="w-[150px] sm:w-[200px]">Progreso</TableHead>
          <TableHead>Estado</TableHead>
          <TableHead>Fecha de Inicio</TableHead>
          <TableHead className="text-center">Detalles</TableHead>
          <TableHead className="text-right">Acciones</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {goals.map((goal) => (
          <TableRow key={goal.id}>
            <TableCell className="font-medium">{goal.product}</TableCell>
            <TableCell className="text-right">{goal.target}</TableCell>
            <TableCell className="text-right">{goal.achieved}</TableCell>
            <TableCell>
              <Progress value={(goal.target > 0 ? (goal.achieved / goal.target) * 100 : 0)} className="w-full h-3" />
            </TableCell>
            <TableCell>{goal.status}</TableCell>
            <TableCell>{goal.startDate ? format(parseISO(goal.startDate), "dd/MM/yyyy", { locale: es }) : '-'}</TableCell>
            <TableCell className="text-center">
              <Button
                variant="outline"
                size="sm"
                onClick={() => handleOpenDetailsDialog(goal)}
                disabled={isSubmitting || isCalculatingDetails}
                title="Ver ingredientes y costos"
                className="px-2 py-1 h-auto"
              >
                <PackageSearch className="mr-0 sm:mr-2 h-4 w-4" />
                <span className="hidden sm:inline">Detalles</span>
              </Button>
            </TableCell>
            <TableCell className="text-right">
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="ghost" size="icon" disabled={isSubmitting}>
                    <MoreHorizontal className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem onClick={() => handleOpenEditDialog(goal)} disabled={isSubmitting}>
                    <Edit className="mr-2 h-4 w-4" />
                    Editar
                  </DropdownMenuItem>
                  <DropdownMenuItem
                    onClick={() => handleOpenDeleteDialog(goal.id, periodType)}
                    className="text-destructive focus:text-destructive-foreground focus:bg-destructive"
                    disabled={isSubmitting}
                  >
                    <Trash2 className="mr-2 h-4 w-4" />
                    Eliminar
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );

  const renderFilterSection = (period: 'weekly' | 'monthly') => {
    const dateRange = period === 'weekly' ? dateRangeFilterWeekly : dateRangeFilterMonthly;
    const setDateRange = period === 'weekly' ? setDateRangeFilterWeekly : setDateRangeFilterMonthly;

    return (
        <div className="flex flex-col sm:flex-row items-center gap-2 w-full sm:w-auto mb-4">
            <Popover>
                <PopoverTrigger asChild>
                <Button
                    id={`date-filter-goals-${period}`}
                    variant={"outline"}
                    className={cn(
                    "w-full sm:w-[260px] justify-start text-left font-normal",
                    !dateRange && "text-muted-foreground"
                    )}
                    disabled={isSubmitting}
                >
                    <CalendarIcon className="mr-2 h-4 w-4" />
                    {dateRange?.from ? (
                    dateRange.to ? (
                        <>
                        {format(dateRange.from, "LLL dd, y", { locale: es })} -{" "}
                        {format(dateRange.to, "LLL dd, y", { locale: es })}
                        </>
                    ) : (
                        format(dateRange.from, "LLL dd, y", { locale: es })
                    )
                    ) : (
                    <span>Elige un rango de fechas</span>
                    )}
                </Button>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0" align="end">
                <Calendar
                    initialFocus
                    mode="range"
                    defaultMonth={dateRange?.from}
                    selected={dateRange}
                    onSelect={setDateRange}
                    numberOfMonths={2}
                    locale={es}
                />
                </PopoverContent>
            </Popover>
            <Button onClick={() => handleApplyFilters(period)} className="w-full sm:w-auto" disabled={isSubmitting}>
                <Filter className="mr-2 h-4 w-4" /> Aplicar Filtro
            </Button>
            <Button onClick={() => handleClearFilters(period)} variant="outline" className="w-full sm:w-auto" disabled={isSubmitting}>Limpiar</Button>
        </div>
    );
  };

  if (isLoading) {
    return (
        <div className="flex items-center justify-center min-h-[calc(100vh-10rem)]">
            <Loader2 className="h-12 w-12 animate-spin text-primary" />
            <p className="ml-4 text-lg">Cargando metas de producción...</p>
        </div>
    );
  }

  return (
    <div className="space-y-6">
      <PageHeader
        title="Metas de Producción"
        description="Establece, rastrea y gestiona los objetivos de producción de tu panadería. Las metas se actualizan automáticamente con los registros del módulo de Producción."
        icon={Target}
        actions={
          <Button onClick={() => { resetAddForm(); setIsSetGoalDialogOpen(true); }} disabled={isSubmitting || productOptionsFromRecipes.length === 0}>
            <PlusCircle className="mr-2 h-4 w-4" />
            Establecer Nueva Meta
          </Button>
        }
      />

      <Tabs defaultValue="weekly">
        <TabsList className="grid w-full grid-cols-2 sm:w-[400px]">
          <TabsTrigger value="weekly">Metas Semanales</TabsTrigger>
          <TabsTrigger value="monthly">Metas Mensuales</TabsTrigger>
        </TabsList>
        <TabsContent value="weekly">
          <Card className="shadow-lg">
            <CardHeader>
              <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
                <div>
                  <CardTitle>Objetivos de Producción Semanales</CardTitle>
                  <CardDescription>Monitorea tu progreso hacia las metas semanales.</CardDescription>
                </div>
              </div>
              {renderFilterSection('weekly')}
            </CardHeader>
            <CardContent>
              {renderGoalsTable(filteredWeeklyGoals, 'weekly')}
              {filteredWeeklyGoals.length === 0 && !isLoading && <p className="text-center text-muted-foreground py-8">{dateRangeFilterWeekly?.from ? "No hay metas semanales para el rango seleccionado." : "No hay metas semanales establecidas."}</p>}
            </CardContent>
          </Card>
        </TabsContent>
        <TabsContent value="monthly">
          <Card className="shadow-lg">
            <CardHeader>
               <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
                  <div>
                    <CardTitle>Objetivos de Producción Mensuales</CardTitle>
                    <CardDescription>Rastrea los logros de tus objetivos mensuales.</CardDescription>
                  </div>
                </div>
                {renderFilterSection('monthly')}
            </CardHeader>
            <CardContent>
              {renderGoalsTable(filteredMonthlyGoals, 'monthly')}
              {filteredMonthlyGoals.length === 0 && !isLoading && <p className="text-center text-muted-foreground py-8">{dateRangeFilterMonthly?.from ? "No hay metas mensuales para el rango seleccionado." : "No hay metas mensuales establecidas."}</p>}
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>

      <Dialog open={isSetGoalDialogOpen || isEditGoalDialogOpen} onOpenChange={isEditGoalDialogOpen ? (isOpen) => {if(!isSubmitting) setIsEditGoalDialogOpen(isOpen)} : (isOpen) => {if(!isSubmitting) setIsSetGoalDialogOpen(isOpen)}}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>{isEditGoalDialogOpen ? "Editar Meta de Producción" : "Establecer Nueva Meta de Producción"}</DialogTitle>
            <DialogDescription>
              {isEditGoalDialogOpen ? "Actualiza los detalles de la meta." : "Define un nuevo objetivo de producción para un producto."}
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="space-y-1">
              <Label htmlFor="product">Producto</Label>
               <Select 
                 value={isEditGoalDialogOpen ? editGoalProduct : newGoalProduct} 
                 onValueChange={(value) => {
                    if (isEditGoalDialogOpen) {
                        setEditGoalProduct(value);
                    } else {
                        setNewGoalProduct(value);
                    }
                 }}
                 disabled={isSubmitting || productOptionsFromRecipes.length === 0}
               >
                <SelectTrigger id="product">
                  <SelectValue placeholder="Selecciona producto" />
                </SelectTrigger>
                <SelectContent>
                  {productOptionsFromRecipes.length > 0 ? (
                    productOptionsFromRecipes.map(p => <SelectItem key={p.id} value={p.name}>{p.name}</SelectItem>)
                  ) : (
                    <SelectItem value="no-options" disabled>No hay recetas (productos finales) definidas</SelectItem>
                  )}
                </SelectContent>
              </Select>
              {productOptionsFromRecipes.length === 0 && (
                 <p className="text-xs text-destructive">Define recetas (que no sean intermedias) en el módulo de Recetas para poder establecer metas.</p>
              )}
            </div>
            <div className="space-y-1">
              <Label htmlFor="target_quantity">Cantidad Objetivo</Label>
              <Input id="target_quantity" type="number" placeholder="ej., 500" 
                value={isEditGoalDialogOpen ? editGoalTarget : newGoalTarget}
                onChange={(e) => isEditGoalDialogOpen ? setEditGoalTarget(e.target.value) : setNewGoalTarget(e.target.value)}
                disabled={isSubmitting}
              />
            </div>
             <div className="space-y-1">
              <Label htmlFor="achieved_quantity">Unidades Logradas</Label>
              <Input id="achieved_quantity" type="number" placeholder="ej., 50" 
                value={isEditGoalDialogOpen ? editGoalAchieved : newGoalAchieved}
                onChange={(e) => isEditGoalDialogOpen ? setEditGoalAchieved(e.target.value) : setNewGoalAchieved(e.target.value)}
                disabled={isSubmitting}
              />
            </div>
            <div className="space-y-1">
              <Label htmlFor="period">Periodo</Label>
              <Select
                value={isEditGoalDialogOpen ? editGoalPeriod : newGoalPeriod}
                onValueChange={(value) => isEditGoalDialogOpen ? setEditGoalPeriod(value as 'weekly' | 'monthly') : setNewGoalPeriod(value as 'weekly' | 'monthly')}
                disabled={isSubmitting}
              >
                <SelectTrigger id="period">
                  <SelectValue placeholder="Selecciona periodo" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="weekly">Semanal</SelectItem>
                  <SelectItem value="monthly">Mensual</SelectItem>
                </SelectContent>
              </Select>
            </div>
             <div className="space-y-1">
              <Label htmlFor="start_date">Fecha de Inicio</Label>
              <Popover open={isGoalDatePickerOpen} onOpenChange={setIsGoalDatePickerOpen}>
                <PopoverTrigger asChild>
                  <Button
                    id="start_date"
                    variant={"outline"}
                    className={cn(
                      "w-full justify-start text-left font-normal",
                      !(isEditGoalDialogOpen ? editGoalStartDate : newGoalStartDate) && "text-muted-foreground"
                    )}
                    disabled={isSubmitting}
                  >
                    <CalendarIcon className="mr-2 h-4 w-4" />
                    {(isEditGoalDialogOpen ? editGoalStartDate : newGoalStartDate) ? format((isEditGoalDialogOpen ? editGoalStartDate : newGoalStartDate)!, "PPP", { locale: es }) : <span>Elige una fecha</span>}
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0">
                  <Calendar
                    mode="single"
                    selected={isEditGoalDialogOpen ? editGoalStartDate : newGoalStartDate}
                    onSelect={(date) => {
                      if (isEditGoalDialogOpen) {
                        setEditGoalStartDate(date);
                      } else {
                        setNewGoalStartDate(date);
                      }
                      setIsGoalDatePickerOpen(false);
                    }}
                    initialFocus
                    locale={es}
                    disabled={isSubmitting}
                  />
                </PopoverContent>
              </Popover>
            </div>
          </div>
          <DialogFooter>
            <DialogClose asChild>
              <Button variant="outline" onClick={() => {
                if(!isSubmitting){
                  if (isEditGoalDialogOpen) {
                    setIsEditGoalDialogOpen(false);
                    setEditingGoal(null);
                  } else {
                    setIsSetGoalDialogOpen(false);
                    resetAddForm();
                  }
                }
              }} disabled={isSubmitting}>Cancelar</Button>
            </DialogClose>
            <Button type="button" onClick={isEditGoalDialogOpen ? handleUpdateGoal : handleAddGoal} disabled={isSubmitting || productOptionsFromRecipes.length === 0}>
              {isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : (isEditGoalDialogOpen ? <Edit className="mr-2 h-4 w-4" /> : <PlusCircle className="mr-2 h-4 w-4" />)}
              {isSubmitting ? "Guardando..." : (isEditGoalDialogOpen ? "Guardar Cambios" : "Guardar Meta")}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <Dialog open={isDeleteConfirmDialogOpen} onOpenChange={(isOpen) => {if(!isSubmitting) setIsDeleteConfirmDialogOpen(isOpen)}}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Confirmar Eliminación</DialogTitle>
            <DialogDescription>
              ¿Estás seguro de que quieres eliminar esta meta de producción? Esta acción no se puede deshacer.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter className="sm:justify-end">
            <DialogClose asChild>
              <Button variant="outline" onClick={() => {if(!isSubmitting){setIsDeleteConfirmDialogOpen(false); setGoalToDelete(null)}}} disabled={isSubmitting}>Cancelar</Button>
            </DialogClose>
            <Button variant="destructive" onClick={handleConfirmDelete} disabled={isSubmitting}>
                {isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Trash2 className="mr-2 h-4 w-4" />}
                {isSubmitting ? "Eliminando..." : "Eliminar Meta"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <Dialog open={isDetailsDialogOpen} onOpenChange={(isOpen) => { if (!isCalculatingDetails) setIsDetailsDialogOpen(isOpen); }}>
        <DialogContent className="sm:max-w-lg">
          <DialogHeader>
            <DialogTitle>Detalles para Meta: {selectedGoalForDetails?.product}</DialogTitle>
            <DialogDescription>
              Ingredientes y costos estimados para alcanzar {selectedGoalForDetails?.target} unidades.
            </DialogDescription>
          </DialogHeader>
          {isCalculatingDetails ? (
            <div className="flex items-center justify-center py-10">
              <Loader2 className="h-8 w-8 animate-spin text-primary" />
              <p className="ml-3">Calculando detalles...</p>
            </div>
          ) : goalDetailsData ? (
            <ScrollArea className="max-h-[60vh] p-1 pr-3">
              <div className="space-y-4 py-4">
                <div>
                  <h4 className="font-semibold mb-2 text-foreground">Ingredientes Requeridos Totales:</h4>
                  {goalDetailsData.ingredientsList.length > 0 ? (
                    <ul className="list-disc list-inside space-y-1 text-sm text-muted-foreground">
                      {goalDetailsData.ingredientsList.map(ing => (
                        <li key={ing.name}>{ing.name}: <FormattedNumber value={ing.quantity} decimalPlaces={3} /> {ing.unit}</li>
                      ))}
                    </ul>
                  ) : (
                    <p className="text-sm text-muted-foreground">No se pudieron determinar los ingredientes. Verifica la receta y asegúrate que no sea una preparación intermedia sin desglose, o que tenga ingredientes definidos.</p>
                  )}
                </div>
                {goalDetailsData.missingPriceInfoForMaterials.length > 0 && (
                  <div className="p-3 bg-yellow-100 dark:bg-yellow-900/30 border border-yellow-400 dark:border-yellow-700 rounded-md">
                    <div className="flex items-start">
                      <AlertTriangle className="h-5 w-5 text-yellow-600 dark:text-yellow-400 mr-2 flex-shrink-0 mt-0.5" />
                      <p className="text-xs text-yellow-700 dark:text-yellow-300">
                        <strong>Atención:</strong> No se encontró información de precios para los siguientes materiales: {goalDetailsData.missingPriceInfoForMaterials.join(", ")}. El costo estimado podría ser impreciso.
                      </p>
                    </div>
                  </div>
                )}
                <div>
                  <h4 className="font-semibold mb-1 text-foreground">Costo Total Estimado (USD):</h4>
                  <p className="text-base text-primary">
                    <FormattedNumber value={goalDetailsData.totalCostMinUSD} prefix="$" /> - <FormattedNumber value={goalDetailsData.totalCostMaxUSD} prefix="$" />
                  </p>
                </div>
                <div>
                  <h4 className="font-semibold mb-1 text-foreground">Costo Total Estimado (VES):</h4>
                  <p className="text-base text-muted-foreground">
                    <FormattedNumber value={exchangeRate > 0 ? goalDetailsData.totalCostMinUSD * exchangeRate : undefined} prefix="Bs. " /> - <FormattedNumber value={exchangeRate > 0 ? goalDetailsData.totalCostMaxUSD * exchangeRate : undefined} prefix="Bs. " />
                  </p>
                </div>
              </div>
            </ScrollArea>
          ) : (
            <p className="text-center text-muted-foreground py-10">No se pudieron cargar los detalles de la meta.</p>
          )}
          <DialogFooter>
            <DialogClose asChild>
              <Button variant="outline" disabled={isCalculatingDetails}>Cerrar</Button>
            </DialogClose>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}

// --- inventory ---


"use client";

import React, { useState, useEffect, useCallback } from 'react';
import { PageHeader } from '@/components/page-header';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogClose } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Package, Search, Loader2, Trash2, PlusCircle } from 'lucide-react';
import Image from 'next/image';
import { useToast } from "@/hooks/use-toast";
import { 
  loadAllProductsFromAllBranches, 
  saveProductsDataForBranch, 
  type Product, 
  loadExchangeRate,
  KEYS,
  loadProductsForBranch
} from '@/lib/data-storage';
import { format, parseISO } from 'date-fns';
import { es } from 'date-fns/locale';
import { FormattedNumber } from '@/components/ui/formatted-number';

export default function StockProduccionPage() {
  const { toast } = useToast();
  const [productsData, setProductsData] = useState<Product[]>([]);
  const [filteredProducts, setFilteredProducts] = useState<Product[]>([]);
  const [searchTerm, setSearchTerm] = useState('');
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [exchangeRate, setExchangeRate] = useState<number>(0);

  const [isDeleteConfirmOpen, setIsDeleteConfirmOpen] = useState(false);
  const [productToDeleteId, setProductToDeleteId] = useState<string | null>(null);

  const [isAdjustDialogOpen, setIsAdjustDialogOpen] = useState(false);
  const [adjustmentType, setAdjustmentType] = useState<'add' | 'subtract'>('add');
  const [productToAdjust, setProductToAdjust] = useState<string>('');
  const [adjustmentQuantity, setAdjustmentQuantity] = useState('');

  const loadProducts = useCallback(() => {
    setIsLoading(true);
    const currentProducts = loadAllProductsFromAllBranches().sort((a, b) => a.name.localeCompare(b.name));
    setProductsData(currentProducts); 
    setFilteredProducts(currentProducts);
    const rate = loadExchangeRate();
    setExchangeRate(rate);
    setIsLoading(false);
  }, []);

  useEffect(() => {
    loadProducts();
    
    const handleDataUpdate = (event: Event) => {
      const customEvent = event as CustomEvent;
      if (customEvent.detail?.key === KEYS.PRODUCTS) {
        loadProducts();
      }
    };

    window.addEventListener('data-updated', handleDataUpdate);
    return () => {
      window.removeEventListener('data-updated', handleDataUpdate);
    };
  }, [loadProducts]);
  
  useEffect(() => {
    if (isAdjustDialogOpen && productsData.length > 0 && !productToAdjust) {
        setProductToAdjust(productsData[0].id);
    }
  }, [isAdjustDialogOpen, productsData, productToAdjust]);


  useEffect(() => {
    const lowercasedFilter = searchTerm.toLowerCase();
    const filtered = productsData.filter(item =>
      item.name.toLowerCase().includes(lowercasedFilter) ||
      item.category.toLowerCase().includes(lowercasedFilter) ||
      item.sourceBranchName?.toLowerCase().includes(lowercasedFilter)
    );
    setFilteredProducts(filtered);
  }, [searchTerm, productsData]);

  const handleOpenDeleteDialog = (productId: string) => {
    setProductToDeleteId(productId);
    setIsDeleteConfirmOpen(true);
  };
  
  const resetAdjustForm = () => {
    setAdjustmentType('add');
    setProductToAdjust(productsData.length > 0 ? productsData[0].id : '');
    setAdjustmentQuantity('');
  };


  const handleConfirmDelete = () => {
    if (!productToDeleteId) return;
    setIsSubmitting(true);

    const productToDelete = productsData.find(p => p.id === productToDeleteId);
    if (!productToDelete || !productToDelete.sourceBranchId) {
        toast({
            title: "Error",
            description: "No se pudo encontrar el producto o su sede de origen para eliminarlo.",
            variant: "destructive",
        });
        setIsSubmitting(false);
        setIsDeleteConfirmOpen(false);
        return;
    }

    const branchId = productToDelete.sourceBranchId;
    const productsForBranch = loadProductsForBranch(branchId);
    const updatedBranchProducts = productsForBranch.filter(p => p.id !== productToDeleteId);
    
    saveProductsDataForBranch(branchId, updatedBranchProducts); 

    toast({
      title: "Producto Eliminado",
      description: `El producto "${productToDelete.name}" ha sido eliminado del stock de la sede ${productToDelete.sourceBranchName}.`,
    });

    setIsDeleteConfirmOpen(false);
    setProductToDeleteId(null);
    setIsSubmitting(false);
  };
  
  const handleSaveAdjustment = () => {
    if (!productToAdjust || !adjustmentQuantity) {
      toast({ title: "Error", description: "Producto y cantidad son obligatorios.", variant: "destructive" });
      return;
    }
    const quantityNum = parseInt(adjustmentQuantity, 10);
    if (isNaN(quantityNum) || quantityNum <= 0) {
      toast({ title: "Error", description: "La cantidad debe ser un número entero positivo.", variant: "destructive" });
      return;
    }

    setIsSubmitting(true);
    
    const productInfo = productsData.find(p => p.id === productToAdjust);
    if (!productInfo || !productInfo.sourceBranchId) {
        toast({ title: "Error", description: "No se pudo encontrar el producto o su sede de origen.", variant: "destructive" });
        setIsSubmitting(false);
        return;
    }

    const branchId = productInfo.sourceBranchId;
    let branchProducts = loadProductsForBranch(branchId);
    const productIndex = branchProducts.findIndex(p => p.id === productToAdjust);

    if (productIndex === -1) {
      toast({ title: "Error de consistencia", description: "El producto no se encontró en los datos de su propia sede. Por favor, recarga.", variant: "destructive" });
      setIsSubmitting(false);
      return;
    }

    if (adjustmentType === 'subtract' && branchProducts[productIndex].stock < quantityNum) {
      toast({ title: "Error de Stock", description: `No se puede restar ${quantityNum}. Stock actual: ${branchProducts[productIndex].stock}.`, variant: "destructive" });
      setIsSubmitting(false);
      return;
    }

    if (adjustmentType === 'add') {
      branchProducts[productIndex].stock += quantityNum;
    } else {
      branchProducts[productIndex].stock -= quantityNum;
    }
    
    branchProducts[productIndex].lastUpdated = new Date().toISOString().split('T')[0];
    saveProductsDataForBranch(branchId, branchProducts);

    toast({ title: "Éxito", description: `Stock de "${productInfo.name}" ajustado en la sede ${productInfo.sourceBranchName}.` });

    setIsAdjustDialogOpen(false);
    resetAdjustForm();
    setIsSubmitting(false);
  };


  if (isLoading) { 
    return (
      <div className="flex items-center justify-center min-h-[calc(100vh-10rem)]">
        <Loader2 className="h-12 w-12 animate-spin text-primary" />
        <p className="ml-4 text-lg">Cargando stock de producción...</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <PageHeader
        title="Stock de Producción (Global)"
        description="Rastrea los niveles de stock de tus productos terminados de todas las sedes. El stock se actualiza desde el módulo de Producción y se deduce en el módulo de Ventas."
        icon={Package}
        actions={
          <Button onClick={() => { resetAdjustForm(); setIsAdjustDialogOpen(true); }} disabled={isSubmitting}>
            <PlusCircle className="mr-2 h-4 w-4" />
            Ajustar Stock
          </Button>
        }
      />

      <Card className="shadow-lg">
        <CardHeader>
          <div className="flex flex-col sm:flex-row items-center justify-between gap-4">
            <div>
              <CardTitle>Stock de Todos los Productos (Global)</CardTitle>
              <CardDescription>Resumen de todos los productos en tu stock de producción de todas las sedes.</CardDescription>
            </div>
            <div className="flex items-center gap-2 w-full sm:w-auto">
              <div className="relative flex-1 sm:flex-initial">
                <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
                <Input
                  type="search"
                  placeholder="Buscar productos o sedes..."
                  className="pl-8 sm:w-[300px] md:w-[200px] lg:w-[300px]"
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                />
              </div>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead className="w-[80px]">Imagen</TableHead>
                <TableHead>Nombre del Producto</TableHead>
                <TableHead>Sede</TableHead>
                <TableHead>Categoría</TableHead>
                <TableHead className="text-right">Stock</TableHead>
                <TableHead className="text-right">Valor Total Stock (USD)</TableHead>
                <TableHead className="text-right">Valor Total Stock (VES)</TableHead>
                <TableHead>Última Actualización</TableHead>
                <TableHead className="text-right">Acciones</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {filteredProducts.map((product) => {
                const totalStockValueUSD = product.stock * product.unitPrice;
                return (
                  <TableRow key={`${product.id}-${product.sourceBranchId}`}>
                    <TableCell>
                      <Image src={product.image || "https://placehold.co/40x40.png"} alt={product.name} width={40} height={40} className="rounded-md object-cover" data-ai-hint={product.aiHint || 'producto panaderia'}/>
                    </TableCell>
                    <TableCell className="font-medium">{product.name}</TableCell>
                    <TableCell>{product.sourceBranchName || 'N/A'}</TableCell>
                    <TableCell>{product.category}</TableCell>
                    <TableCell className="text-right">{product.stock}</TableCell>
                    <TableCell className="text-right">
                      <FormattedNumber value={totalStockValueUSD} prefix="$" />
                    </TableCell>
                    <TableCell className="text-right">
                       <FormattedNumber value={exchangeRate > 0 ? totalStockValueUSD * exchangeRate : undefined} prefix="Bs. " />
                    </TableCell>
                    <TableCell>{product.lastUpdated ? format(parseISO(product.lastUpdated), "dd/MM/yyyy", { locale: es }) : '-'}</TableCell>
                    <TableCell className="text-right">
                      <Button
                          variant="ghost"
                          size="icon"
                          onClick={() => handleOpenDeleteDialog(product.id)}
                          disabled={isSubmitting}
                          title={`Eliminar ${product.name} de ${product.sourceBranchName}`}
                          className="text-destructive hover:bg-destructive/10"
                      >
                          <Trash2 className="h-4 w-4" />
                      </Button>
                    </TableCell>
                  </TableRow>
                );
              })}
            </TableBody>
          </Table>
           {filteredProducts.length === 0 && !isLoading && (
            <p className="text-center text-muted-foreground py-8">No se encontraron productos en stock.</p>
          )}
        </CardContent>
      </Card>

      <Dialog open={isAdjustDialogOpen} onOpenChange={(isOpen) => { if (!isSubmitting) setIsAdjustDialogOpen(isOpen); }}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Ajuste Manual de Stock de Producción</DialogTitle>
            <DialogDescription>Añade o resta cantidad a un producto terminado en su sede de origen.</DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="space-y-1">
              <Label htmlFor="adjustment_type_prod">Tipo de Ajuste</Label>
              <Select value={adjustmentType} onValueChange={(v) => setAdjustmentType(v as 'add' | 'subtract')} disabled={isSubmitting}>
                <SelectTrigger id="adjustment_type_prod"><SelectValue/></SelectTrigger>
                <SelectContent>
                  <SelectItem value="add">Añadir al Stock</SelectItem>
                  <SelectItem value="subtract">Restar del Stock</SelectItem>
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-1">
              <Label htmlFor="product_to_adjust">Producto</Label>
              <Select value={productToAdjust} onValueChange={setProductToAdjust} disabled={isSubmitting || productsData.length === 0}>
                <SelectTrigger id="product_to_adjust"><SelectValue placeholder="Selecciona producto..."/></SelectTrigger>
                <SelectContent>
                  {productsData.map(prod => (
                    <SelectItem key={prod.id} value={prod.id}>
                      {prod.name} ({prod.sourceBranchName} - Stock: {prod.stock})
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-1">
                <Label htmlFor="adjustment_quantity_prod">Cantidad a {adjustmentType === 'add' ? 'Añadir' : 'Restar'}</Label>
                <Input 
                    id="adjustment_quantity_prod" 
                    type="number" 
                    value={adjustmentQuantity} 
                    onChange={(e) => setAdjustmentQuantity(e.target.value)} 
                    placeholder="ej., 10" 
                    disabled={isSubmitting}
                />
            </div>
          </div>
          <DialogFooter>
            <DialogClose asChild><Button variant="outline" disabled={isSubmitting}>Cancelar</Button></DialogClose>
            <Button type="button" onClick={handleSaveAdjustment} disabled={isSubmitting}>
              {isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin"/> : <PlusCircle className="mr-2 h-4 w-4" />}
              {isSubmitting ? "Guardando..." : "Guardar Ajuste"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <Dialog open={isDeleteConfirmOpen} onOpenChange={(isOpen) => { if (!isSubmitting) setIsDeleteConfirmOpen(isOpen); }}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Confirmar Eliminación</DialogTitle>
            <DialogDescription>
              ¿Estás seguro de que quieres eliminar el producto "{productsData.find(p => p.id === productToDeleteId)?.name || ''}" del stock de su sede? Esta acción no se puede deshacer.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter className="sm:justify-end">
            <DialogClose asChild>
              <Button variant="outline" onClick={() => {if(!isSubmitting){setIsDeleteConfirmOpen(false); setProductToDeleteId(null)}}} disabled={isSubmitting}>
                Cancelar
              </Button>
            </DialogClose>
            <Button variant="destructive" onClick={handleConfirmDelete} disabled={isSubmitting}>
                {isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Trash2 className="mr-2 h-4 w-4" />}
                {isSubmitting ? "Eliminando..." : "Eliminar Producto"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}

// --- inventory-transfers ---


"use client";

import React, { useState, useEffect, useCallback } from 'react';
import { PageHeader } from '@/components/page-header';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogClose } from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Textarea } from '@/components/ui/textarea';
import { Popover, PopoverTrigger, PopoverContent } from '@/components/ui/popover';
import { Calendar } from "@/components/ui/calendar";
import { ArrowRightLeft, PlusCircle, Loader2, Trash2, AlertTriangle, Edit, MoreHorizontal } from 'lucide-react';
import { Calendar as CalendarIcon } from 'lucide-react';
import { useToast } from "@/hooks/use-toast";
import { format, parseISO } from 'date-fns';
import { es } from 'date-fns/locale';
import { cn } from '@/lib/utils';
import { DropdownMenu, DropdownMenuTrigger, DropdownMenuContent, DropdownMenuItem } from '@/components/ui/dropdown-menu';
import {
  availableBranches,
  type Branch,
  type RawMaterialInventoryItem,
  type InventoryTransfer,
  loadRawMaterialInventoryData,
  saveRawMaterialInventoryData,
  inventoryTransfersData as initialInventoryTransfersData,
  saveInventoryTransfersData,
  commonUnitOptions,
  convertMaterialToBaseUnit,
  normalizeUnit,
} from '@/lib/data-storage';
import { FormattedNumber } from '@/components/ui/formatted-number';

interface MaterialOption {
  name: string;
  unit: string;
  availableQuantity: number;
}

interface DebtSummaryItem {
  debtorBranchId: string;
  debtorBranchName: string;
  creditorBranchId: string;
  creditorBranchName: string;
  materialName: string;
  quantityOwed: number;
  unit: string;
}


export default function InventoryTransfersPage() {
  const { toast } = useToast();
  const [transfers, setTransfers] = useState<InventoryTransfer[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Estados para el diálogo de Registrar Transferencia
  const [isRegisterTransferDialogOpen, setIsRegisterTransferDialogOpen] = useState(false);
  const [fromBranchId, setFromBranchId] = useState<string>('');
  const [toBranchId, setToBranchId] = useState<string>('');
  const [materialName, setMaterialName] = useState<string>('');
  const [quantity, setQuantity] = useState<string>('');
  const [unit, setUnit] = useState<string>('');
  const [transferDate, setTransferDate] = useState<Date | undefined>(new Date());
  const [notes, setNotes] = useState<string>('');

  const [availableMaterialsFromOrigin, setAvailableMaterialsFromOrigin] = useState<MaterialOption[]>([]);

  // Estados para el diálogo de Editar Transferencia
  const [isEditTransferDialogOpen, setIsEditTransferDialogOpen] = useState(false);
  const [editingTransfer, setEditingTransfer] = useState<InventoryTransfer | null>(null);
  const [originalTransferForEdit, setOriginalTransferForEdit] = useState<InventoryTransfer | null>(null);
  const [editFromBranchId, setEditFromBranchId] = useState<string>('');
  const [editToBranchId, setEditToBranchId] = useState<string>('');
  const [editMaterialName, setEditMaterialName] = useState<string>('');
  const [editQuantity, setEditQuantity] = useState<string>('');
  const [editUnit, setEditUnit] = useState<string>('');
  const [editTransferDate, setEditTransferDate] = useState<Date | undefined>(undefined);
  const [editNotes, setEditNotes] = useState<string>('');
  const [availableMaterialsFromEditOrigin, setAvailableMaterialsFromEditOrigin] = useState<MaterialOption[]>([]);


  const [isDeleteConfirmOpen, setIsDeleteConfirmOpen] = useState(false);
  const [transferToDeleteId, setTransferToDeleteId] = useState<string | null>(null);

  const [debtSummary, setDebtSummary] = useState<DebtSummaryItem[]>([]);
  const [isTransferDatePickerOpen, setIsTransferDatePickerOpen] = useState(false);
  const [isEditTransferDatePickerOpen, setIsEditTransferDatePickerOpen] = useState(false);

  const calculateDebtSummary = useCallback((currentTransfers: InventoryTransfer[]): DebtSummaryItem[] => {
    const netTransfers: { [key: string]: number } = {};

    currentTransfers.forEach(transfer => {
      const key = `${transfer.fromBranchId}-${transfer.toBranchId}-${transfer.materialName}-${transfer.unit}`;
      netTransfers[key] = (netTransfers[key] || 0) + transfer.quantity;
    });

    const summary: DebtSummaryItem[] = [];
    const processedPairs = new Set<string>();

    availableBranches.forEach(branchA => {
      availableBranches.forEach(branchB => {
        if (branchA.id === branchB.id) return;
        const pairKey1 = `${branchA.id}-${branchB.id}`;
        const pairKey2 = `${branchB.id}-${branchA.id}`;
        if (processedPairs.has(pairKey1) || processedPairs.has(pairKey2)) return;

        const materialsTransferred: { [materialKey: string]: { name: string, unit: string, net: number } } = {};
        Object.keys(netTransfers).forEach(key => {
          const [from, to, matName, matUnit] = key.split('-');
          const quantityTransferred = netTransfers[key];
          const materialKey = `${matName}-${matUnit}`;
          if (from === branchA.id && to === branchB.id) {
            materialsTransferred[materialKey] = materialsTransferred[materialKey] || { name: matName, unit: matUnit, net: 0 };
            materialsTransferred[materialKey].net += quantityTransferred;
          } else if (from === branchB.id && to === branchA.id) {
            materialsTransferred[materialKey] = materialsTransferred[materialKey] || { name: matName, unit: matUnit, net: 0 };
            materialsTransferred[materialKey].net -= quantityTransferred;
          }
        });

        Object.values(materialsTransferred).forEach(materialData => {
          if (materialData.net > 0.0001) {
            summary.push({
              debtorBranchId: branchB.id, debtorBranchName: branchB.name,
              creditorBranchId: branchA.id, creditorBranchName: branchA.name,
              materialName: materialData.name, quantityOwed: materialData.net, unit: materialData.unit,
            });
          } else if (materialData.net < -0.0001) {
            summary.push({
              debtorBranchId: branchA.id, debtorBranchName: branchA.name,
              creditorBranchId: branchB.id, creditorBranchName: branchB.name,
              materialName: materialData.name, quantityOwed: -materialData.net, unit: materialData.unit,
            });
          }
        });
        processedPairs.add(pairKey1); processedPairs.add(pairKey2);
      });
    });
    return summary.sort((a,b) => a.debtorBranchName.localeCompare(b.debtorBranchName) || a.creditorBranchName.localeCompare(b.creditorBranchName) || a.materialName.localeCompare(b.materialName));
  }, []);


  const loadTransfersAndSummary = useCallback(() => {
    setIsLoading(true);
    const sortedTransfers = [...initialInventoryTransfersData].sort((a, b) => parseISO(b.date).getTime() - parseISO(a.date).getTime());
    setTransfers(sortedTransfers);
    setDebtSummary(calculateDebtSummary(sortedTransfers));

    if (availableBranches.length > 0) {
      if (!fromBranchId) setFromBranchId(availableBranches[0].id);
      if (!toBranchId) {
        const initialFrom = fromBranchId || availableBranches[0].id;
        if (availableBranches.length > 1) {
          const secondBranch = availableBranches.find(b => b.id !== initialFrom);
          setToBranchId(secondBranch ? secondBranch.id : '');
        } else {
          setToBranchId('');
        }
      }
    }
    setIsLoading(false);
  }, [fromBranchId, toBranchId, calculateDebtSummary]);

  useEffect(() => {
    loadTransfersAndSummary();
  }, [loadTransfersAndSummary]);

  const updateAvailableMaterials = useCallback((branchId: string, forEditDialog: boolean = false) => {
    if (branchId) {
      const inventory = loadRawMaterialInventoryData(branchId);
      const materialOptions = inventory
        .filter(item => item.quantity > 0.0001)
        .map(item => ({
          name: item.name,
          unit: item.unit,
          availableQuantity: item.quantity,
        }))
        .sort((a, b) => a.name.localeCompare(b.name));

      if (forEditDialog) {
        setAvailableMaterialsFromEditOrigin(materialOptions);
        const currentSelectedMat = materialOptions.find(m => m.name === editMaterialName);
        if (!currentSelectedMat && materialOptions.length > 0) {
            setEditMaterialName(materialOptions[0].name);
            setEditUnit(materialOptions[0].unit);
        } else if (!currentSelectedMat) {
            setEditMaterialName('');
            setEditUnit('');
        }
      } else {
        setAvailableMaterialsFromOrigin(materialOptions);
        const currentSelectedMat = materialOptions.find(m => m.name === materialName);
         if (!currentSelectedMat && materialOptions.length > 0) {
            setMaterialName(materialOptions[0].name);
            setUnit(materialOptions[0].unit);
        } else if (!currentSelectedMat) {
            setMaterialName('');
            setUnit('');
        }
      }
    } else {
      if (forEditDialog) {
        setAvailableMaterialsFromEditOrigin([]);
        setEditMaterialName('');
        setEditUnit('');
      } else {
        setAvailableMaterialsFromOrigin([]);
        setMaterialName('');
        setUnit('');
      }
    }
  }, [materialName, editMaterialName]); // Dependencias para cada contexto

  useEffect(() => {
    if(fromBranchId) {
      updateAvailableMaterials(fromBranchId, false);
    }
  }, [fromBranchId, updateAvailableMaterials]);

  useEffect(() => {
    if(editFromBranchId) {
      updateAvailableMaterials(editFromBranchId, true);
    }
  }, [editFromBranchId, updateAvailableMaterials]);


  const resetDialogForm = () => {
    let initialFrom = ''; let initialTo = '';
    if (availableBranches.length > 0) {
      initialFrom = availableBranches[0].id;
      if (availableBranches.length > 1) {
        const secondBranch = availableBranches.find(b => b.id !== initialFrom);
        initialTo = secondBranch ? secondBranch.id : '';
      } else { initialTo = ''; }
    }
    setFromBranchId(initialFrom); setToBranchId(initialTo);
    if(initialFrom) updateAvailableMaterials(initialFrom, false);
    else setAvailableMaterialsFromOrigin([]);
    setQuantity(''); setTransferDate(new Date()); setNotes('');
  };

  const handleFromBranchChange = (newFromId: string, forEdit: boolean = false) => {
    if (forEdit) {
        setEditFromBranchId(newFromId);
        if (newFromId === editToBranchId && availableBranches.length > 1) {
            const otherBranch = availableBranches.find(b => b.id !== newFromId);
            if (otherBranch) setEditToBranchId(otherBranch.id);
        }
    } else {
        setFromBranchId(newFromId);
        if (newFromId === toBranchId && availableBranches.length > 1) {
            const otherBranch = availableBranches.find(b => b.id !== newFromId);
            if (otherBranch) setToBranchId(otherBranch.id);
        }
    }
  };

  const handleToBranchChange = (newToId: string, forEdit: boolean = false) => {
    if (forEdit) {
        setEditToBranchId(newToId);
        if (newToId === editFromBranchId && availableBranches.length > 1) {
            const otherBranch = availableBranches.find(b => b.id !== newToId);
            if (otherBranch) setEditFromBranchId(otherBranch.id);
        }
    } else {
        setToBranchId(newToId);
        if (newToId === fromBranchId && availableBranches.length > 1) {
            const otherBranch = availableBranches.find(b => b.id !== newToId);
            if (otherBranch) setFromBranchId(otherBranch.id);
        }
    }
  };


  const handleRegisterTransfer = () => {
    if (!fromBranchId || !toBranchId || !materialName || !quantity || !unit || !transferDate) {
      toast({ title: "Error", description: "Todos los campos marcados con * son obligatorios.", variant: "destructive" }); return;
    }
    if (fromBranchId === toBranchId) {
      toast({ title: "Error", description: "La sede de origen y destino no pueden ser la misma.", variant: "destructive" }); return;
    }
    const transferQtyNum = parseFloat(quantity);
    if (isNaN(transferQtyNum) || transferQtyNum <= 0) {
      toast({ title: "Error", description: "La cantidad debe ser un número positivo.", variant: "destructive" }); return;
    }
    setIsSubmitting(true);
    const originInventory = loadRawMaterialInventoryData(fromBranchId);
    const { quantity: transferQtyInBaseUnit, unit: materialBaseUnit } = convertMaterialToBaseUnit(transferQtyNum, unit, materialName);
    const materialInOrigin = originInventory.find(item => item.name.toLowerCase() === materialName.toLowerCase() && normalizeUnit(item.unit) === normalizeUnit(materialBaseUnit));
    if (!materialInOrigin || materialInOrigin.quantity < transferQtyInBaseUnit) {
      toast({ title: "Error de Stock", description: `Stock insuficiente de ${materialName} (${materialInOrigin?.quantity.toFixed(3)} ${materialBaseUnit} disp.) en origen.`, variant: "destructive", duration: 7000 });
      setIsSubmitting(false); return;
    }
    const updatedOriginInventory = originInventory.map(item => item.name.toLowerCase() === materialName.toLowerCase() && normalizeUnit(item.unit) === normalizeUnit(materialBaseUnit) ? { ...item, quantity: item.quantity - transferQtyInBaseUnit } : item).filter(item => item.quantity > 0.0001);
    saveRawMaterialInventoryData(fromBranchId, updatedOriginInventory);
    let destinationInventory = loadRawMaterialInventoryData(toBranchId);
    const materialInDestinationIndex = destinationInventory.findIndex(item => item.name.toLowerCase() === materialName.toLowerCase() && normalizeUnit(item.unit) === normalizeUnit(materialBaseUnit));
    if (materialInDestinationIndex !== -1) destinationInventory[materialInDestinationIndex].quantity += transferQtyInBaseUnit;
    else destinationInventory.push({ name: materialName, quantity: transferQtyInBaseUnit, unit: materialBaseUnit });
    saveRawMaterialInventoryData(toBranchId, destinationInventory);
    const fromBranch = availableBranches.find(b => b.id === fromBranchId);
    const toBranch = availableBranches.find(b => b.id === toBranchId);
    const newTransfer: InventoryTransfer = {
      id: `TRNFR-${Date.now().toString().slice(-5)}`, date: format(transferDate, "yyyy-MM-dd"),
      fromBranchId, fromBranchName: fromBranch?.name || 'Desconocida',
      toBranchId, toBranchName: toBranch?.name || 'Desconocida',
      materialName, quantity: transferQtyInBaseUnit, unit: materialBaseUnit, notes: notes.trim(),
      timestamp: new Date().toISOString(), // Added timestamp
    };
    const updatedTransfers = [newTransfer, ...transfers].sort((a, b) => parseISO(b.date).getTime() - parseISO(a.date).getTime());
    saveInventoryTransfersData(updatedTransfers);
    setTransfers(updatedTransfers); setDebtSummary(calculateDebtSummary(updatedTransfers));
    updateAvailableMaterials(fromBranchId, false);
    toast({ title: "Transferencia Registrada", description: `Se transfirieron ${transferQtyNum} ${unit} de ${materialName}.` });
    setIsRegisterTransferDialogOpen(false); resetDialogForm(); setIsSubmitting(false);
  };

  const handleOpenEditDialog = (transfer: InventoryTransfer) => {
    setEditingTransfer(transfer);
    setOriginalTransferForEdit(JSON.parse(JSON.stringify(transfer)));
    setEditFromBranchId(transfer.fromBranchId);
    setEditToBranchId(transfer.toBranchId);
    setEditMaterialName(transfer.materialName);
    setEditQuantity(transfer.quantity.toString()); // Convertir a string para el input
    setEditUnit(transfer.unit);
    setEditTransferDate(parseISO(transfer.date));
    setEditNotes(transfer.notes || '');
    updateAvailableMaterials(transfer.fromBranchId, true); // Cargar materiales para la sede origen actual de la transferencia
    setIsEditTransferDialogOpen(true);
  };

  const handleUpdateTransfer = () => {
    if (!editingTransfer || !originalTransferForEdit || !editFromBranchId || !editToBranchId || !editMaterialName || !editQuantity || !editUnit || !editTransferDate) {
      toast({ title: "Error", description: "Todos los campos marcados con * son obligatorios.", variant: "destructive" }); return;
    }
    if (editFromBranchId === editToBranchId) {
      toast({ title: "Error", description: "La sede de origen y destino no pueden ser la misma.", variant: "destructive" }); return;
    }
    const transferQtyNum = parseFloat(editQuantity);
    if (isNaN(transferQtyNum) || transferQtyNum <= 0) {
      toast({ title: "Error", description: "La cantidad debe ser un número positivo.", variant: "destructive" }); return;
    }
    setIsSubmitting(true);

    // 1. Revertir la transferencia original
    let origFromInv = loadRawMaterialInventoryData(originalTransferForEdit.fromBranchId);
    let origToInv = loadRawMaterialInventoryData(originalTransferForEdit.toBranchId);
    const origMatIdxFrom = origFromInv.findIndex(i => i.name === originalTransferForEdit.materialName && normalizeUnit(i.unit) === normalizeUnit(originalTransferForEdit.unit));
    if (origMatIdxFrom !== -1) origFromInv[origMatIdxFrom].quantity += originalTransferForEdit.quantity;
    else origFromInv.push({ name: originalTransferForEdit.materialName, quantity: originalTransferForEdit.quantity, unit: originalTransferForEdit.unit });
    saveRawMaterialInventoryData(originalTransferForEdit.fromBranchId, origFromInv);
    const origMatIdxTo = origToInv.findIndex(i => i.name === originalTransferForEdit.materialName && normalizeUnit(i.unit) === normalizeUnit(originalTransferForEdit.unit));
    if (origMatIdxTo !== -1) {
        origToInv[origMatIdxTo].quantity -= originalTransferForEdit.quantity;
        if (origToInv[origMatIdxTo].quantity < 0.0001) origToInv.splice(origMatIdxTo, 1);
    }
    saveRawMaterialInventoryData(originalTransferForEdit.toBranchId, origToInv);

    // 2. Aplicar la nueva transferencia (validando stock)
    const newOriginInventory = loadRawMaterialInventoryData(editFromBranchId);
    const { quantity: newTransferQtyInBaseUnit, unit: newMaterialBaseUnit } = convertMaterialToBaseUnit(transferQtyNum, editUnit, editMaterialName);
    const materialInNewOrigin = newOriginInventory.find(item => item.name.toLowerCase() === editMaterialName.toLowerCase() && normalizeUnit(item.unit) === normalizeUnit(newMaterialBaseUnit));
    if (!materialInNewOrigin || materialInNewOrigin.quantity < newTransferQtyInBaseUnit) {
      // Revertir la reversión si la nueva operación falla
      saveRawMaterialInventoryData(originalTransferForEdit.fromBranchId, loadRawMaterialInventoryData(originalTransferForEdit.fromBranchId).map(i => i.name === originalTransferForEdit.materialName && normalizeUnit(i.unit) === normalizeUnit(originalTransferForEdit.unit) ? {...i, quantity: i.quantity - originalTransferForEdit.quantity} : i).filter(i => i.quantity > 0.0001) );
      saveRawMaterialInventoryData(originalTransferForEdit.toBranchId, loadRawMaterialInventoryData(originalTransferForEdit.toBranchId).map(i => i.name === originalTransferForEdit.materialName && normalizeUnit(i.unit) === normalizeUnit(originalTransferForEdit.unit) ? {...i, quantity: i.quantity + originalTransferForEdit.quantity} : i) );

      toast({ title: "Error de Stock", description: `Stock insuficiente de ${editMaterialName} en ${editFromBranchId} para la nueva cantidad. Cambios revertidos.`, variant: "destructive", duration: 7000 });
      setIsSubmitting(false); return;
    }
    const updatedNewOriginInventory = newOriginInventory.map(item => item.name.toLowerCase() === editMaterialName.toLowerCase() && normalizeUnit(item.unit) === normalizeUnit(newMaterialBaseUnit) ? { ...item, quantity: item.quantity - newTransferQtyInBaseUnit } : item).filter(item => item.quantity > 0.0001);
    saveRawMaterialInventoryData(editFromBranchId, updatedNewOriginInventory);
    let newDestinationInventory = loadRawMaterialInventoryData(editToBranchId);
    const materialInNewDestinationIndex = newDestinationInventory.findIndex(item => item.name.toLowerCase() === editMaterialName.toLowerCase() && normalizeUnit(item.unit) === normalizeUnit(newMaterialBaseUnit));
    if (materialInNewDestinationIndex !== -1) newDestinationInventory[materialInNewDestinationIndex].quantity += newTransferQtyInBaseUnit;
    else newDestinationInventory.push({ name: editMaterialName, quantity: newTransferQtyInBaseUnit, unit: newMaterialBaseUnit });
    saveRawMaterialInventoryData(editToBranchId, newDestinationInventory);

    // 3. Actualizar el registro de transferencia
    const fromBranchNew = availableBranches.find(b => b.id === editFromBranchId);
    const toBranchNew = availableBranches.find(b => b.id === editToBranchId);
    const updatedTransferData: InventoryTransfer = {
      ...editingTransfer,
      date: format(editTransferDate, "yyyy-MM-dd"),
      fromBranchId: editFromBranchId, fromBranchName: fromBranchNew?.name || 'Desconocida',
      toBranchId: editToBranchId, toBranchName: toBranchNew?.name || 'Desconocida',
      materialName: editMaterialName, quantity: newTransferQtyInBaseUnit, unit: newMaterialBaseUnit,
      notes: editNotes.trim(),
      timestamp: new Date().toISOString(), // Update timestamp on edit
    };
    const updatedTransfers = transfers.map(t => t.id === editingTransfer.id ? updatedTransferData : t).sort((a, b) => parseISO(b.date).getTime() - parseISO(a.date).getTime());
    saveInventoryTransfersData(updatedTransfers);
    setTransfers(updatedTransfers); setDebtSummary(calculateDebtSummary(updatedTransfers));
    updateAvailableMaterials(editFromBranchId, true); // Actualizar materiales para el diálogo de edición si sigue abierto

    toast({ title: "Transferencia Actualizada", description: `La transferencia ${editingTransfer.id} ha sido actualizada.` });
    setIsEditTransferDialogOpen(false); setEditingTransfer(null); setOriginalTransferForEdit(null); setIsSubmitting(false);
  };

  const handleOpenDeleteDialog = (transferId: string) => {
    setTransferToDeleteId(transferId);
    setIsDeleteConfirmOpen(true);
  };

  const handleConfirmDeleteTransfer = () => {
    if (!transferToDeleteId) return;
    setIsSubmitting(true);
    const transferToDelete = transfers.find(t => t.id === transferToDeleteId);
    if (!transferToDelete) {
        toast({ title: "Error", description: "Transferencia no encontrada.", variant: "destructive" });
        setIsSubmitting(false); setIsDeleteConfirmOpen(false); return;
    }
    let originInventory = loadRawMaterialInventoryData(transferToDelete.fromBranchId);
    const materialInOriginIdx = originInventory.findIndex(item => item.name.toLowerCase() === transferToDelete.materialName.toLowerCase() && normalizeUnit(item.unit) === normalizeUnit(transferToDelete.unit));
    if (materialInOriginIdx !== -1) originInventory[materialInOriginIdx].quantity += transferToDelete.quantity;
    else originInventory.push({ name: transferToDelete.materialName, quantity: transferToDelete.quantity, unit: transferToDelete.unit });
    saveRawMaterialInventoryData(transferToDelete.fromBranchId, originInventory);
    let destinationInventory = loadRawMaterialInventoryData(transferToDelete.toBranchId);
    const materialInDestIdx = destinationInventory.findIndex(item => item.name.toLowerCase() === transferToDelete.materialName.toLowerCase() && normalizeUnit(item.unit) === normalizeUnit(transferToDelete.unit));
    if (materialInDestIdx !== -1) {
        destinationInventory[materialInDestIdx].quantity -= transferToDelete.quantity;
        if (destinationInventory[materialInDestIdx].quantity < 0.0001) destinationInventory.splice(materialInDestIdx, 1);
    }
    saveRawMaterialInventoryData(transferToDelete.toBranchId, destinationInventory);
    const updatedTransfers = transfers.filter(t => t.id !== transferToDeleteId);
    saveInventoryTransfersData(updatedTransfers);
    setTransfers(updatedTransfers); setDebtSummary(calculateDebtSummary(updatedTransfers));
    updateAvailableMaterials(transferToDelete.fromBranchId, false);
    toast({ title: "Transferencia Eliminada", description: "La transferencia ha sido eliminada y los inventarios ajustados."});
    setIsDeleteConfirmOpen(false); setTransferToDeleteId(null); setIsSubmitting(false);
  };


  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[calc(100vh-10rem)]">
        <Loader2 className="h-12 w-12 animate-spin text-primary" />
        <p className="ml-4 text-lg">Cargando transferencias...</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <PageHeader
        title="Transferencias de Materia Prima entre Sedes"
        description="Registra y consulta el movimiento de materia prima entre tus diferentes sedes. También puedes ver un resumen de las deudas pendientes de materia prima."
        icon={ArrowRightLeft}
        actions={
          <Button onClick={() => { resetDialogForm(); setIsRegisterTransferDialogOpen(true); }} disabled={isSubmitting || availableBranches.length < 2}>
            <PlusCircle className="mr-2 h-4 w-4" />
            Registrar Nueva Transferencia
          </Button>
        }
      />
       {availableBranches.length < 2 && (
          <Card className="border-yellow-500 border-dashed bg-yellow-500/10">
            <CardContent className="pt-6">
              <div className="flex items-center">
                <AlertTriangle className="h-5 w-5 text-yellow-600 mr-3" />
                <p className="text-yellow-700 dark:text-yellow-500 text-sm">
                  Debes tener al menos dos sedes configuradas para poder realizar transferencias. Actualmente solo hay {availableBranches.length} sede(s).
                </p>
              </div>
            </CardContent>
          </Card>
        )}

      <Card className="shadow-lg">
        <CardHeader>
          <CardTitle>Resumen de Deudas de Materia Prima entre Sedes</CardTitle>
          <CardDescription>
            {debtSummary.length > 0 ? "Listado de materia prima pendiente de reponer entre sedes." : "No hay deudas de materia prima pendientes entre sedes."}
          </CardDescription>
        </CardHeader>
        <CardContent>
          {debtSummary.length > 0 ? (
            <Table>
              <TableHeader><TableRow><TableHead>Sede Deudora</TableHead><TableHead>Sede Acreedora</TableHead><TableHead>Materia Prima</TableHead><TableHead className="text-right">Cantidad Adeudada</TableHead><TableHead>Unidad</TableHead></TableRow></TableHeader>
              <TableBody>
                {debtSummary.map((debt, index) => (
                  <TableRow key={`${debt.debtorBranchId}-${debt.creditorBranchId}-${debt.materialName}-${index}`}>
                    <TableCell className="font-medium">{debt.debtorBranchName}</TableCell><TableCell className="font-medium">{debt.creditorBranchName}</TableCell>
                    <TableCell>{debt.materialName}</TableCell>
                    <TableCell className="text-right text-destructive font-semibold">
                      <FormattedNumber value={debt.quantityOwed} decimalPlaces={3} />
                    </TableCell>
                    <TableCell>{debt.unit}</TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          ) : (!isLoading && <p className="text-center text-muted-foreground py-8">No hay deudas de materia prima pendientes entre sedes.</p>)}
        </CardContent>
      </Card>

      <Card className="shadow-lg">
        <CardHeader>
          <CardTitle>Historial de Transferencias</CardTitle>
          <CardDescription>{transfers.length > 0 ? "Lista de todas las transferencias de materia prima realizadas." : "No hay transferencias registradas."}</CardDescription>
        </CardHeader>
        <CardContent>
          {transfers.length > 0 ? (
            <Table>
              <TableHeader><TableRow><TableHead>Fecha</TableHead><TableHead>Sede Origen</TableHead><TableHead>Sede Destino</TableHead><TableHead>Materia Prima</TableHead><TableHead className="text-right">Cantidad</TableHead><TableHead>Unidad</TableHead><TableHead>Notas</TableHead><TableHead className="text-right">Acciones</TableHead></TableRow></TableHeader>
              <TableBody>
                {transfers.map((transfer) => (
                  <TableRow key={transfer.id}>
                    <TableCell>{format(parseISO(transfer.date), "dd/MM/yyyy", { locale: es })}</TableCell>
                    <TableCell>{transfer.fromBranchName}</TableCell><TableCell>{transfer.toBranchName}</TableCell>
                    <TableCell className="font-medium">{transfer.materialName}</TableCell>
                    <TableCell className="text-right">
                      <FormattedNumber value={transfer.quantity} decimalPlaces={3} />
                    </TableCell>
                    <TableCell>{transfer.unit}</TableCell><TableCell className="max-w-xs truncate" title={transfer.notes}>{transfer.notes || '-'}</TableCell>
                    <TableCell className="text-right">
                        <DropdownMenu>
                            <DropdownMenuTrigger asChild><Button variant="ghost" size="icon" disabled={isSubmitting}><MoreHorizontal className="h-4 w-4" /></Button></DropdownMenuTrigger>
                            <DropdownMenuContent align="end">
                                <DropdownMenuItem onClick={() => handleOpenEditDialog(transfer)} disabled={isSubmitting}><Edit className="mr-2 h-4 w-4" />Editar</DropdownMenuItem>
                                <DropdownMenuItem onClick={() => handleOpenDeleteDialog(transfer.id)} disabled={isSubmitting} className="text-destructive focus:text-destructive-foreground focus:bg-destructive/90"><Trash2 className="mr-2 h-4 w-4" />Eliminar</DropdownMenuItem>
                            </DropdownMenuContent>
                        </DropdownMenu>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          ) : (!isLoading && <p className="text-center text-muted-foreground py-8">No hay transferencias registradas.</p>)}
        </CardContent>
      </Card>

      {/* Dialogo para Registrar Transferencia */}
      <Dialog open={isRegisterTransferDialogOpen} onOpenChange={(isOpen) => { if(!isSubmitting) setIsRegisterTransferDialogOpen(isOpen); }}>
        <DialogContent className="sm:max-w-lg">
          <DialogHeader><DialogTitle>Registrar Nueva Transferencia</DialogTitle><DialogDescription>Completa los detalles.</DialogDescription></DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="grid grid-cols-2 gap-4">
                <div className="space-y-1"><Label htmlFor="fromBranchId">Sede Origen*</Label><Select value={fromBranchId} onValueChange={(val) => handleFromBranchChange(val, false)} disabled={isSubmitting}><SelectTrigger id="fromBranchId"><SelectValue /></SelectTrigger><SelectContent>{availableBranches.map(b => (<SelectItem key={b.id} value={b.id}>{b.name}</SelectItem>))}</SelectContent></Select></div>
                <div className="space-y-1"><Label htmlFor="toBranchId">Sede Destino*</Label><Select value={toBranchId} onValueChange={(val) => handleToBranchChange(val, false)} disabled={isSubmitting}><SelectTrigger id="toBranchId"><SelectValue /></SelectTrigger><SelectContent>{availableBranches.map(b => (<SelectItem key={b.id} value={b.id}>{b.name}</SelectItem>))}</SelectContent></Select></div>
            </div>
            <div className="space-y-1"><Label htmlFor="materialName">Materia Prima*</Label><Select value={materialName} onValueChange={(v) => {setMaterialName(v); const sm=availableMaterialsFromOrigin.find(m=>m.name===v); if(sm)setUnit(sm.unit); else setUnit('');}} disabled={isSubmitting||availableMaterialsFromOrigin.length===0}><SelectTrigger id="materialName"><SelectValue/></SelectTrigger>
              <SelectContent>{availableMaterialsFromOrigin.map(m=>(<SelectItem key={m.name} value={m.name}>{m.name} (Disp: <FormattedNumber value={m.availableQuantity} decimalPlaces={3} /> {m.unit})</SelectItem>))}</SelectContent>
            </Select>{availableMaterialsFromOrigin.length===0&&fromBranchId&&<p className="text-xs text-muted-foreground pt-1">No hay stock en origen.</p>}</div>
            <div className="grid grid-cols-2 gap-4">
                <div className="space-y-1"><Label htmlFor="quantity">Cantidad*</Label><Input id="quantity" type="number" value={quantity} onChange={(e)=>setQuantity(e.target.value)} disabled={isSubmitting}/></div>
                <div className="space-y-1"><Label htmlFor="unit">Unidad*</Label><Input id="unit" value={unit} readOnly disabled className="bg-muted/50"/></div>
            </div>
            <div className="space-y-1"><Label htmlFor="transferDate">Fecha*</Label><Popover open={isTransferDatePickerOpen} onOpenChange={setIsTransferDatePickerOpen}><PopoverTrigger asChild><Button id="transferDate" variant="outline" className={cn("w-full justify-start text-left font-normal",!transferDate&&"text-muted-foreground")} disabled={isSubmitting}><CalendarIcon className="mr-2 h-4 w-4"/>{transferDate?format(transferDate,"PPP",{locale:es}):<span>Elige</span>}</Button></PopoverTrigger><PopoverContent className="w-auto p-0"><Calendar mode="single" selected={transferDate} onSelect={(date) => {setTransferDate(date); setIsTransferDatePickerOpen(false);}} initialFocus locale={es} disabled={isSubmitting}/></PopoverContent></Popover></div>
            <div className="space-y-1"><Label htmlFor="notes">Notas</Label><Textarea id="notes" value={notes} onChange={(e)=>setNotes(e.target.value)} disabled={isSubmitting}/></div>
          </div>
          <DialogFooter><DialogClose asChild><Button variant="outline" disabled={isSubmitting}>Cancelar</Button></DialogClose><Button onClick={handleRegisterTransfer} disabled={isSubmitting||fromBranchId===toBranchId||availableBranches.length<2}>{isSubmitting?<Loader2 className="mr-2 h-4 w-4 animate-spin"/>:"Registrar"}</Button></DialogFooter>
        </DialogContent>
      </Dialog>

       {/* Dialogo para Editar Transferencia */}
       <Dialog open={isEditTransferDialogOpen} onOpenChange={(isOpen) => { if(!isSubmitting) setIsEditTransferDialogOpen(isOpen); }}>
        <DialogContent className="sm:max-w-lg">
          <DialogHeader><DialogTitle>Editar Transferencia</DialogTitle><DialogDescription>Modifica los detalles de la transferencia.</DialogDescription></DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="grid grid-cols-2 gap-4">
                <div className="space-y-1"><Label htmlFor="editFromBranchId">Sede Origen*</Label><Select value={editFromBranchId} onValueChange={(val) => handleFromBranchChange(val, true)} disabled={isSubmitting}><SelectTrigger id="editFromBranchId"><SelectValue /></SelectTrigger><SelectContent>{availableBranches.map(b => (<SelectItem key={b.id} value={b.id}>{b.name}</SelectItem>))}</SelectContent></Select></div>
                <div className="space-y-1"><Label htmlFor="editToBranchId">Sede Destino*</Label><Select value={editToBranchId} onValueChange={(val) => handleToBranchChange(val, true)} disabled={isSubmitting}><SelectTrigger id="editToBranchId"><SelectValue /></SelectTrigger><SelectContent>{availableBranches.map(b => (<SelectItem key={b.id} value={b.id}>{b.name}</SelectItem>))}</SelectContent></Select></div>
            </div>
            <div className="space-y-1"><Label htmlFor="editMaterialName">Materia Prima*</Label><Select value={editMaterialName} onValueChange={(v) => {setEditMaterialName(v); const sm=availableMaterialsFromEditOrigin.find(m=>m.name===v); if(sm)setEditUnit(sm.unit); else setEditUnit('');}} disabled={isSubmitting||availableMaterialsFromEditOrigin.length===0}><SelectTrigger id="editMaterialName"><SelectValue/></SelectTrigger>
              <SelectContent>{availableMaterialsFromEditOrigin.map(m=>(<SelectItem key={m.name} value={m.name}>{m.name} (Disp: <FormattedNumber value={m.availableQuantity} decimalPlaces={3} /> {m.unit})</SelectItem>))}</SelectContent>
            </Select>{availableMaterialsFromEditOrigin.length===0&&editFromBranchId&&<p className="text-xs text-muted-foreground pt-1">No hay stock en origen.</p>}</div>
            <div className="grid grid-cols-2 gap-4">
                <div className="space-y-1"><Label htmlFor="editQuantity">Cantidad*</Label><Input id="editQuantity" type="number" value={editQuantity} onChange={(e)=>setEditQuantity(e.target.value)} disabled={isSubmitting}/></div>
                <div className="space-y-1"><Label htmlFor="editUnit">Unidad*</Label><Input id="editUnit" value={editUnit} readOnly disabled className="bg-muted/50"/></div>
            </div>
            <div className="space-y-1"><Label htmlFor="editTransferDate">Fecha*</Label><Popover open={isEditTransferDatePickerOpen} onOpenChange={setIsEditTransferDatePickerOpen}><PopoverTrigger asChild><Button id="editTransferDate" variant="outline" className={cn("w-full justify-start text-left font-normal",!editTransferDate&&"text-muted-foreground")} disabled={isSubmitting}><CalendarIcon className="mr-2 h-4 w-4"/>{editTransferDate?format(editTransferDate,"PPP",{locale:es}):<span>Elige</span>}</Button></PopoverTrigger><PopoverContent className="w-auto p-0"><Calendar mode="single" selected={editTransferDate} onSelect={(date) => {setEditTransferDate(date); setIsEditTransferDatePickerOpen(false);}} initialFocus locale={es} disabled={isSubmitting}/></PopoverContent></Popover></div>
            <div className="space-y-1"><Label htmlFor="editNotes">Notas</Label><Textarea id="editNotes" value={editNotes} onChange={(e)=>setEditNotes(e.target.value)} disabled={isSubmitting}/></div>
          </div>
          <DialogFooter><DialogClose asChild><Button variant="outline" disabled={isSubmitting}>Cancelar</Button></DialogClose><Button onClick={handleUpdateTransfer} disabled={isSubmitting||editFromBranchId===editToBranchId||availableBranches.length<2}>{isSubmitting?<Loader2 className="mr-2 h-4 w-4 animate-spin"/>:"Guardar Cambios"}</Button></DialogFooter>
        </DialogContent>
      </Dialog>

       <Dialog open={isDeleteConfirmOpen} onOpenChange={(isOpen) => { if(!isSubmitting) setIsDeleteConfirmOpen(isOpen); }}>
        <DialogContent className="sm:max-w-md">
            <DialogHeader><DialogTitle>Confirmar Eliminación</DialogTitle><DialogDescription>¿Eliminar esta transferencia? Se revertirán los cambios en inventarios. No se puede deshacer.</DialogDescription></DialogHeader>
            <DialogFooter><DialogClose asChild><Button variant="outline" disabled={isSubmitting}>Cancelar</Button></DialogClose><Button variant="destructive" onClick={handleConfirmDeleteTransfer} disabled={isSubmitting}>{isSubmitting?<Loader2 className="mr-2 h-4 w-4 animate-spin"/>:"Sí, Eliminar"}</Button></DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}

// --- login ---


"use client";

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useToast } from "@/hooks/use-toast";
import { LogIn, KeyRound } from 'lucide-react';
import { SIMULATED_ADMIN_USERNAME, SIMULATED_USER_PASSWORD } from '@/lib/data-storage';

export default function LoginPage() {
  const router = useRouter();
  const { toast } = useToast();
  const [username, setUsername] = useState(''); // Cambiado de email a username
  const [password, setPassword] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    if (typeof window !== 'undefined' && localStorage.getItem('isUserLoggedIn') === 'true') {
      router.replace('/');
    }
  }, [router]);

  const handleLogin = async (event: React.FormEvent) => {
    event.preventDefault();
    setIsLoading(true);

    // Comparar con SIMULATED_ADMIN_USERNAME
    if (username === SIMULATED_ADMIN_USERNAME && password === SIMULATED_USER_PASSWORD) {
      toast({
        title: "Inicio de Sesión Exitoso",
        description: `¡Bienvenido de nuevo, Administrador!`,
      });
      if (typeof window !== 'undefined') {
        localStorage.setItem('isUserLoggedIn', 'true');
      }
      router.push('/'); 
    } else {
      toast({
        title: "Error de Inicio de Sesión",
        description: "Nombre de usuario o contraseña incorrectos.",
        variant: "destructive",
      });
      setIsLoading(false);
    }
  };

  return (
    <div className="flex items-center justify-center min-h-screen bg-background p-4">
      <Card className="w-full max-w-md shadow-xl">
        <CardHeader className="space-y-1 text-center">
          <div className="flex justify-center mb-4">
            <div className="p-3 bg-primary/10 rounded-full">
                <LogIn className="h-8 w-8 text-primary" />
            </div>
          </div>
          <CardTitle className="text-2xl">Iniciar Sesión</CardTitle>
          <CardDescription>
            Ingresa tus credenciales de administrador.
            {/* Pista de credenciales eliminada */}
          </CardDescription>
        </CardHeader>
        <form onSubmit={handleLogin}>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="username">Nombre de Usuario</Label> {/* Cambiado de email a username */}
              <Input
                id="username"
                type="text" // Cambiado de email a text
                placeholder="admin"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                required
                disabled={isLoading}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="password">Contraseña</Label>
              <Input
                id="password"
                type="password"
                placeholder="••••••••"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                disabled={isLoading}
              />
            </div>
          </CardContent>
          <CardFooter className="flex flex-col">
            <Button type="submit" className="w-full" disabled={isLoading}>
              {isLoading ? 'Iniciando...' : 'Iniciar Sesión'}
            </Button>
            <p className="mt-4 text-center text-xs text-muted-foreground">
              <KeyRound className="inline-block h-3 w-3 mr-1" />
              Inicio de sesión simulado.
            </p>
          </CardFooter>
        </form>
      </Card>
    </div>
  );
}

// --- logout ---


"use client";

import { PageHeader } from '@/components/page-header';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { LogOut, AlertTriangle } from 'lucide-react';
import Link from 'next/link';
import { useRouter } from 'next/navigation';
import { useToast } from "@/hooks/use-toast";
import { useEffect } from 'react';

export default function LogoutPage() {
  const router = useRouter();
  const { toast } = useToast();

  const handleLogout = () => {
    if (typeof window !== 'undefined') {
      localStorage.removeItem('isUserLoggedIn'); // Eliminar indicador de login
    }
    toast({
      title: "Sesión Cerrada",
      description: "Has cerrado sesión correctamente. Serás redirigido.",
    });
    setTimeout(() => {
      router.push('/login'); // Redirigir a la página de login
    }, 1500);
  };

  // Opcional: Si el usuario llega aquí y no está "logueado", redirigir a login inmediatamente.
  useEffect(() => {
    if (typeof window !== 'undefined' && !localStorage.getItem('isUserLoggedIn')) {
      router.replace('/login');
    }
  }, [router]);


  return (
    <div className="space-y-6 flex flex-col items-center justify-center min-h-[calc(100vh-15rem)]">
      <PageHeader
        title="Cerrar Sesión"
        description="¿Estás seguro de que quieres cerrar sesión en tu cuenta?"
        icon={LogOut}
      />

      <Card className="shadow-lg w-full max-w-md">
        <CardHeader className="text-center">
            <AlertTriangle className="mx-auto h-12 w-12 text-destructive mb-4" />
            <CardTitle>Confirmar Cierre de Sesión</CardTitle>
            <CardDescription>Serás redirigido a la página de inicio de sesión.</CardDescription>
        </CardHeader>
        <CardContent className="space-y-4 p-6">
          <Button variant="destructive" className="w-full" onClick={handleLogout}>
            Sí, Cerrar Sesión
          </Button>
          <Button variant="outline" className="w-full" asChild>
            <Link href="/">Cancelar y Volver al Panel</Link>
          </Button>
        </CardContent>
      </Card>
    </div>
  );
}

// --- orders ---



"use client";

import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { PageHeader } from '@/components/page-header';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Badge } from '@/components/ui/badge';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogClose } from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Textarea } from '@/components/ui/textarea';
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Calendar } from "@/components/ui/calendar";
import { Receipt, PlusCircle, MoreHorizontal, Edit, Trash2, Calendar as CalendarIcon, Loader2, Trash, FileText as InvoiceIcon, Filter, Gift, AlertTriangle, Eye, DollarSign, SaveIcon, PackageCheck, Settings, Settings2, ListPlus, XCircle, Search } from 'lucide-react';
import { useToast } from "@/hooks/use-toast";
import { format, parseISO, addDays, differenceInDays, isWithinInterval, startOfDay, endOfDay, isValid, compareDesc } from "date-fns";
import type { DateRange } from "react-day-picker";
import { es } from "date-fns/locale";
import { cn } from "@/lib/utils";
import {
  type Product,
  salesData as initialSalesDataGlobal,
  saveSalesData,
  type Sale,
  type SaleItem,
  type SaleBranchDetail,
  customersData as initialCustomersDataGlobal,
  saveCustomersData,
  type Customer,
  salePaymentMethods,
  loadExchangeRate,
  type AccountTransaction,
  type CompanyAccountsData,
  type AccountType,
  accountTypeNames,
  getInvoiceStatus,
  type SaleStatus,
  paymentsData as initialPaymentsData,
  savePaymentsData,
  type Payment,
  KEYS,
  loadAllProductsFromAllBranches,
  loadProductsForBranch,
  saveProductsDataForBranch,
  type PendingFundTransfer,
  savePendingFundTransfersData,
  pendingFundTransfersData as initialPendingFundTransfersData,
  availableBranches,
  getActiveBranchId,
  loadFromLocalStorageForBranch,
  saveToLocalStorageForBranch,
  calculateCustomerBalance,
  type PaymentSplit,
  type PaymentMethodType,
  paymentMethodList,
  suppliersData as initialSuppliersData,
  getBestPriceInfo,
  getCurrentPriceFromHistory,
  loadCompanyAccountsData,
  type PurchaseOrderStatus,
  savePurchaseOrdersData,
  updateRawMaterialInventoryFromOrder,
  addRawMaterialOption,
  removeRawMaterialOption,
  saveSuppliersData,
  type PriceHistoryEntry,
  type PurchaseOrder,
  type PurchaseOrderItem,
  purchaseOrderStatusList,
  updateSupplierPriceList,
  updateCompanyAccountAndExpensesForPO,
  commonUnitOptions,
  getCurrentRawMaterialOptions,
  loadPurchaseOrdersFromStorage,
  convertMaterialToBaseUnit,
  normalizeUnit,
  type PricePointInfo,
  type Supplier
} from '@/lib/data-storage';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Separator } from '@/components/ui/separator';
import { Tooltip, TooltipProvider, TooltipTrigger, TooltipContent } from "@/components/ui/tooltip";
import { ManageConversionsDialog } from '@/components/orders/manage-conversions-dialog';
import { FormattedNumber } from '@/components/ui/formatted-number';
import { processInvoice, type ProcessInvoiceInput, type ProcessInvoiceOutput } from '@/ai/flows/process-invoice-flow';
import type jsPDF from 'jspdf';


interface jsPDFWithAutoTable extends jsPDF {
  autoTable: (options: any) => jsPDFWithAutoTable;
}

interface PurchaseOrderItemExtended extends PurchaseOrderItem {
  bestPriceHint?: string;
  manualPriceEdit?: boolean;
  unitPriceDisplayUSD: string;
  unitPriceDisplayVES: string;
  priceInputCurrency: 'USD' | 'VES';
}

const ALL_SUPPLIERS_FILTER_VALUE = "__ALL_SUPPLIERS__";


export default function OrdersPage() {
  const { toast } = useToast();
  const [allPurchaseOrders, setAllPurchaseOrders] = useState<PurchaseOrder[]>([]);
  const [filteredPurchaseOrders, setFilteredPurchaseOrders] = useState<PurchaseOrder[]>([]);
  const [currentRawMaterialOptions, setCurrentRawMaterialOptions] = useState<string[]>([]);
  const [currentSuppliers, setCurrentSuppliers] = useState<Supplier[]>([]);
  const [exchangeRate, setExchangeRate] = useState<number>(0);
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isAnalyzing, setIsAnalyzing] = useState(false);

  const [isPODialogOpen, setIsPODialogOpen] = useState(false);
  const [isEditingPO, setIsEditingPO] = useState(false);
  const [editingPOId, setEditingPOId] = useState<string | null>(null);
  const [currentEditablePOId, setCurrentEditablePOId] = useState<string>('');
  const [originalPOForEdit, setOriginalPOForEdit] = useState<PurchaseOrder | null>(null);

  const [newOrderId, setNewOrderId] = useState<string>('');
  const [selectedSupplierId, setSelectedSupplierId] = useState<string>('');
  const [orderDate, setOrderDate] = useState<Date | undefined>(new Date());
  const [expectedDelivery, setExpectedDelivery] = useState<Date | undefined>(new Date());
  const [currentOrderStatus, setCurrentOrderStatus] = useState<PurchaseOrderStatus>('Pagado');
  const [newPONotes, setNewPONotes] = useState('');
  const [editPONotes, setEditPONotes] = useState('');
  const [editOrderDate, setEditOrderDate] = useState<Date | undefined>(undefined);
  const [editExpectedDelivery, setEditExpectedDelivery] = useState<Date | undefined>(undefined);

  const [isOrderDatePickerOpen, setIsOrderDatePickerOpen] = useState(false);
  const [isDeliveryDatePickerOpen, setIsDeliveryDatePickerOpen] = useState(false);


  const generateUniqueItemId = useCallback((prefix: string, existingIdsInList: string[]): string => {
    let newId;
    let attempt = 0;
    const MAX_ATTEMPTS = 100;
    const generateRandomSuffix = () => {
      if (typeof crypto !== 'undefined' && crypto.randomUUID) {
        return crypto.randomUUID().replace(/-/g, '').substring(0, 22);
      }
      return (Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15) + Math.random().toString(36,2,15)).substring(0, 22);
    };

    do {
      const randomSuffix = generateRandomSuffix();
      newId = `${prefix}-${randomSuffix}${attempt > 0 ? `-v${attempt}` : ''}`;
      attempt++;
      if (attempt > MAX_ATTEMPTS) {
        console.warn(`generateUniqueItemId: Max attempts for ${prefix}. Using: ${newId}`);
        break;
      }
    } while (existingIdsInList.includes(newId));
    return newId;
  }, []);


  const [globalOrderItems, setGlobalOrderItems] = useState<PurchaseOrderItemExtended[]>([{ id: generateUniqueItemId('global-item-initial-state', []), rawMaterialName: '', quantity: 0, unit: commonUnitOptions[0] || '', unitPrice: 0, subtotal: 0, bestPriceHint: '', manualPriceEdit: false, unitPriceDisplayUSD: "0", unitPriceDisplayVES: "0.00", priceInputCurrency: 'VES' }]);


  const activeBranchForDefaultSplit = getActiveBranchId();
  const initialBranchIdForDefaultNewSplit = activeBranchForDefaultSplit || (availableBranches.length > 0 ? availableBranches[0].id : '');

  const [newPaymentSplits, setNewPaymentSplits] = useState<PaymentSplit[]>([{
    id: generateUniqueItemId('split-initial-state', []),
    amount: 0,
    currency: 'VES',
    paymentMethod: 'Transferencia (VES)',
    paidToBranchId: initialBranchIdForDefaultNewSplit,
    paidToAccountId: 'vesElectronic',
    items: []
  }]);
  const [editPaymentSplits, setEditPaymentSplits] = useState<PaymentSplit[]>([]);


  const [isDeleteConfirmDialogOpen, setIsDeleteConfirmDialogOpen] = useState(false);
  const [poToDeleteId, setPoToDeleteId] = useState<string | null>(null);

  const [isManageMaterialsDialogOpen, setIsManageMaterialsDialogOpen] = useState(false);
  const [newMaterialName, setNewMaterialName] = useState('');
  const [materialToDelete, setMaterialToDelete] = useState<string | null>(null);
  const [isDeleteMaterialConfirmOpen, setIsDeleteMaterialConfirmOpen] = useState(false);

  const [dateRangeFilter, setDateRangeFilter] = useState<DateRange | undefined>(undefined);
  const [filterSupplierId, setFilterSupplierId] = useState<string>(ALL_SUPPLIERS_FILTER_VALUE);
  const [filterOrderId, setFilterOrderId] = useState<string>('');


  const [isViewPODialogOpen, setIsViewPODialogOpen] = useState(false);
  const [poToViewDetails, setPoToViewDetails] = useState<PurchaseOrder | null>(null);

  const [isManageConversionsDialogOpen, setIsManageConversionsDialogOpen] = useState(false);

  const [invoiceFile, setInvoiceFile] = useState<File | null>(null);

  const handleConversionsUpdated = useCallback(() => {}, []);


  const loadInitialData = useCallback(() => {
    setIsLoading(true);
    const activeBranchId = getActiveBranchId();
    if (!activeBranchId) {
      toast({ title: "Error de Configuración", description: "No se ha seleccionado una sede activa. Por favor, selecciona una sede.", variant: "destructive" });
      setIsLoading(false);
      return;
    }

    const orders = [...loadFromLocalStorageForBranch<PurchaseOrder[]>(KEYS.PURCHASE_ORDERS, activeBranchId)].sort((a,b) => {
        const dateA = a.orderDate && isValid(parseISO(a.orderDate)) ? parseISO(a.orderDate).getTime() : 0;
        const dateB = b.orderDate && isValid(parseISO(b.orderDate)) ? parseISO(b.orderDate).getTime() : 0;
        if (dateA === 0 && dateB === 0) return 0;
        if (dateA === 0) return 1;
        if (dateB === 0) return -1;
        return dateB - dateA;
    });
    setAllPurchaseOrders(orders);
    setFilteredPurchaseOrders(orders);

    const materialOptions = getCurrentRawMaterialOptions();
    setCurrentRawMaterialOptions(materialOptions);

    const loadedSuppliers = [...initialSuppliersData];
    setCurrentSuppliers(loadedSuppliers);

    if (loadedSuppliers.length > 0 && !selectedSupplierId) {
      setSelectedSupplierId(loadedSuppliers[0].id);
    }

    const rate = loadExchangeRate();
    setExchangeRate(rate);

    const initialBranchIdForPayment = activeBranchId || (availableBranches.length > 0 ? availableBranches[0].id : '');
    setNewPaymentSplits([{
        id: generateUniqueItemId('split-load-init', []),
        amount: 0, currency: 'VES', paymentMethod: 'Transferencia (VES)',
        paidToBranchId: initialBranchIdForPayment, paidToAccountId: 'vesElectronic',
        referenceNumber: '', items: []
    }]);
    
    setGlobalOrderItems([{ 
        id: generateUniqueItemId('global-item-load', []), 
        rawMaterialName: '', quantity: 0, unit: commonUnitOptions[0] || '', 
        unitPrice: 0, subtotal: 0, bestPriceHint: '', manualPriceEdit: false, 
        unitPriceDisplayUSD: "0", unitPriceDisplayVES: "0.00", 
        priceInputCurrency: 'VES' 
    }]);
    
    setIsLoading(false);
  }, [selectedSupplierId, toast, generateUniqueItemId]);


  useEffect(() => {
    loadInitialData();
  }, [loadInitialData]);


  const updateItemsForNewSupplier = useCallback((
    currentItems: PurchaseOrderItemExtended[],
    supplierId: string,
    currentGlobalExchangeRate: number
  ): PurchaseOrderItemExtended[] => {
      const supplier = currentSuppliers.find(s => s.id === supplierId);
      if (!supplier) return currentItems;

      const formatVes = (price: number) => (currentGlobalExchangeRate > 0 ? (price * currentGlobalExchangeRate).toFixed(2) : "0.00");

      return currentItems.map(item => {
          if (item.manualPriceEdit || !item.rawMaterialName) return item;

          let newItemData = { ...item };
          const listToUse = item.priceInputCurrency === 'USD' ? supplier.priceListUSDCash : supplier.priceList;
          let newUnitPrice = item.unitPrice;
          let priceFound = false;

          const priceListItem = listToUse?.find(pli => pli.rawMaterialName === item.rawMaterialName && pli.unit === item.unit);
          if (priceListItem) {
              const currentPrice = getCurrentPriceFromHistory(priceListItem.priceHistory);
              if (currentPrice) {
                  newUnitPrice = currentPrice.price;
                  priceFound = true;
              }
          }

          if (!priceFound) {
              const otherList = item.priceInputCurrency === 'USD' ? supplier.priceList : supplier.priceListUSDCash;
              const otherPriceItem = otherList?.find(pli => pli.rawMaterialName === item.rawMaterialName && pli.unit === item.unit);
              if (otherPriceItem) {
                  const currentPrice = getCurrentPriceFromHistory(otherPriceItem.priceHistory);
                  if (currentPrice) {
                      newUnitPrice = currentPrice.price;
                  }
              }
          }

          newItemData.unitPrice = newUnitPrice;
          newItemData.subtotal = parseFloat(((item.quantity || 0) * newUnitPrice).toFixed(4));
          newItemData.unitPriceDisplayUSD = newUnitPrice.toFixed(4);
          newItemData.unitPriceDisplayVES = formatVes(newUnitPrice);

          return newItemData;
      });
  }, [currentSuppliers]);


  useEffect(() => {
    if (isAnalyzing) return;
    
    const handler = () => {
      if (isEditingPO) {
        const updatedItems = updateItemsForNewSupplier(globalOrderItems, selectedSupplierId, exchangeRate);
        setGlobalOrderItems(updatedItems);
        const updatedSplits = editPaymentSplits.map(split => ({
            ...split,
            items: updateItemsForNewSupplier(split.items || [], selectedSupplierId, exchangeRate)
        }));
        setEditPaymentSplits(updatedSplits);
      } else {
        const updatedItems = updateItemsForNewSupplier(globalOrderItems, selectedSupplierId, exchangeRate);
        setGlobalOrderItems(updatedItems);
        const updatedSplits = newPaymentSplits.map(split => ({
            ...split,
            items: updateItemsForNewSupplier(split.items || [], selectedSupplierId, exchangeRate)
        }));
        setNewPaymentSplits(updatedSplits);
      }
    };

    handler();

  }, [selectedSupplierId, exchangeRate, isAnalyzing]); // Removed dependencies to avoid re-triggering, now it only runs on supplier/rate change.


  useEffect(() => {
    const handleDataUpdate = (event: Event) => {
      const customEvent = event as CustomEvent;
      const key = customEvent.detail?.key;
  
      if (key === KEYS.SUPPLIERS) {
        setCurrentSuppliers([...initialSuppliersData]);
      } else if (key === KEYS.RAW_MATERIAL_OPTIONS) {
        setCurrentRawMaterialOptions(getCurrentRawMaterialOptions());
      } else if (key === KEYS.EXCHANGE_RATE || key === KEYS.EXCHANGE_RATE_HISTORY) {
        const dateToUse = isPODialogOpen ? (isEditingPO ? editOrderDate : orderDate) : new Date();
        setExchangeRate(loadExchangeRate(dateToUse));
      } else if (key === KEYS.ACTIVE_BRANCH_ID) {
        loadInitialData();
      } else if (
        !isPODialogOpen &&
        (key === KEYS.PURCHASE_ORDERS ||
         key === KEYS.RAW_MATERIAL_INVENTORY ||
         key === KEYS.COMPANY_ACCOUNTS ||
         key === KEYS.CUSTOM_CONVERSION_RULES)
      ) {
        loadInitialData();
      }
    };
    window.addEventListener('data-updated', handleDataUpdate);
    return () => {
      window.removeEventListener('data-updated', handleDataUpdate);
    };
  }, [isPODialogOpen, loadInitialData, isEditingPO, orderDate, editOrderDate]);


  useEffect(() => {
    if (isAnalyzing) return;

    const dateToUse = isEditingPO ? editOrderDate : orderDate;
    const currentRate = dateToUse ? loadExchangeRate(dateToUse) : 0;
    if (Math.abs(currentRate - exchangeRate) > 0.0001) {
      setExchangeRate(currentRate);
    }
  }, [
    isAnalyzing,
    isPODialogOpen,
    currentOrderStatus,
    isEditingPO,
    orderDate,
    editOrderDate,
    exchangeRate
  ]);


  const applyFilters = useCallback(() => {
    let filtered = [...allPurchaseOrders];
    
    if (dateRangeFilter?.from) {
      const toDate = dateRangeFilter.to ? endOfDay(dateRangeFilter.to) : endOfDay(dateRangeFilter.from);
      filtered = filtered.filter(po =>
        po.orderDate && isValid(parseISO(po.orderDate)) && isWithinInterval(parseISO(po.orderDate), { start: startOfDay(dateRangeFilter.from!), end: toDate })
      );
    }

    if (filterSupplierId !== ALL_SUPPLIERS_FILTER_VALUE) {
        filtered = filtered.filter(po => po.supplierId === filterSupplierId);
    }
    
    if (filterOrderId.trim() !== '') {
        filtered = filtered.filter(po => po.id.toLowerCase().includes(filterOrderId.trim().toLowerCase()));
    }

    setFilteredPurchaseOrders(filtered);
  }, [allPurchaseOrders, dateRangeFilter, filterSupplierId, filterOrderId]);

  useEffect(() => {
    applyFilters();
  }, [allPurchaseOrders, dateRangeFilter, filterSupplierId, filterOrderId, applyFilters]);


  const calculateItemsTotalCost = useCallback((itemsList: PurchaseOrderItemExtended[]): number => {
    return itemsList.reduce((total, item) => {
        const subtotal = Number(item.subtotal) || 0;
        return total + subtotal;
    }, 0);
  }, []);

  const displayedTotalCost = useMemo(() => {
    if (currentOrderStatus === 'Pagado') {
      const splitsToConsider = isEditingPO ? editPaymentSplits : newPaymentSplits;
      return (splitsToConsider || []).reduce((total, split) => {
        const itemsTotalUSDForSplit = (split.items || []).reduce((sum, item) => sum + (item.subtotal || 0), 0);
        return total + itemsTotalUSDForSplit;
      }, 0);
    }
    return calculateItemsTotalCost(globalOrderItems);
  }, [currentOrderStatus, newPaymentSplits, editPaymentSplits, globalOrderItems, calculateItemsTotalCost, isEditingPO]);


  const resetAddForm = useCallback(() => {
    setNewOrderId('');
    setCurrentEditablePOId('');
    const currentSuppliersList = [...initialSuppliersData];
    const firstSupplierId = currentSuppliersList.length > 0 ? currentSuppliersList[0].id : '';
    setSelectedSupplierId(firstSupplierId);

    const today = new Date();
    setOrderDate(today);
    setExpectedDelivery(today);
    setCurrentOrderStatus('Pagado');
    setNewPONotes('');

    const initialMaterial = currentRawMaterialOptions.length > 0 ? currentRawMaterialOptions[0] : '';
    let initialPriceUSD = 0;
    let initialUnitForNewItem = commonUnitOptions[0] || '';
    const supplierForNew = currentSuppliersList.find(s => s.id === firstSupplierId);

    if (initialMaterial && supplierForNew) {
      const listToUseForNewItem = supplierForNew.priceList;
      const priceListItemForNew = listToUseForNewItem?.find(pli => pli.rawMaterialName === initialMaterial);
      if (priceListItemForNew) {
        const currentPriceEntry = getCurrentPriceFromHistory(priceListItemForNew.priceHistory);
        initialPriceUSD = currentPriceEntry ? currentPriceEntry.price : 0;
        initialUnitForNewItem = priceListItemForNew.unit;
      }
    }
    const currentGlobalItemsIds = (Array.isArray(globalOrderItems) ? globalOrderItems : []).map(it => it.id);
    const rateForReset = loadExchangeRate(today);
    
    setGlobalOrderItems([{
      id: generateUniqueItemId('global-item-reset', currentGlobalItemsIds),
      rawMaterialName: initialMaterial,
      quantity: 0,
      unit: initialUnitForNewItem,
      unitPrice: initialPriceUSD,
      subtotal: 0,
      bestPriceHint: '',
      manualPriceEdit: false,
      unitPriceDisplayUSD: initialPriceUSD.toFixed(4),
      unitPriceDisplayVES: rateForReset > 0 ? (initialPriceUSD * rateForReset).toFixed(2) : "0.00",
      priceInputCurrency: 'VES' 
    }]);

    const activeBranch = getActiveBranchId();
    const initialBranchIdForPayment = activeBranch || (availableBranches.length > 0 ? availableBranches[0].id : '');
    const existingSplitIds = (Array.isArray(newPaymentSplits) ? newPaymentSplits : []).map(s => s.id);
    
    const initialSplitCurrency: 'VES' | 'USD' = 'VES';
    const initialSplitPaymentMethod: PaymentMethodType = 'Transferencia (VES)';
    const initialSplitAccountId: AccountType = 'vesElectronic';

    setNewPaymentSplits([{
      id: generateUniqueItemId('split-reset', existingSplitIds),
      amount: 0,
      currency: initialSplitCurrency,
      paymentMethod: initialSplitPaymentMethod,
      paidToBranchId: initialBranchIdForPayment,
      paidToAccountId: initialSplitAccountId,
      referenceNumber: '',
      items: []
    }]);

    setIsEditingPO(false);
    setEditingPOId(null);
    setOriginalPOForEdit(null);
    setEditPONotes('');
  }, [currentRawMaterialOptions, generateUniqueItemId, globalOrderItems, newPaymentSplits]);


  useEffect(() => {
    if (!isEditingPO && orderDate) {
      setExpectedDelivery(orderDate);
    }
  }, [orderDate, isEditingPO]);

  const handleItemChange = (
    itemIndex: number,
    field: keyof Omit<PurchaseOrderItemExtended, 'id' | 'subtotal' | 'bestPriceHint' | 'manualPriceEdit' | 'unitPrice'> | 'unitPriceDisplayUSD' | 'unitPriceDisplayVES' | 'priceInputCurrency',
    value: string | number,
    splitIndex?: number
  ) => {
    const updateItemsState = (prevItems: PurchaseOrderItemExtended[]) => {
      const newItems = [...prevItems];
      const updatedItem = { ...newItems[itemIndex] };
      const supplier = currentSuppliers.find(s => s.id === selectedSupplierId);
      
      let splitCurrencyForListLookup: 'USD' | 'VES' = updatedItem.priceInputCurrency;
      if (splitIndex !== undefined) {
          const currentSplits = isEditingPO ? editPaymentSplits : newPaymentSplits;
          if (currentSplits[splitIndex]) {
              splitCurrencyForListLookup = currentSplits[splitIndex].currency;
          }
      }
      
      const formatVesPriceWithCurrentRate = (usdPrice: number) => {
        if (exchangeRate > 0 && typeof usdPrice === 'number' && !isNaN(usdPrice)) {
          return (usdPrice * exchangeRate).toFixed(2);
        }
        return "0.00";
      };

      if (field === 'quantity') {
        updatedItem.quantity = Number(value) >= 0 ? Number(value) : 0;
      } else if (field === 'rawMaterialName') {
        updatedItem.rawMaterialName = value as string;
        updatedItem.manualPriceEdit = false;
        let price = 0;
        let itemUnit = commonUnitOptions[0] || '';
        let hint = '';

        if (supplier) {
          const listToUse = splitIndex !== undefined ? (splitCurrencyForListLookup === 'USD' ? supplier.priceListUSDCash : supplier.priceList) : (updatedItem.priceInputCurrency === 'USD' ? supplier.priceListUSDCash : supplier.priceList);
          
          const priceListItem = listToUse?.find(pli => pli.rawMaterialName === updatedItem.rawMaterialName);
          const currentPriceEntry = priceListItem ? getCurrentPriceFromHistory(priceListItem.priceHistory) : null;

          if (priceListItem && currentPriceEntry) {
            price = currentPriceEntry.price;
            itemUnit = priceListItem.unit;
            const bestPriceInfo = getBestPriceInfo(updatedItem.rawMaterialName);
            if (bestPriceInfo && bestPriceInfo.supplierId === supplier.id && bestPriceInfo.originalUnitPrice === currentPriceEntry.price && bestPriceInfo.originalUnit === priceListItem.unit) {
              hint = 'Este proveedor tiene el mejor precio.';
            } else if (bestPriceInfo) {
              hint = `💡 Mejor opción: ${bestPriceInfo.supplierName} a $${bestPriceInfo.originalUnitPrice.toFixed(4)} por ${bestPriceInfo.originalUnit}.`;
            } else {
              hint = 'Precio cargado de lista. No hay otros proveedores para comparar.';
            }
          } else {
            hint = 'No encontrado en la lista de este proveedor. Ingresa el precio manualmente.';
            const bestPriceInfo = getBestPriceInfo(updatedItem.rawMaterialName);
            if (bestPriceInfo) {
                hint += ` Mejor opción: ${bestPriceInfo.supplierName} a $${bestPriceInfo.originalUnitPrice.toFixed(4)} por ${bestPriceInfo.originalUnit}.`;
            }
          }
        }
        updatedItem.unitPrice = price;
        updatedItem.unit = itemUnit;
        updatedItem.bestPriceHint = hint;
        updatedItem.priceInputCurrency = splitIndex !== undefined ? splitCurrencyForListLookup : updatedItem.priceInputCurrency;
        updatedItem.unitPriceDisplayUSD = price.toFixed(4);
        updatedItem.unitPriceDisplayVES = formatVesPriceWithCurrentRate(price);

      } else if (field === 'unit') {
        updatedItem.unit = value as string;
        updatedItem.manualPriceEdit = false;
        let newPriceUSD = 0;
        if (supplier && updatedItem.rawMaterialName) {
          const listToUse = splitIndex !== undefined ? (splitCurrencyForListLookup === 'USD' ? supplier.priceListUSDCash : supplier.priceList) : (updatedItem.priceInputCurrency === 'USD' ? supplier.priceListUSDCash : supplier.priceList);

          const priceListItem = listToUse?.find(pli => pli.rawMaterialName === updatedItem.rawMaterialName && pli.unit === updatedItem.unit);
          if (priceListItem) {
            newPriceUSD = getCurrentPriceFromHistory(priceListItem.priceHistory)?.price || 0;
          } else {
             const anyPriceListItem = listToUse?.find(pli => pli.rawMaterialName === updatedItem.rawMaterialName);
             if(anyPriceListItem) newPriceUSD = getCurrentPriceFromHistory(anyPriceListItem.priceHistory)?.price || 0;
          }
        }
        updatedItem.unitPrice = newPriceUSD;
        updatedItem.priceInputCurrency = splitIndex !== undefined ? splitCurrencyForListLookup : updatedItem.priceInputCurrency;
        updatedItem.unitPriceDisplayUSD = newPriceUSD.toFixed(4);
        updatedItem.unitPriceDisplayVES = formatVesPriceWithCurrentRate(newPriceUSD);

      } else if (field === 'priceInputCurrency') { 
        updatedItem.priceInputCurrency = value as 'USD' | 'VES';
        let newPriceFromList = 0;
        if(supplier && updatedItem.rawMaterialName && updatedItem.unit) {
            const listToUseForNewCurrency = updatedItem.priceInputCurrency === 'USD' ? supplier.priceListUSDCash : supplier.priceList;
            const priceListItem = listToUseForNewCurrency?.find(pli => pli.rawMaterialName === updatedItem.rawMaterialName && pli.unit === updatedItem.unit);
            if(priceListItem) {
                newPriceFromList = getCurrentPriceFromHistory(priceListItem.priceHistory)?.price || 0;
            }
        }
        updatedItem.unitPrice = newPriceFromList;
        updatedItem.manualPriceEdit = false;
        updatedItem.unitPriceDisplayUSD = updatedItem.unitPrice.toFixed(4);
        updatedItem.unitPriceDisplayVES = formatVesPriceWithCurrentRate(updatedItem.unitPrice);


      } else if (field === 'unitPriceDisplayUSD') {
        updatedItem.unitPriceDisplayUSD = String(value);
        if (updatedItem.priceInputCurrency === 'USD') {
          updatedItem.manualPriceEdit = true;
          const newPriceUSD = parseFloat(String(value).replace(/,/g, '.')) || 0;
          updatedItem.unitPrice = newPriceUSD < 0 ? 0 : newPriceUSD;
          updatedItem.unitPriceDisplayVES = formatVesPriceWithCurrentRate(updatedItem.unitPrice);
        }
      } else if (field === 'unitPriceDisplayVES') {
        updatedItem.unitPriceDisplayVES = String(value);
        if (updatedItem.priceInputCurrency === 'VES') {
          updatedItem.manualPriceEdit = true;
          const newPriceVES = parseFloat(String(value).replace(/,/g, '.')) || 0;
          updatedItem.unitPrice = exchangeRate > 0 ? (newPriceVES < 0 ? 0 : newPriceVES / exchangeRate) : 0;
          updatedItem.unitPriceDisplayUSD = updatedItem.unitPrice.toFixed(4);
        }
      }
      
      updatedItem.subtotal = parseFloat(((Number(updatedItem.quantity) || 0) * (Number(updatedItem.unitPrice) || 0)).toFixed(4));
      newItems[itemIndex] = updatedItem;
      return newItems;
    };

    if (splitIndex !== undefined) {
      const setSplitsFunction = isEditingPO ? setEditPaymentSplits : setNewPaymentSplits;
      setSplitsFunction(prevSplits => {
        const newSplits = [...prevSplits];
        if (newSplits[splitIndex]) {
          newSplits[splitIndex].items = updateItemsState(newSplits[splitIndex].items || []);
          const totalItemsUSDForSplit = (newSplits[splitIndex].items || []).reduce((sum, item) => sum + (item.subtotal || 0), 0);
          if (newSplits[splitIndex].currency === 'VES') {
              newSplits[splitIndex].amount = parseFloat((totalItemsUSDForSplit * (newSplits[splitIndex].exchangeRateAtPayment || exchangeRate || 1)).toFixed(2));
          } else { 
              newSplits[splitIndex].amount = parseFloat(totalItemsUSDForSplit.toFixed(2));
          }
        }
        return newSplits;
      });
    } else {
      setGlobalOrderItems(updateItemsState);
    }
  };

  const handleUpdateSupplierPriceListItemManually = useCallback((
    supplierId: string,
    rawMaterialName: string,
    unitPrice: number,
    unit: string,
    listType: 'default' | 'usdCash'
  ) => {
    if (!supplierId || !rawMaterialName || unitPrice < 0 || !unit) {
      toast({
        title: "Datos incompletos",
        description: "No se puede guardar el precio sin proveedor, material, precio y unidad.",
        variant: "destructive"
      });
      return;
    }

    const suppliersToUpdate = [...currentSuppliers];
    const supplierIndex = suppliersToUpdate.findIndex(s => s.id === supplierId);
    if (supplierIndex === -1) {
      toast({ title: "Error", description: "Proveedor no encontrado.", variant: "destructive" });
      return;
    }

    const supplier = { ...suppliersToUpdate[supplierIndex] };
    const priceListName = listType === 'usdCash' ? 'priceListUSDCash' : 'priceList';
    
    if (!Array.isArray(supplier[priceListName])) {
      supplier[priceListName] = [];
    }

    let targetPriceList = [...(supplier[priceListName]!)];
    const itemIndex = targetPriceList.findIndex(item => item.rawMaterialName === rawMaterialName && item.unit === unit);
    const today = format(new Date(), "yyyy-MM-dd");

    if (itemIndex !== -1) {
      const itemToUpdate = { ...targetPriceList[itemIndex] };
      itemToUpdate.priceHistory = itemToUpdate.priceHistory ? [...itemToUpdate.priceHistory] : [];
      const historyIndex = itemToUpdate.priceHistory.findIndex(entry => entry.date === today);

      if (historyIndex !== -1) {
        itemToUpdate.priceHistory[historyIndex].price = unitPrice;
      } else {
        itemToUpdate.priceHistory.push({ date: today, price: unitPrice });
      }
      itemToUpdate.priceHistory.sort((a, b) => compareDesc(parseISO(a.date), parseISO(b.date)));
      targetPriceList[itemIndex] = itemToUpdate;
    } else {
      targetPriceList.push({
        id: `pli-manual-${Date.now()}`,
        rawMaterialName,
        unit,
        priceHistory: [{ date: today, price: unitPrice }],
      });
    }

    supplier[priceListName] = targetPriceList;
    suppliersToUpdate[supplierIndex] = supplier;
    
    saveSuppliersData(suppliersToUpdate);
    setCurrentSuppliers(suppliersToUpdate);
    
    toast({
      title: "Precio Guardado",
      description: `El precio para ${rawMaterialName} se ha guardado en la lista de ${supplier.name}.`,
    });
  }, [currentSuppliers, toast]);

  useEffect(() => {
    if (isAnalyzing) return;
    if (isPODialogOpen && isEditingPO && originalPOForEdit) {
        if (currentOrderStatus === 'Pagado' && originalPOForEdit.status !== 'Pagado') {
            const currentSplits = Array.isArray(editPaymentSplits) ? editPaymentSplits : [];
            const currentGlobalItemsForAutoSplit = Array.isArray(globalOrderItems) ? globalOrderItems : [];

            if ((!currentSplits || currentSplits.length === 0 || currentSplits.every(ps => !ps.items || ps.items.length === 0)) && currentGlobalItemsForAutoSplit.length > 0 && currentGlobalItemsForAutoSplit.some(it => it.rawMaterialName && it.quantity > 0)) {
                const totalGlobalItemsCostUSD = calculateItemsTotalCost(currentGlobalItemsForAutoSplit);
                const activeBranchForPayment = getActiveBranchId() || (availableBranches.length > 0 ? availableBranches[0].id : '');
                
                const existingSplitIds = currentSplits.map(s => s.id);
                
                let defaultSplitCurrency: 'VES' | 'USD' = 'VES';
                let defaultSplitPaymentMethod: PaymentMethodType = 'Transferencia (VES)';
                let defaultSplitAccountId: AccountType = 'vesElectronic';
                
                const supplierDetails = currentSuppliers.find(s => s.id === selectedSupplierId);
                if (supplierDetails?.priceListUSDCash && supplierDetails.priceListUSDCash.length > 0 && exchangeRate > 0) {
                     let usdMatchCount = 0;
                    currentGlobalItemsForAutoSplit.forEach(item => {
                        const usdPriceItem = supplierDetails.priceListUSDCash?.find(pli => pli.rawMaterialName === item.rawMaterialName && pli.unit === item.unit);
                        if (usdPriceItem && getCurrentPriceFromHistory(usdPriceItem.priceHistory)?.price === item.unitPrice) {
                            usdMatchCount++;
                        }
                    });
                    if (usdMatchCount > currentGlobalItemsForAutoSplit.length / 2) {
                        defaultSplitCurrency = 'USD';
                        defaultSplitPaymentMethod = 'Efectivo USD';
                        defaultSplitAccountId = 'usdCash';
                    }
                }

                const newSplitAmount = defaultSplitCurrency === 'VES' ? totalGlobalItemsCostUSD * (exchangeRate || 1) : totalGlobalItemsCostUSD;

                setEditPaymentSplits([{
                    id: generateUniqueItemId(`split-auto-edit`, existingSplitIds),
                    amount: parseFloat(newSplitAmount.toFixed(2)),
                    currency: defaultSplitCurrency,
                    paymentMethod: defaultSplitPaymentMethod,
                    paidToBranchId: activeBranchForPayment,
                    paidToAccountId: defaultSplitAccountId,
                    referenceNumber: '',
                    items: JSON.parse(JSON.stringify(currentGlobalItemsForAutoSplit.filter(it => it.rawMaterialName && it.quantity > 0).map(item => ({
                        id: item.id, rawMaterialName: item.rawMaterialName, quantity: item.quantity, unit: item.unit, unitPrice: Number(item.unitPrice), subtotal: item.subtotal
                    }))))
                }]);
            }
        }
    }
  }, [isAnalyzing, currentOrderStatus, isPODialogOpen, isEditingPO, originalPOForEdit, globalOrderItems, calculateItemsTotalCost, generateUniqueItemId, editPaymentSplits, exchangeRate, currentSuppliers, selectedSupplierId]);

  const isAddingSplitItemRef = useRef(false);
  const handleAddItemToSplit = (splitIndex: number) => {
    if (isAddingSplitItemRef.current) {
      return;
    }
    isAddingSplitItemRef.current = true;
    
    const setSplits = isEditingPO ? setEditPaymentSplits : setNewPaymentSplits;
    const currentSplitsForNewItem = isEditingPO ? editPaymentSplits : newPaymentSplits;
    const targetSplitForNewItem = currentSplitsForNewItem[splitIndex];


    setSplits(prevSplits => {
      const newSplits = [...(Array.isArray(prevSplits) ? prevSplits : [])];
      if (newSplits[splitIndex]) {
        const targetSplit = { ...newSplits[splitIndex] };
        const existingItems = targetSplit.items ? [...targetSplit.items] : [];

        const initialMaterial = currentRawMaterialOptions.length > 0 ? currentRawMaterialOptions[0] : '';
        let initialPriceUSD = 0;
        let initialUnit = commonUnitOptions[0] || '';
        const supplier = currentSuppliers.find(s => s.id === selectedSupplierId);
        if (initialMaterial && supplier) {
            const listToUse = targetSplitForNewItem.currency === 'USD' ? supplier.priceListUSDCash : supplier.priceList;
            const pli = listToUse?.find(p => p.rawMaterialName === initialMaterial);
            if (pli) {
                initialPriceUSD = getCurrentPriceFromHistory(pli.priceHistory)?.price || 0;
                initialUnit = pli.unit;
            }
        }
        
        const currentItemsInThisSplitForIdGen = existingItems.map(it => it.id);
        const newItemId = generateUniqueItemId(`split-item-${splitIndex}-idx${existingItems.length}`, currentItemsInThisSplitForIdGen);

        const newItem: PurchaseOrderItemExtended = {
          id: newItemId,
          rawMaterialName: initialMaterial,
          quantity: 0,
          unit: initialUnit,
          unitPrice: initialPriceUSD,
          subtotal: 0,
          bestPriceHint: '',
          manualPriceEdit: false,
          unitPriceDisplayUSD: initialPriceUSD.toFixed(4),
          unitPriceDisplayVES: exchangeRate > 0 ? (initialPriceUSD * exchangeRate).toFixed(2) : "0.00",
          priceInputCurrency: targetSplitForNewItem.currency
        };

        targetSplit.items = [...existingItems, newItem];
      
        newSplits[splitIndex] = targetSplit;
      }
      
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          isAddingSplitItemRef.current = false;
        });
      });
      return newSplits;
    });
  };


  const handleRemoveItemFromSplit = (splitIndex: number, itemIndex: number) => {
    const setSplits = isEditingPO ? setEditPaymentSplits : setNewPaymentSplits;
    const currentSplitsForRemove = isEditingPO ? editPaymentSplits : newPaymentSplits;
    const targetSplitForRemove = currentSplitsForRemove[splitIndex];

    setSplits(prev => {
      const newSplits = [...(Array.isArray(prev) ? prev : [])];
      if (newSplits[splitIndex] && newSplits[splitIndex].items) {
        newSplits[splitIndex].items = newSplits[splitIndex].items!.filter((_, i) => i !== itemIndex);
        if (newSplits[splitIndex].items!.length === 0) {
            const initialMaterial = currentRawMaterialOptions.length > 0 ? currentRawMaterialOptions[0] : '';
            let initialPriceUSD = 0; let initialUnit = commonUnitOptions[0] || '';
            const supplier = currentSuppliers.find(s => s.id === selectedSupplierId);
            if (initialMaterial && supplier) {
                const listToUse = targetSplitForRemove.currency === 'USD' ? supplier.priceListUSDCash : supplier.priceList;
                const pli = listToUse?.find(p => p.rawMaterialName === initialMaterial);
                if (pli) { initialPriceUSD = getCurrentPriceFromHistory(pli.priceHistory)?.price || 0; initialUnit = pli.unit; }
            }
            const placeholderItemId = generateUniqueItemId(`split-item-${splitIndex}-placeholder`, (newSplits[splitIndex].items || []).map(it => it.id));
            newSplits[splitIndex].items = [{
                id: placeholderItemId,
                rawMaterialName: initialMaterial,
                quantity: 0, unit: initialUnit, unitPrice: initialPriceUSD, subtotal: 0,
                bestPriceHint: '', manualPriceEdit: false,
                unitPriceDisplayUSD: initialPriceUSD.toFixed(4),
                unitPriceDisplayVES: exchangeRate > 0 ? (initialPriceUSD * exchangeRate).toFixed(2) : "0.00",
                priceInputCurrency: targetSplitForRemove.currency
            }];
        }
        const totalItemsUSDForSplit = (newSplits[splitIndex].items || []).reduce((sum, item) => sum + (item.subtotal || 0), 0);
        if (newSplits[splitIndex].currency === 'VES') {
            newSplits[splitIndex].amount = parseFloat((totalItemsUSDForSplit * (newSplits[splitIndex].exchangeRateAtPayment || exchangeRate || 1)).toFixed(2));
        } else {
            newSplits[splitIndex].amount = parseFloat(totalItemsUSDForSplit.toFixed(2));
        }
      }
      return newSplits;
    });
  };

  const handleAddGlobalItem = () => {
    const initialMaterial = currentRawMaterialOptions.length > 0 ? currentRawMaterialOptions[0] : '';
    let initialPriceUSD = 0; let initialUnit = commonUnitOptions[0] || '';
    const supplier = currentSuppliers.find(s => s.id === selectedSupplierId);
    if (initialMaterial && supplier?.priceList) {
        const pli = supplier.priceList.find(p => p.rawMaterialName === initialMaterial);
        if (pli) { initialPriceUSD = getCurrentPriceFromHistory(pli.priceHistory)?.price || 0; initialUnit = pli.unit; }
    }
    const currentGlobalItemsIds = globalOrderItems.map(it => it.id);
    const newId = generateUniqueItemId(`global-item-idx${globalOrderItems.length}`, currentGlobalItemsIds);

    setGlobalOrderItems(prev => [...(Array.isArray(prev) ? prev : []), {
      id: newId,
      rawMaterialName: initialMaterial, quantity: 0, unit: initialUnit,
      unitPrice: initialPriceUSD, subtotal: 0, bestPriceHint: '', manualPriceEdit: false,
      unitPriceDisplayUSD: initialPriceUSD.toFixed(4),
      unitPriceDisplayVES: exchangeRate > 0 ? (initialPriceUSD * exchangeRate).toFixed(2) : "0.00",
      priceInputCurrency: 'VES'
    }]);
  };

  const handleRemoveGlobalItem = (index: number) => {
    setGlobalOrderItems(prev => {
      const newList = (Array.isArray(prev) ? prev : []).filter((_, i) => i !== index);
      if (newList.length === 0) {
        const initialMaterial = currentRawMaterialOptions.length > 0 ? currentRawMaterialOptions[0] : '';
        let initialPriceUSD = 0; let initialUnit = commonUnitOptions[0] || '';
        const supplier = currentSuppliers.find(s => s.id === selectedSupplierId);
        if (initialMaterial && supplier?.priceList) {
            const pli = supplier.priceList.find(p => p.rawMaterialName === initialMaterial);
            if (pli) { initialPriceUSD = getCurrentPriceFromHistory(pli.priceHistory)?.price || 0; initialUnit = pli.unit; }
        }
        const placeholderId = generateUniqueItemId(`global-item-placeholder`, newList.map(it => it.id));
        return [{
            id: placeholderId,
            rawMaterialName: initialMaterial,
            quantity: 0, unit: initialUnit, unitPrice: initialPriceUSD, subtotal: 0,
            bestPriceHint: '', manualPriceEdit: false,
            unitPriceDisplayUSD: initialPriceUSD.toFixed(4),
            unitPriceDisplayVES: exchangeRate > 0 ? (initialPriceUSD * exchangeRate).toFixed(2) : "0.00",
            priceInputCurrency: 'VES'
        }];
      }
      return newList;
    });
  };


  const handleAddPaymentSplit = (formType: 'new' | 'edit') => {
    const setSplits = isEditingPO ? setEditPaymentSplits : setNewPaymentSplits;
    const currentSplits = isEditingPO ? editPaymentSplits : newPaymentSplits;

    const activeBranchForPayment = getActiveBranchId() || (availableBranches.length > 0 ? availableBranches[0].id : '');
    
    const currentSplitsIds = (Array.isArray(currentSplits) ? currentSplits : []).map(sp => sp.id);
    const newSplitId = generateUniqueItemId(`split-idx${(Array.isArray(currentSplits) ? currentSplits : []).length}`, currentSplitsIds);
    
    const initialSplitCurrency: 'VES' | 'USD' = 'VES';
    const initialSplitPaymentMethod: PaymentMethodType = 'Transferencia (VES)';
    const initialSplitAccountId: AccountType = 'vesElectronic';

    setSplits(prev => [...(Array.isArray(prev) ? prev : []), {
        id: newSplitId,
        amount: 0,
        currency: initialSplitCurrency,
        paymentMethod: initialSplitPaymentMethod,
        paidToBranchId: activeBranchForPayment,
        paidToAccountId: initialSplitAccountId,
        referenceNumber: '',
        items: []
    }]);
  };
  const handleRemovePaymentSplit = (id: string, formType: 'new' | 'edit') => {
    const setSplits = isEditingPO ? setEditPaymentSplits : setNewPaymentSplits;
    setSplits(prev => (Array.isArray(prev) ? prev : []).filter(split => split.id !== id));
  };

  const getPaymentMethodsForPOPaymentSplitCurrency = useCallback((currency: 'USD' | 'VES'): PaymentMethodType[] => {
    if (currency === 'USD') return ['Efectivo USD'];
    if (currency === 'VES' && exchangeRate > 0) return ['Pago Móvil (VES)', 'Transferencia (VES)', 'Efectivo VES'];
    if (currency === 'VES' && exchangeRate <= 0) return [];
    return ['Otro'];
  }, [exchangeRate]);

  const getAccountsForPOPaymentSplitMethod = useCallback((currency: 'USD' | 'VES', method: PaymentMethodType): AccountType[] => {
      if (currency === 'USD' && method === 'Efectivo USD') return ['usdCash'];
      if (currency === 'VES' && exchangeRate > 0) {
          if (method === 'Pago Móvil (VES)' || method === 'Transferencia (VES)') return ['vesElectronic'];
          if (method === 'Efectivo VES') return ['vesCash'];
      }
      if ((currency === 'VES' && exchangeRate <= 0) || method === 'Otro') return [];
      return Object.values(accountTypeNames).map((_, idx) => Object.keys(accountTypeNames)[idx] as AccountType);
  }, [exchangeRate]);

  const handlePaymentSplitChange = (id: string, field: keyof Omit<PaymentSplit, 'id' | 'items' | 'amount'>, value: string | number | undefined, formType: 'new' | 'edit') => {
    const setSplits = formType === 'new' ? setNewPaymentSplits : setEditPaymentSplits;
    setSplits(prevSplits => (Array.isArray(prevSplits) ? prevSplits : []).map(split => {
      if (split.id === id) {
        let updatedSplit = { ...split, [field]: value };

        if (field === 'currency') {
          const newCurrency = value as 'USD' | 'VES';
          if (newCurrency === 'USD') {
            updatedSplit.paymentMethod = 'Efectivo USD';
            updatedSplit.paidToAccountId = 'usdCash';
          } else {
            if (updatedSplit.paymentMethod === 'Efectivo USD' || updatedSplit.paymentMethod === 'Otro') { 
                updatedSplit.paymentMethod = 'Transferencia (VES)';
                updatedSplit.paidToAccountId = 'vesElectronic';
            } else if (updatedSplit.paymentMethod === 'Efectivo VES') {
                updatedSplit.paidToAccountId = 'vesCash';
            } else { 
                updatedSplit.paidToAccountId = 'vesElectronic';
            }
          }
          
          const supplier = currentSuppliers.find(s => s.id === selectedSupplierId);
          if (supplier && updatedSplit.items) {
              const listToUseForNewSplitCurrency = newCurrency === 'USD' ? supplier.priceListUSDCash : supplier.priceList;
              const updatedItemsForSplit = updatedSplit.items.map(item => {
                  let newUnitPriceUSD = item.unitPrice;
                  if (!item.manualPriceEdit) {
                      const priceListItem = listToUseForNewSplitCurrency?.find(pli =>
                          pli.rawMaterialName === item.rawMaterialName && pli.unit === item.unit
                      );
                      if (priceListItem) {
                          newUnitPriceUSD = getCurrentPriceFromHistory(priceListItem.priceHistory)?.price || 0;
                      } else {
                          const fallbackList = newCurrency === 'USD' ? supplier.priceList : supplier.priceListUSDCash;
                          const fallbackPriceItem = fallbackList?.find(pli =>
                              pli.rawMaterialName === item.rawMaterialName && pli.unit === item.unit
                          );
                          if (fallbackPriceItem) {
                              newUnitPriceUSD = getCurrentPriceFromHistory(fallbackPriceItem.priceHistory)?.price || 0;
                          }
                      }
                  }
                  return {
                      ...item,
                      priceInputCurrency: newCurrency, 
                      unitPrice: newUnitPriceUSD,
                      unitPriceDisplayUSD: newUnitPriceUSD.toFixed(4),
                      unitPriceDisplayVES: exchangeRate > 0 ? (newUnitPriceUSD * exchangeRate).toFixed(2) : "0.00",
                      subtotal: (item.quantity || 0) * newUnitPriceUSD,
                  };
              });
              updatedSplit.items = updatedItemsForSplit;
              const totalItemsUSD = (updatedSplit.items || []).reduce((sum, item) => sum + (item.subtotal || 0), 0);
              if (updatedSplit.currency === 'VES') {
                  updatedSplit.amount = parseFloat((totalItemsUSD * (updatedSplit.exchangeRateAtPayment || exchangeRate || 1)).toFixed(2));
              } else {
                  updatedSplit.amount = parseFloat(totalItemsUSD.toFixed(2));
              }
          }

        } else if (field === 'paymentMethod') {
          const newMethod = value as PaymentMethodType;
          const availableAccounts = getAccountsForPOPaymentSplitMethod(updatedSplit.currency, newMethod);
          updatedSplit.paidToAccountId = availableAccounts[0] || (updatedSplit.currency === 'USD' ? 'usdCash' : 'vesElectronic');
        }
        if (field === 'paidToBranchId') {
            if (updatedSplit.currency === 'USD') {
                 updatedSplit.paymentMethod = 'Efectivo USD';
                 updatedSplit.paidToAccountId = 'usdCash';
            } else if (updatedSplit.currency === 'VES') {
                if (updatedSplit.paymentMethod === 'Efectivo VES') {
                    updatedSplit.paidToAccountId = 'vesCash';
                } else { 
                    updatedSplit.paymentMethod = 'Transferencia (VES)';
                    updatedSplit.paidToAccountId = 'vesElectronic';
                }
            }
        }
        return updatedSplit;
      }
      return split;
    }));
  };


  const _revertPOFinancialEffects = useCallback((poToRevert: PurchaseOrder, rate: number) => {
    const activeBranchId = getActiveBranchId();
    if (!activeBranchId) {
      console.warn("_revertPOFinancialEffects: No active branch. Skipping.");
      return;
    }
    if (poToRevert.status === 'Pagado') {
      updateRawMaterialInventoryFromOrder(poToRevert, 'subtract');
      updateCompanyAccountAndExpensesForPO(poToRevert, 'subtract', rate, poToRevert);
    }
  }, []);

  const _applyPOFinancialEffects = useCallback((poToApply: PurchaseOrder, rate: number) => {
    const activeBranchId = getActiveBranchId();
    if (!activeBranchId) {
      console.warn("_applyPOFinancialEffects: No active branch. Skipping.");
      return;
    }
    if (poToApply.status === 'Pagado') {
      if (!poToApply.timestamp) poToApply.timestamp = new Date().toISOString();
      updateRawMaterialInventoryFromOrder(poToApply, 'add');
      updateCompanyAccountAndExpensesForPO(poToApply, 'add', rate);
      updateSupplierPriceList(poToApply);
    }
  }, []);

  const handleSubmitPO = () => {
    const activeBranchId = getActiveBranchId();
    if (!activeBranchId) {
        toast({ title: "Error de Configuración", description: "No se ha seleccionado una sede activa para la orden de compra.", variant: "destructive" });
        return;
    }
    setIsSubmitting(true);
    const supplierDetails = currentSuppliers.find(s => s.id === selectedSupplierId);
    const finalPOId = (isEditingPO ? currentEditablePOId : newOrderId).trim();
    if (!finalPOId) { toast({ title: "Error", description: "ID de OC obligatorio.", variant: "destructive" }); setIsSubmitting(false); return; }

    const currentPOsForBranch = loadFromLocalStorageForBranch<PurchaseOrder[]>(KEYS.PURCHASE_ORDERS, activeBranchId);
    if (isEditingPO && originalPOForEdit) {
        if (finalPOId.toLowerCase() !== originalPOForEdit.id.toLowerCase() && currentPOsForBranch.some(po => po.id.toLowerCase() === finalPOId.toLowerCase())) {
            toast({ title: "Error", description: "El nuevo ID de OC ya existe para otra orden en esta sede.", variant: "destructive" });
            setIsSubmitting(false); return;
        }
    } else {
        if (currentPOsForBranch.some(po => po.id.toLowerCase() === finalPOId.toLowerCase())) {
            toast({ title: "Error", description: "ID de OC ya existe en esta sede.", variant: "destructive" });
            setIsSubmitting(false); return;
        }
    }
    const orderDateToUse = isEditingPO ? editOrderDate : orderDate;
    const expectedDeliveryToUse = isEditingPO ? editExpectedDelivery : expectedDelivery;
    
    if (!supplierDetails || !orderDateToUse || !expectedDeliveryToUse) { toast({ title: "Error", description: "Proveedor y fechas obligatorios.", variant: "destructive" }); setIsSubmitting(false); return; }

    let itemsToProcessForPOStorage: PurchaseOrderItem[] = [];
    let calculatedTotalCostUSD = 0;
    let finalPaymentSplits: PaymentSplit[] | undefined = undefined;
    const splitsToProcess = isEditingPO ? editPaymentSplits : newPaymentSplits;


    if (currentOrderStatus === 'Pagado') {
      const validSplits = (Array.isArray(splitsToProcess) ? splitsToProcess : []).filter(split => split.items && split.items.some(item => item.rawMaterialName && Number(item.quantity) > 0 && Number(item.unitPrice) >= 0 && item.unit));
      if (validSplits.length === 0 || validSplits.some(s => !s.items || s.items.length === 0 || !s.items.some(i => i.rawMaterialName && i.quantity > 0))) {
        toast({ title: "Error", description: "Para estado 'Pagado', al menos una forma de pago debe tener ítems válidos con cantidad positiva.", variant: "destructive" });
        setIsSubmitting(false); return;
      }

      finalPaymentSplits = validSplits.map(split => {
          const totalItemsUSDForThisSplit = (split.items || []).reduce((sum, item) => sum + (item.subtotal || 0),0);
          let splitAmountInSplitCurrency;
          if (split.currency === 'VES') {
              splitAmountInSplitCurrency = totalItemsUSDForThisSplit * (split.exchangeRateAtPayment || exchangeRate || 1);
          } else { 
              splitAmountInSplitCurrency = totalItemsUSDForThisSplit;
          }
          return {
            ...split,
            amount: parseFloat(splitAmountInSplitCurrency.toFixed(2)),
            items: (split.items || []).filter(item => item.rawMaterialName && item.quantity > 0).map(item => ({
              id: item.id, rawMaterialName: item.rawMaterialName, quantity: item.quantity, unit: item.unit, unitPrice: Number(item.unitPrice), subtotal: item.subtotal
            }))
        }
      });

      itemsToProcessForPOStorage = finalPaymentSplits.flatMap(split => split.items || []);
      calculatedTotalCostUSD = itemsToProcessForPOStorage.reduce((sum, item) => sum + (item.subtotal || 0), 0);


      if (finalPaymentSplits.some(s => {
          const ref = s.referenceNumber?.trim();
          return (s.paymentMethod === 'Pago Móvil (VES)' || s.paymentMethod === 'Transferencia (VES)') && ref && !/^\d{6}$/.test(ref);
        })) {
        toast({ title: "Error de Referencia", description: "Si se ingresa una referencia para Pago Móvil/Transferencia, debe ser de 6 dígitos.", variant: "destructive" });
        setIsSubmitting(false); return;
      }
    } else {
      const validGlobalItems = (Array.isArray(globalOrderItems) ? globalOrderItems : []).filter(item => item.rawMaterialName && Number(item.quantity) > 0 && Number(item.unitPrice) >= 0 && item.unit);
      if (validGlobalItems.length === 0) {
        toast({ title: "Error", description: "Añada artículos válidos a la orden.", variant: "destructive" });
        setIsSubmitting(false); return;
      }
      itemsToProcessForPOStorage = validGlobalItems.map(item => ({ id: item.id, rawMaterialName: item.rawMaterialName, quantity: item.quantity, unit: item.unit, unitPrice: Number(item.unitPrice), subtotal: item.subtotal }));
      calculatedTotalCostUSD = calculateItemsTotalCost(validGlobalItems);
    }
     if (itemsToProcessForPOStorage.length === 0) {
        toast({ title: "Error", description: "La orden debe tener al menos un artículo válido.", variant: "destructive" });
        setIsSubmitting(false); return;
    }


    let updatedPOs;
    const currentGlobalRate = loadExchangeRate(orderDateToUse);
    const currentTimestamp = new Date().toISOString();
    const finalNotes = isEditingPO ? editPONotes : newPONotes;

    if (isEditingPO && editingPOId && originalPOForEdit) {
      _revertPOFinancialEffects(originalPOForEdit, currentGlobalRate);
      
      const updatedPOData: PurchaseOrder = {
        ...originalPOForEdit,
        id: finalPOId, supplierId: selectedSupplierId, supplierName: supplierDetails.name,
        orderDate: format(orderDateToUse, "yyyy-MM-dd"),
        expectedDelivery: format(expectedDeliveryToUse || new Date(), "yyyy-MM-dd"),
        items: currentOrderStatus !== 'Pagado' ? itemsToProcessForPOStorage : [],
        totalCost: calculatedTotalCostUSD, status: currentOrderStatus,
        paymentSplits: finalPaymentSplits?.map(split => ({ 
            ...split,
            exchangeRateAtPayment: split.currency === 'VES' ? (split.exchangeRateAtPayment || currentGlobalRate || undefined) : undefined,
        })),
        timestamp: currentOrderStatus === 'Pagado' ? (originalPOForEdit.timestamp && originalPOForEdit.status === 'Pagado' ? originalPOForEdit.timestamp : currentTimestamp) : undefined,
        exchangeRateOnOrderDate: currentGlobalRate,
        notes: finalNotes.trim() || undefined,
      };

      _applyPOFinancialEffects(updatedPOData, currentGlobalRate);
      
      const filteredPOs = currentPOsForBranch.filter(p => p.id !== originalPOForEdit.id);
      updatedPOs = [updatedPOData, ...filteredPOs];
      toast({ title: "Éxito", description: "OC actualizada." });
    } else {
      const newPO: PurchaseOrder = {
        id: finalPOId, supplierId: selectedSupplierId, supplierName: supplierDetails.name,
        orderDate: format(orderDateToUse, "yyyy-MM-dd"),
        expectedDelivery: format(expectedDeliveryToUse || new Date(), "yyyy-MM-dd"),
        items: currentOrderStatus !== 'Pagado' ? itemsToProcessForPOStorage : [],
        totalCost: calculatedTotalCostUSD, status: currentOrderStatus,
        paymentSplits: finalPaymentSplits?.map(split => ({ 
            ...split,
            exchangeRateAtPayment: split.currency === 'VES' ? (split.exchangeRateAtPayment || currentGlobalRate || undefined) : undefined,
        })),
        timestamp: currentOrderStatus === 'Pagado' ? currentTimestamp : undefined,
        exchangeRateOnOrderDate: currentGlobalRate,
        notes: finalNotes.trim() || undefined,
      };
      _applyPOFinancialEffects(newPO, currentGlobalRate);
      updatedPOs = [newPO, ...currentPOsForBranch];
      toast({ title: "Éxito", description: `OC ${newPO.status} creada.` });
    }
    const sortedPOs = updatedPOs.sort((a,b) => {
        const dateA = a.orderDate && isValid(parseISO(a.orderDate)) ? parseISO(a.orderDate).getTime() : 0;
        const dateB = b.orderDate && isValid(parseISO(b.orderDate)) ? parseISO(b.orderDate).getTime() : 0;
        if (dateA === 0 && dateB === 0) return 0;
        if (dateA === 0) return 1;
        if (dateB === 0) return -1;
        return dateB - dateA;
    });
    savePurchaseOrdersData(activeBranchId, sortedPOs);
    setAllPurchaseOrders(sortedPOs);
    setIsPODialogOpen(false); resetAddForm(); setIsSubmitting(false);
  };


  const handleMarkAsPaid = (poId: string) => {
    const poToEdit = allPurchaseOrders.find(p => p.id === poId);
    if (poToEdit) {
        if (poToEdit.status === 'Pagado') { toast({title: "Info", description: "Ya pagada.", variant: "default"}); return; }
        handleOpenEditDialog(poToEdit);
        setTimeout(() => {
            setCurrentOrderStatus('Pagado');
            const itemsForSplit = Array.isArray(editPaymentSplits) ? editPaymentSplits : [];
            const itemsFromNonPaidOrder = poToEdit.items || [];


            if (poToEdit.status !== 'Pagado' && itemsFromNonPaidOrder.length > 0 && itemsFromNonPaidOrder.some(it => it.rawMaterialName && it.quantity > 0)) {
                const totalOrderItemsCostUSD = itemsFromNonPaidOrder.reduce((sum, item) => sum + item.subtotal, 0);
                const activeBranchForPayment = getActiveBranchId() || (availableBranches.length > 0 ? availableBranches[0].id : '');
                
                const currentSplitsIds = itemsForSplit.map(sp => sp.id);
                
                let defaultSplitCurrency: 'VES' | 'USD' = 'VES';
                let defaultSplitPaymentMethod: PaymentMethodType = 'Transferencia (VES)';
                let defaultSplitAccountId: AccountType = 'vesElectronic';
                
                const supplierDetails = currentSuppliers.find(s => s.id === poToEdit.supplierId);
                if (supplierDetails?.priceListUSDCash && supplierDetails.priceListUSDCash.length > 0 && exchangeRate > 0) {
                     let usdMatchCount = 0;
                    itemsFromNonPaidOrder.forEach(item => {
                        const usdPriceItem = supplierDetails.priceListUSDCash?.find(pli => pli.rawMaterialName === item.rawMaterialName && pli.unit === item.unit);
                        if (usdPriceItem && getCurrentPriceFromHistory(usdPriceItem.priceHistory)?.price === item.unitPrice) {
                            usdMatchCount++;
                        }
                    });
                    if (usdMatchCount > itemsFromNonPaidOrder.length / 2) {
                        defaultSplitCurrency = 'USD';
                        defaultSplitPaymentMethod = 'Efectivo USD';
                        defaultSplitAccountId = 'usdCash';
                    }
                }

                const newSplitAmount = defaultSplitCurrency === 'VES' ? totalOrderItemsCostUSD * (exchangeRate || 1) : totalOrderItemsCostUSD;

                setEditPaymentSplits([{
                    id: generateUniqueItemId(`split-markpaid-auto`, currentSplitsIds),
                    amount: parseFloat(newSplitAmount.toFixed(2)),
                    currency: defaultSplitCurrency,
                    paymentMethod: defaultSplitPaymentMethod,
                    paidToBranchId: activeBranchForPayment,
                    paidToAccountId: defaultSplitAccountId,
                    referenceNumber: '',
                    items: JSON.parse(JSON.stringify(itemsFromNonPaidOrder.filter(it => it.rawMaterialName && it.quantity > 0).map(item => ({
                        id: item.id, rawMaterialName: item.rawMaterialName, quantity: item.quantity, unit: item.unit, unitPrice: Number(item.unitPrice), subtotal: item.subtotal
                    }))))
                }]);
            } else if (!itemsForSplit || itemsForSplit.length === 0 || itemsForSplit.every(ps => !ps.items || ps.items.length === 0)) {
                const activeBranchForPayment = getActiveBranchId() || (availableBranches.length > 0 ? availableBranches[0].id : '');
                const currentSplitsIds = itemsForSplit.map(sp => sp.id);
                 setEditPaymentSplits([{
                    id: generateUniqueItemId(`split-markpaid-empty`, currentSplitsIds),
                    amount: 0, currency: 'VES', paymentMethod: 'Transferencia (VES)',
                    paidToBranchId: activeBranchForPayment, paidToAccountId: 'vesElectronic',
                    referenceNumber: '', items: []
                }]);
            }
            toast({title: "Acción", description: "Estado cambiado a 'Pagado'. Verifica/Ajusta las formas de pago e ítems asociados y guarda."});
        }, 150);
    } else { toast({title: "Error", description: "OC no encontrada.", variant: "destructive"});}
  };

  const handleOpenEditDialog = (po: PurchaseOrder) => {
    setIsEditingPO(true); setEditingPOId(po.id); setCurrentEditablePOId(po.id);
    const originalPoDeepClone = JSON.parse(JSON.stringify(po));
    setOriginalPOForEdit(originalPoDeepClone);

    setSelectedSupplierId(po.supplierId || '');
    setEditOrderDate(po.orderDate && isValid(parseISO(po.orderDate)) ? parseISO(po.orderDate) : new Date());
    setEditExpectedDelivery(po.expectedDelivery && isValid(parseISO(po.expectedDelivery)) ? parseISO(po.expectedDelivery) : new Date());
    setCurrentOrderStatus(po.status);
    setEditPONotes(po.notes || '');

    if (po.status === 'Pagado' && po.paymentSplits && po.paymentSplits.length > 0) {
        const processedSplitsData = JSON.parse(JSON.stringify(po.paymentSplits.map((split, splitIndex) => {
            const itemsInThisSplitFromPO = split.items || [];
            const processedItemsForThisSplit: PurchaseOrderItemExtended[] = [];
            const idsUsedInThisSplitMapping = new Set<string>();

            itemsInThisSplitFromPO.forEach((item: PurchaseOrderItem, itemIndex: number) => {
                let itemId = item.id;
                const currentIdsInProcessedItems = processedItemsForThisSplit.map(pi => pi.id);
                if (!itemId || idsUsedInThisSplitMapping.has(itemId) || currentIdsInProcessedItems.includes(itemId)) {
                    itemId = generateUniqueItemId(`edit-split${splitIndex}-item${itemIndex}`, [...currentIdsInProcessedItems, ...Array.from(idsUsedInThisSplitMapping)]);
                }
                idsUsedInThisSplitMapping.add(itemId);
                processedItemsForThisSplit.push({
                    id: itemId,
                    rawMaterialName: item.rawMaterialName,
                    quantity: item.quantity,
                    unit: item.unit,
                    unitPrice: Number(item.unitPrice),
                    subtotal: item.subtotal,
                    unitPriceDisplayUSD: (Number(item.unitPrice) || 0).toFixed(4),
                    unitPriceDisplayVES: exchangeRate > 0 ? ((Number(item.unitPrice) || 0) * exchangeRate).toFixed(2) : "0.00",
                    priceInputCurrency: split.currency,
                    manualPriceEdit: false,
                    bestPriceHint: ''
                });
            });
            const existingSplitIdsForIdGen = po.paymentSplits?.map(s => s.id).filter(Boolean) as string[] || [];
            return {
                id: split.id || generateUniqueItemId(`edit-split${splitIndex}`, existingSplitIdsForIdGen),
                amount: parseFloat(split.amount.toFixed(2)),
                currency: split.currency,
                paymentMethod: split.paymentMethod,
                exchangeRateAtPayment: split.exchangeRateAtPayment,
                paidToBranchId: split.paidToBranchId,
                paidToAccountId: split.paidToAccountId,
                referenceNumber: split.referenceNumber,
                items: processedItemsForThisSplit
            };
        })));
        setEditPaymentSplits(processedSplitsData);
        const currentGlobalItemsIds = (Array.isArray(globalOrderItems) ? globalOrderItems : []).map(it => it.id);
        setGlobalOrderItems([{ id: generateUniqueItemId('global-item-placeholder-edit', currentGlobalItemsIds), rawMaterialName: '', quantity: 0, unit: commonUnitOptions[0] || '', unitPrice: 0, subtotal: 0, bestPriceHint: '', manualPriceEdit: false, unitPriceDisplayUSD: "0", unitPriceDisplayVES: "0.00", priceInputCurrency: 'VES' }]);
    } else {
        const itemsFromPO = (po.items || []).map((itemOriginal, idx) => {
            const item = JSON.parse(JSON.stringify(itemOriginal));
            let itemId = item.id;
            const existingItemIdsInPo = (po.items || []).map(i => i.id).filter(Boolean);
            const itemsFromPOMap = new Map();
            (po.items || []).forEach(i => itemsFromPOMap.set(i.id, (itemsFromPOMap.get(i.id) || 0) + 1));
            if (!itemId || itemsFromPOMap.get(itemId) > 1) {
                itemId = generateUniqueItemId(`edit-gitem-${idx}-${Date.now().toString().slice(-5)}`, []);
            }
            const poUnitPrice = Number(item.unitPrice);
            const poQuantity = Number(item.quantity);
            const validUnitPrice = !isNaN(poUnitPrice) && isFinite(poUnitPrice) ? poUnitPrice : 0;
            const validQuantity = !isNaN(poQuantity) && isFinite(poQuantity) ? poQuantity : 0;
            const poSubtotal = Number(item.subtotal);
            const calculatedSubtotal = !isNaN(poSubtotal) && isFinite(poSubtotal) ? poSubtotal : (validUnitPrice * validQuantity);

            return {
                id: itemId,
                rawMaterialName: item.rawMaterialName || '',
                quantity: validQuantity,
                unit: item.unit || (commonUnitOptions[0] || ''),
                unitPrice: validUnitPrice,
                subtotal: parseFloat(calculatedSubtotal.toFixed(4)),
                unitPriceDisplayUSD: validUnitPrice.toFixed(4),
                unitPriceDisplayVES: exchangeRate > 0 ? (validUnitPrice * exchangeRate).toFixed(2) : "0.00",
                priceInputCurrency: 'USD' as 'USD' | 'VES',
                manualPriceEdit: true,
                bestPriceHint: ''
            };
        });

        if (itemsFromPO.length > 0) {
            setGlobalOrderItems(itemsFromPO);
        } else {
            const currentGlobalItemsIds = (Array.isArray(globalOrderItems) ? globalOrderItems : []).map(it => it.id);
            setGlobalOrderItems([{
                id: generateUniqueItemId('global-item-placeholder-edit-noitems', currentGlobalItemsIds),
                rawMaterialName: '',
                quantity: 0,
                unit: commonUnitOptions[0] || '',
                unitPrice: 0,
                subtotal: 0,
                unitPriceDisplayUSD: "0.0000",
                unitPriceDisplayVES: "0.00",
                priceInputCurrency: 'USD' as 'USD' | 'VES',
                manualPriceEdit: false,
                bestPriceHint: ''
            }]);
        }
        
        const activeBranchForPayment = getActiveBranchId() || (availableBranches.length > 0 ? availableBranches[0].id : '');
        const initialSplitsForEdit = (po.paymentSplits && po.paymentSplits.length > 0)
            ? JSON.parse(JSON.stringify(po.paymentSplits.map((ps, splitIndex) => { /* ... (mapeo complejo de paymentSplits) ... */ }))) // Mantener la lógica actual si existe
            : [{
                id: generateUniqueItemId(`split-default-edit-nonpaid-${Date.now().toString().slice(-4)}`, []),
                amount: 0, currency: 'VES' as 'USD' | 'VES', paymentMethod: 'Transferencia (VES)' as PaymentMethodType,
                paidToBranchId: activeBranchForPayment, paidToAccountId: 'vesElectronic' as AccountType,
                referenceNumber: '', items: []
            }];
        setEditPaymentSplits(initialSplitsForEdit);
    }
    setIsPODialogOpen(true);
  };

  const handleOpenViewDialog = (po: PurchaseOrder) => { setPoToViewDetails(po); setIsViewPODialogOpen(true); };
  const handleOpenDeleteDialog = (poId: string) => { setPoToDeleteId(poId); setIsDeleteConfirmDialogOpen(true); };
  const handleConfirmDelete = () => {
    const activeBranchId = getActiveBranchId();
    if (!activeBranchId) { toast({ title: "Error", description: "No hay sede activa.", variant: "destructive" }); return; }
    setIsSubmitting(true);
    if (poToDeleteId) {
      const currentPOsForBranch = loadFromLocalStorageForBranch<PurchaseOrder[]>(KEYS.PURCHASE_ORDERS, activeBranchId);
      const poToDeleteDetails = currentPOsForBranch.find(p => p.id === poToDeleteId);
      if (poToDeleteDetails) {
        _revertPOFinancialEffects(poToDeleteDetails, exchangeRate);
      }
      const updatedPOs = currentPOsForBranch.filter(p => p.id !== poToDeleteId).sort((a,b) => {
        const dateA = a.orderDate && isValid(parseISO(a.orderDate)) ? parseISO(a.orderDate).getTime() : 0;
        const dateB = b.orderDate && isValid(parseISO(b.orderDate)) ? parseISO(b.orderDate).getTime() : 0;
        if (dateA === 0 && dateB === 0) return 0; if (dateA === 0) return 1; if (dateB === 0) return -1; return dateB - dateA;
    });
      savePurchaseOrdersData(activeBranchId, updatedPOs); setAllPurchaseOrders(updatedPOs);
      toast({ title: "Éxito", description: "OC eliminada." });
      setIsDeleteConfirmDialogOpen(false); setPoToDeleteId(null);
    }
    setIsSubmitting(false);
  };

  const formatItemsForDisplay = (itemsList?: PurchaseOrderItem[]) => {
    if (!Array.isArray(itemsList) || itemsList.length === 0) return '-';
    return itemsList.map(item => `${item.rawMaterialName} (${item.quantity} ${item.unit})`).join('; ');
  };

  const formatPaymentSplitsForDisplay = (splits?: PaymentSplit[]) => {
    if (!Array.isArray(splits) || splits.length === 0) return '-';
    return splits.map(split => {
      const itemsDesc = split.items && split.items.length > 0 ? `(${split.items.length} art.)` : '(Sin art.)';
      const rate = split.currency === 'VES' ? (split.exchangeRateAtPayment || exchangeRate || 0) : 0;
      const amountOfSplitInUSD = split.items && split.items.length > 0
                                 ? split.items.reduce((sum, item) => sum + (item.subtotal || 0), 0)
                                 : (split.currency === 'USD' ? split.amount : (rate > 0 ? split.amount / rate : 0));

      return `${split.paymentMethod} ${split.currency} ${split.amount.toFixed(2)} ($${amountOfSplitInUSD.toFixed(2)} USD) ${itemsDesc}`;
    }).join('; ');
  };


  const handleAddNewRawMaterial = () => {
    if (!newMaterialName.trim()) { toast({ title: "Error", description: "Nombre vacío.", variant: "destructive"}); return; }
    if (addRawMaterialOption(newMaterialName.trim())) {
      setCurrentRawMaterialOptions(getCurrentRawMaterialOptions());
      toast({ title: "Éxito", description: `Materia "${newMaterialName.trim()}" añadida.`}); setNewMaterialName('');
    } else { toast({ title: "Info", description: `Materia "${newMaterialName.trim()}" ya existe.`, variant: "default"}); }
  };

  const openDeleteMaterialConfirm = (option: string) => { setMaterialToDelete(option); setIsDeleteMaterialConfirmOpen(true); };
  const handleConfirmDeleteMaterial = () => {
    if (materialToDelete) {
      removeRawMaterialOption(materialToDelete);
      setCurrentRawMaterialOptions(getCurrentRawMaterialOptions());
      toast({ title: "Éxito", description: `Materia "${materialToDelete}" eliminada.`});
      setMaterialToDelete(null); setIsDeleteMaterialConfirmOpen(false);
    }
  };

  const handleFilterApply = () => { applyFilters(); };
  const handleClearFilters = () => { 
    setDateRangeFilter(undefined); 
    setFilterSupplierId(ALL_SUPPLIERS_FILTER_VALUE);
    setFilterOrderId('');
  };

  const getReportFilename = (baseName: string): string => {
    const today = format(new Date(), "yyyy-MM-dd");
    let branchSuffix = '';
    const currentBranchId = getActiveBranchId();
    if (baseName.includes("gastos") || baseName.includes("stock") || baseName.includes("materia_prima") || baseName.includes("ordenes_compra") || baseName.includes("merma") || baseName.includes("perdidas")) {
        if (currentBranchId) branchSuffix = `_${currentBranchId}`;
    }

    if (dateRangeFilter?.from) {
      const fromDate = format(dateRangeFilter.from, "yyyy-MM-dd");
      if (dateRangeFilter.to) {
        const toDate = format(dateRangeFilter.to, "yyyy-MM-dd");
        return `${baseName}${branchSuffix}_${fromDate}_a_${toDate}.pdf`;
      }
      return `${baseName}${branchSuffix}_${fromDate}.pdf`;
    }
    return `${baseName}${branchSuffix}_general_${today}.pdf`;
  };

  const generatePurchaseOrderPDF = async (po: PurchaseOrder) => {
    const { default: jsPDF } = await import('jspdf');
    await import('jspdf-autotable');

    const supplier = currentSuppliers.find(s => s.id === po.supplierId);
    const doc = new jsPDF() as jsPDFWithAutoTable;

    const rateToUseForPdf = (po.exchangeRateOnOrderDate && po.exchangeRateOnOrderDate > 0)
        ? po.exchangeRateOnOrderDate
        : exchangeRate; 

    const formatVesForPdf = (usdPrice: number) => {
        if (rateToUseForPdf > 0 && typeof usdPrice === 'number' && !isNaN(usdPrice)) {
            return `Bs. ${(usdPrice * rateToUseForPdf).toFixed(2)}`;
        }
        return "Bs. --";
    };
    
    doc.setFontSize(18); doc.text("Panificadora Valladares", 14, 22);
    doc.setFontSize(12); doc.text("Orden de Compra", 14, 30);
    doc.setFontSize(11); doc.text(`OC #: ${po.id}`, 14, 38);
    doc.text(`Fecha de Orden: ${po.orderDate && isValid(parseISO(po.orderDate)) ? format(parseISO(po.orderDate), "dd/MM/yyyy", { locale: es }) : 'N/A'}`, 14, 44);
    doc.text(`Entrega Estimada: ${po.expectedDelivery && isValid(parseISO(po.expectedDelivery)) ? format(parseISO(po.expectedDelivery), "dd/MM/yyyy", { locale: es }) : 'N/A'}`, 14, 50);
    const currentBranchName = availableBranches.find(b => b.id === getActiveBranchId())?.name || 'Sede Desconocida';
    doc.text(`Sede de Compra: ${currentBranchName}`, 14, 56);
    doc.text(`Tasa de Cambio Aplicada (USD/VES): ${rateToUseForPdf > 0 ? rateToUseForPdf.toFixed(2) : 'No disponible'}`, 14, 62);


    let startYContent = 72;
    if (supplier) {
      doc.text(`Proveedor: ${supplier.name}`, 14, startYContent); startYContent += 6;
      if (supplier.contactPerson) {doc.text(`Atn: ${supplier.contactPerson}`, 14, startYContent); startYContent += 6;}
      if (supplier.phone) {doc.text(`Tel: ${supplier.phone}`, 14, startYContent); startYContent += 6;}
      if (supplier.email) {doc.text(`Email: ${supplier.email}`, 14, startYContent); startYContent += 6;}
    } else { doc.text(`Proveedor: ${po.supplierName || 'Desconocido'}`, 14, startYContent); startYContent += 6;}
    
    if (po.notes) {
      startYContent += 2;
      doc.setFontSize(11);
      doc.setFont("helvetica", "bold");
      doc.text("Observaciones:", 14, startYContent);
      startYContent += 6;
      doc.setFont("helvetica", "normal");
      doc.setFontSize(10);
      const splitNotes = doc.splitTextToSize(po.notes, 180);
      doc.text(splitNotes, 14, startYContent);
      startYContent += (splitNotes.length * 5) + 4;
    } else {
        startYContent += 2;
    }


    if (po.status === 'Pagado' && po.paymentSplits && po.paymentSplits.length > 0) {
        doc.setFontSize(10);
        doc.text("Formas de Pago y Artículos:", 14, startYContent); startYContent += 7;

        po.paymentSplits.forEach((split, splitIndex) => {
            doc.setFont("helvetica", "bold");
            doc.text(`Forma de Pago ${splitIndex + 1}: ${split.paymentMethod} (${split.currency})`, 14, startYContent);
            doc.setFont("helvetica", "normal");
            startYContent += 5;

            const splitItemsTotalUSD = (split.items || []).reduce((s, i) => s + (i.subtotal || 0), 0);
            const declaredPaymentAmountDisplay = split.currency === 'USD' ? `$${split.amount.toFixed(2)}` : `Bs.${split.amount.toFixed(2)}`;
            
            const rateForThisSplitDisplay = split.currency === 'VES' ? (split.exchangeRateAtPayment || rateToUseForPdf) : rateToUseForPdf;
            const declaredPaymentAmountInUSD = split.currency === 'USD' 
                ? split.amount 
                : (rateForThisSplitDisplay > 0 ? split.amount / rateForThisSplitDisplay : 0);


            doc.text(`  Monto Pago Declarado: ${declaredPaymentAmountDisplay} (Equiv. ~$${declaredPaymentAmountInUSD.toFixed(2)} USD @ ${rateForThisSplitDisplay > 0 ? rateForThisSplitDisplay.toFixed(2) : 'N/A'})`, 16, startYContent);
            startYContent += 5;
            doc.text(`  Suma de Ítems en este Pago (USD): $${splitItemsTotalUSD.toFixed(2)}`, 16, startYContent);
            startYContent += 5;

            doc.text(`  Cuenta: ${accountTypeNames[split.paidToAccountId]} (Sede: ${availableBranches.find(b=>b.id===split.paidToBranchId)?.name || 'N/A'})`, 16, startYContent);
            if (split.referenceNumber) { startYContent += 5; doc.text(`  Referencia: ${split.referenceNumber}`, 16, startYContent); }
            startYContent += 7;

            const headItems = [["Material", "Cantidad", "Unidad", "P.Unit(USD)", "Subtotal(USD)"]];
            const bodyItems = (split.items || []).map(item => ([ item.rawMaterialName, item.quantity, item.unit, `$${item.unitPrice.toFixed(4)}`, `$${item.subtotal.toFixed(4)}` ]));
            if (bodyItems.length > 0) {
                doc.autoTable({
                    startY: startYContent, head: headItems, body: bodyItems, theme: 'grid', headStyles: { fillColor: [200, 200, 220], fontSize: 9 }, bodyStyles: { fontSize: 8 },
                    didDrawPage: (data: any) => { startYContent = data.cursor?.y ? data.cursor.y + 5 : 20; }
                });
                startYContent = (doc as any).lastAutoTable.finalY + 10;
            } else {
                doc.text("  (Sin artículos asignados a esta forma de pago)", 16, startYContent); startYContent += 7;
            }
        });
    } else {
        const head = [["Material", "Cantidad", "Unidad", "P.Unit(USD)", "Subtotal(USD)"]];
        const body = po.items.map(item => ([ item.rawMaterialName, item.quantity, item.unit, `$${item.unitPrice.toFixed(4)}`, `$${item.subtotal.toFixed(4)}` ]));
        doc.autoTable({ startY: startYContent, head: head, body: body, theme: 'striped', headStyles: { fillColor: [224, 122, 95] }, didDrawPage: function (data: any) { const pageCount = doc.getNumberOfPages ? doc.getNumberOfPages() : (doc.internal as any).getNumberOfPages(); doc.setFontSize(10); doc.text(`Página ${doc.getCurrentPageInfo ? doc.getCurrentPageInfo().pageNumber : (doc.internal as any).getCurrentPageInfo().pageNumber} de ${pageCount}`, (data.settings.margin as any).left || 14, (doc.internal as any).pageSize.height - 10); startYContent = data.cursor?.y ? data.cursor.y + 5 : 20; } });
        startYContent = (doc as any).lastAutoTable.finalY || startYContent + 20;
    }

    const finalY = startYContent;
    doc.setFontSize(12); doc.text(`Estado: ${po.status}`, 14, finalY + 10);

    let totalVesPaid = 0;
    let totalUsdPaid = 0;
    if (po.status === 'Pagado' && po.paymentSplits && po.paymentSplits.length > 0) {
        po.paymentSplits.forEach(split => {
            if (split.currency === 'VES') totalVesPaid += split.amount;
            else if (split.currency === 'USD') totalUsdPaid += split.amount;
        });
    }
    let summaryStartY = finalY + 18;
    if (totalVesPaid > 0) { doc.setFontSize(10); doc.text(`Total Pagado (VES): Bs. ${totalVesPaid.toFixed(2)}`, 14, summaryStartY); summaryStartY +=6; }
    if (totalUsdPaid > 0) { doc.setFontSize(10); doc.text(`Total Pagado (USD): $${totalUsdPaid.toFixed(2)}`, 14, summaryStartY); summaryStartY +=6; }


    doc.setFontSize(14); doc.setFont("helvetica", "bold"); doc.text(`Neto Factura (USD): $${po.totalCost.toFixed(4)}`, 14, summaryStartY);
    if (rateToUseForPdf > 0) { doc.setFont("helvetica", "normal"); doc.setFontSize(10); doc.text(`Equivalente Neto Factura (VES): ${formatVesForPdf(po.totalCost)}`, 14, summaryStartY + 6); }
    doc.save(getReportFilename(`oc_${getActiveBranchId() || 'general'}_${po.id}`));
    toast({ title: "OC Generada", description: `OC ${po.id}.pdf descargada.` });
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.files && event.target.files[0]) {
      setInvoiceFile(event.target.files[0]);
    } else {
      setInvoiceFile(null);
    }
  };

  const handleAnalyzeInvoice = async () => {
    if (!invoiceFile) {
        toast({ title: "Sin archivo", description: "Por favor, selecciona un archivo de imagen.", variant: "destructive" });
        return;
    }
    setIsAnalyzing(true);
    setIsSubmitting(true);
    
    try {
        const reader = new FileReader();
        reader.readAsDataURL(invoiceFile);
        reader.onload = async () => {
            try {
                const invoiceImageUri = reader.result as string;

                const analysisInput: ProcessInvoiceInput = {
                  invoiceImageUri,
                  availableSuppliers: currentSuppliers.map(s => s.name),
                  availableRawMaterials: currentRawMaterialOptions,
                };
                
                const response = await processInvoice(analysisInput);
                
                const supplierFromAI = response.supplierName ? currentSuppliers.find(s => s.name === response.supplierName) : null;
                const dateFromAI = response.orderDate && isValid(parseISO(response.orderDate)) ? parseISO(response.orderDate) : undefined;
                if(dateFromAI) dateFromAI.setMinutes(dateFromAI.getMinutes() + dateFromAI.getTimezoneOffset());
                
                const finalItems: PurchaseOrderItemExtended[] = [];
                if (Array.isArray(response.items)) {
                    response.items.forEach((aiItem, index) => {
                      const priceFromInvoiceVES = aiItem.unitPrice || 0;
                      const invoiceUnit = aiItem.unit || 'unidad';
                      let finalUnitPriceUSD = 0;
                      let finalUnit = invoiceUnit;
                      let priceFound = false;
                      let bestPriceHint = '';

                      if (supplierFromAI) {
                        const priceListItem = supplierFromAI.priceList?.find(pli => pli.rawMaterialName === aiItem.description);
                        if (priceListItem) {
                          const latestPrice = getCurrentPriceFromHistory(priceListItem.priceHistory);
                          if (latestPrice) {
                            finalUnit = priceListItem.unit;
                            finalUnitPriceUSD = latestPrice.price;
                            priceFound = true;
                          }
                        }
                      }
                      
                      if (!priceFound) {
                        const rateForCalc = loadExchangeRate(dateFromAI || new Date());
                        if (rateForCalc > 0 && priceFromInvoiceVES > 0) {
                          finalUnitPriceUSD = priceFromInvoiceVES / rateForCalc;
                          bestPriceHint = `No se encontró en lista de precios. Precio calculado desde factura. Unidad "${finalUnit}" extraída de factura. VERIFICAR.`;
                        } else {
                          bestPriceHint = `No se encontró precio de lista para este proveedor. Por favor, ingrésalo manualmente.`;
                        }
                      } else {
                        const bestPriceInfoForAIItem = getBestPriceInfo(aiItem.description);
                        if (bestPriceInfoForAIItem && supplierFromAI && bestPriceInfoForAIItem.supplierId === supplierFromAI.id) {
                            bestPriceHint = `Este proveedor tiene el mejor precio.`;
                        } else if (bestPriceInfoForAIItem) {
                            bestPriceHint = `💡 Mejor opción: ${bestPriceInfoForAIItem.supplierName} a $${bestPriceInfoForAIItem.originalUnitPrice.toFixed(4)} por ${bestPriceInfoForAIItem.originalUnit}.`;
                        } else {
                            bestPriceHint = `Precio y unidad cargados desde la lista de precios de ${supplierFromAI?.name || 'proveedor actual'}.`;
                        }
                      }
                      
                      const itemQuantity = aiItem.quantity || 0;
                      const newItem: PurchaseOrderItemExtended = {
                          id: `ai-item-${Date.now()}-${index}`,
                          rawMaterialName: aiItem.description,
                          quantity: itemQuantity,
                          unit: finalUnit,
                          unitPrice: finalUnitPriceUSD,
                          subtotal: itemQuantity * finalUnitPriceUSD,
                          bestPriceHint: bestPriceHint,
                          manualPriceEdit: !priceFound,
                          unitPriceDisplayUSD: finalUnitPriceUSD.toFixed(4),
                          unitPriceDisplayVES: exchangeRate > 0 ? (finalUnitPriceUSD * exchangeRate).toFixed(2) : "0.00",
                          priceInputCurrency: 'VES'
                      };
                      finalItems.push(newItem);
                    });
                }
                
                const splitsSetter = isEditingPO ? setEditPaymentSplits : setNewPaymentSplits;
                
                if (finalItems.length > 0) {
                    if (currentOrderStatus === 'Pagado') {
                        const totalCostFromAI = response.totalCost || 0;
                        const activeBranch = getActiveBranchId() || (availableBranches.length > 0 ? availableBranches[0].id : '');
                        splitsSetter([{
                            id: `ai-split-${Date.now()}`,
                            amount: totalCostFromAI, currency: 'VES', paymentMethod: 'Transferencia (VES)',
                            paidToBranchId: activeBranch, paidToAccountId: 'vesElectronic',
                            referenceNumber: '', items: finalItems,
                        }]);
                    } else {
                        setGlobalOrderItems(finalItems);
                    }
                }
                
                if (supplierFromAI) setSelectedSupplierId(supplierFromAI.id);
                if (isEditingPO) {
                    if (response.invoiceId) setCurrentEditablePOId(response.invoiceId);
                    if (dateFromAI) setEditOrderDate(dateFromAI);
                } else {
                    if (response.invoiceId) setNewOrderId(response.invoiceId);
                    if (dateFromAI) setOrderDate(dateFromAI);
                }
                
                toast({
                    title: 'Análisis Completado',
                    description: `${response.analysisNotes || 'Revisa los datos para confirmar.'}`,
                    duration: 9000,
                });

            } catch (aiError) {
                 console.error("Error analyzing invoice (AI):", aiError);
                 toast({ title: 'Error de Análisis', description: 'La IA no pudo procesar la factura. Inténtalo de nuevo con una imagen más clara o revisa la consola para más detalles.', variant: 'destructive' });
            } finally {
                setIsAnalyzing(false);
                setIsSubmitting(false);
                setInvoiceFile(null); 
                const fileInput = document.getElementById('invoice_upload') as HTMLInputElement;
                if(fileInput) fileInput.value = '';
            }
        };
        reader.onerror = (error) => {
            console.error("Error reading file:", error);
            toast({ title: 'Error de Lectura', description: 'No se pudo leer el archivo de imagen.', variant: 'destructive' });
            setIsAnalyzing(false);
            setIsSubmitting(false);
        };
    } catch (error) {
        console.error("Error handling file:", error);
        toast({ title: 'Error Inesperado', description: 'Ocurrió un error al manejar el archivo.', variant: 'destructive' });
        setIsAnalyzing(false);
        setIsSubmitting(false);
    }
  };


  const renderGlobalItemsSection = (currentItems: PurchaseOrderItemExtended[]) => (
    <div className="space-y-2 border p-3 rounded-md">
        <Label className="font-medium">Artículos de la Orden (Global)</Label>
        {currentItems.map((item, index) => (
            <div key={item.id} className="grid grid-cols-12 gap-x-2 gap-y-1 items-start border-b pb-3 mb-3 last:border-b-0 last:pb-0 last:mb-0">
                <div className="col-span-12 sm:col-span-6 lg:col-span-2 space-y-0.5">
                  {index === 0 && <Label htmlFor={`global_item_name_${item.id}_oc`} className="text-xs">Materia Prima</Label>}
                  <Select value={item.rawMaterialName} onValueChange={(value) => handleItemChange(index, 'rawMaterialName', value)} disabled={isSubmitting}>
                    <SelectTrigger id={`global_item_name_${item.id}_oc`} className="h-9"><SelectValue placeholder="Material" className="truncate" /></SelectTrigger>
                    <SelectContent>{currentRawMaterialOptions.map(option => <SelectItem key={option} value={option}>{option}</SelectItem>)}</SelectContent>
                  </Select>
                  {item.bestPriceHint && (
                    <p className={cn("text-xs pt-1",
                        item.bestPriceHint.startsWith("Este proveedor") ? "text-green-600 dark:text-green-500" :
                        item.bestPriceHint.startsWith("💡") ? "text-amber-600 dark:text-amber-500" :
                        "text-muted-foreground"
                    )}>{item.bestPriceHint}</p>
                  )}
                </div>
                <div className="col-span-4 sm:col-span-2 lg:col-span-1 space-y-0.5">{index === 0 && <Label htmlFor={`global_item_quantity_${item.id}_oc`} className="text-xs">Cant.</Label>}<Input id={`global_item_quantity_${item.id}_oc`} type="number" placeholder="Cant." value={item.quantity ?? 0} onChange={(e) => handleItemChange(index, 'quantity', e.target.value)} min="0" className="h-9" disabled={isSubmitting} /></div>
                <div className="col-span-4 sm:col-span-2 lg:col-span-1 space-y-0.5">{index === 0 && <Label htmlFor={`global_item_unit_${item.id}_oc`} className="text-xs">Unidad</Label>}<Select value={item.unit} onValueChange={(value) => handleItemChange(index, 'unit', value)} disabled={isSubmitting}><SelectTrigger id={`global_item_unit_${item.id}_oc`} className="h-9"><SelectValue placeholder="Unidad" /></SelectTrigger><SelectContent>{commonUnitOptions.map(option => <SelectItem key={option} value={option}>{option}</SelectItem>)}</SelectContent></Select></div>
                <div className="col-span-4 sm:col-span-2 lg:col-span-1 space-y-0.5">
                    {index === 0 && <Label htmlFor={`global_item_price_currency_${item.id}_oc`} className="text-xs">Moneda P.U.</Label>}
                    <Select value={item.priceInputCurrency} onValueChange={(value) => handleItemChange(index, 'priceInputCurrency', value)} disabled={isSubmitting}>
                        <SelectTrigger id={`global_item_price_currency_${item.id}_oc`} className="h-9"><SelectValue /></SelectTrigger>
                        <SelectContent><SelectItem value="VES" disabled={exchangeRate <= 0}>VES {exchangeRate <=0 ? '(Tasa no disp.)':''}</SelectItem><SelectItem value="USD">USD</SelectItem></SelectContent>
                    </Select>
                </div>
                <div className="col-span-6 sm:col-span-3 lg:col-span-2 space-y-0.5">
                    {index === 0 && <Label htmlFor={`global_item_unit_price_ves_${item.id}_oc`} className="text-xs">P. Unit (VES)</Label>}
                    <Input id={`global_item_unit_price_ves_${item.id}_oc`} type="text" placeholder="Precio VES" value={item.unitPriceDisplayVES || ''} onChange={(e) => handleItemChange(index, 'unitPriceDisplayVES', e.target.value)} className="h-9" disabled={isSubmitting || item.priceInputCurrency !== 'VES' || exchangeRate <= 0}/>
                </div>
                 <div className="col-span-6 sm:col-span-3 lg:col-span-2 space-y-0.5">
                    {index === 0 && <Label htmlFor={`global_item_unit_price_usd_${item.id}_oc`} className="text-xs">P. Unit (USD)</Label>}
                    <Input id={`global_item_unit_price_usd_${item.id}_oc`} type="text" placeholder="Precio USD" value={item.unitPriceDisplayUSD || ''} onChange={(e) => handleItemChange(index, 'unitPriceDisplayUSD', e.target.value)} className="h-9" disabled={isSubmitting || item.priceInputCurrency !== 'USD'}/>
                </div>
                <div className="col-span-8 sm:col-span-2 lg:col-span-1 space-y-1 text-left sm:text-right">
                    {index === 0 && <Label className="text-xs md:hidden">Subtotal (USD)</Label>} {index === 0 && <Label className="text-xs hidden md:block">Subtotal (USD)</Label>} {index > 0 && <div className="md:hidden h-5"></div>} {index > 0 && <div className="hidden md:block h-5"></div>}
                    <div className="h-9 flex flex-col items-start sm:items-end justify-center">
                        <p className="text-sm font-medium">
                            <FormattedNumber value={item.subtotal} prefix="$" decimalPlaces={4} />
                        </p>
                        {item.subtotal > 0 && exchangeRate > 0 && (
                            <p className="text-xs text-muted-foreground">
                                <FormattedNumber value={item.subtotal * exchangeRate} prefix="Bs. " />
                            </p>
                        )}
                    </div>
                </div>
                <div className="col-span-4 sm:col-span-2 lg:col-span-2 flex items-center justify-end space-x-1">
                    <Button type="button" variant="ghost" size="icon" className="h-9 w-9 text-primary hover:bg-primary/10 shrink-0"
                      onClick={() => handleUpdateSupplierPriceListItemManually(selectedSupplierId, item.rawMaterialName, Number(item.unitPrice), item.unit, item.priceInputCurrency === 'USD' ? 'usdCash' : 'default')}
                      disabled={isSubmitting || !selectedSupplierId || !item.rawMaterialName || item.unitPrice < 0 || !item.unit}
                      title={`Guardar precio en lista ${item.priceInputCurrency === 'USD' ? 'USD Efectivo' : 'Estándar'} del proveedor`}>
                      <SaveIcon className="h-4 w-4" />
                    </Button>
                    <Button type="button" variant="ghost" size="icon" onClick={() => handleRemoveGlobalItem(index)} className="h-9 w-9 text-destructive hover:bg-destructive/10" disabled={isSubmitting}><Trash className="h-4 w-4" /></Button>
                </div>
            </div>
        ))}
        <Button type="button" variant="outline" size="sm" onClick={handleAddGlobalItem} className="mt-2" disabled={isSubmitting || currentRawMaterialOptions.length === 0}><PlusCircle className="mr-2 h-4 w-4" /> Añadir Artículo</Button>
    </div>
  );

  const renderPaymentSplitsSection = () => {
    const paymentSplitsToRender = isEditingPO ? editPaymentSplits : newPaymentSplits;
    const formTypeForSplits = isEditingPO ? 'edit' : 'new';

    const getPaymentMethodsForCurrency = (currency: 'USD' | 'VES'): PaymentMethodType[] => {
        if (currency === 'USD') return ['Efectivo USD'];
        if (currency === 'VES' && exchangeRate > 0) return ['Pago Móvil (VES)', 'Transferencia (VES)', 'Efectivo VES'];
        if (currency === 'VES' && exchangeRate <= 0) return [];
        return ['Otro'];
    };
    
    const getAccountsForPaymentMethod = (currency: 'USD' | 'VES', method: PaymentMethodType): AccountType[] => {
        if (currency === 'USD' && method === 'Efectivo USD') return ['usdCash'];
        if (currency === 'VES' && exchangeRate > 0) {
            if (method === 'Pago Móvil (VES)' || method === 'Transferencia (VES)') return ['vesElectronic'];
            if (method === 'Efectivo VES') return ['vesCash'];
        }
        if ((currency === 'VES' && exchangeRate <= 0) || method === 'Otro') return [];
        return Object.values(accountTypeNames).map((_, idx) => Object.keys(accountTypeNames)[idx] as AccountType);
    };

    return (
      <div className="space-y-3 border p-3 rounded-md">
        <Label className="font-medium">Formas de Pago Múltiples</Label>
        {paymentSplitsToRender.map((split, index) => {
          const availablePaymentMethods = getPaymentMethodsForCurrency(split.currency);
          const availableAccounts = getAccountsForPaymentMethod(split.currency, split.paymentMethod);
          
          const splitItemsTotalUSD = (split.items || []).reduce((sum, item) => sum + (item.subtotal || 0), 0);
          let splitAmountToDisplay = 0;
          if (split.currency === 'VES') {
            splitAmountToDisplay = splitItemsTotalUSD * (split.exchangeRateAtPayment || exchangeRate || 1);
          } else {
            splitAmountToDisplay = splitItemsTotalUSD;
          }

          return (
          <div key={split.id} className="border-b pb-3 mb-3 last:border-b-0 last:pb-0 last:mb-0 bg-background p-2 rounded-md shadow-sm">
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-3 items-end mb-2">
              <div className="space-y-1 lg:col-span-1">
                  <Label htmlFor={`split_amount_display_${split.id}`} className="text-xs">Monto Pago ({split.currency})</Label>
                  <div className="h-9 rounded-md bg-muted/50 px-3 flex items-center justify-end">
                    <FormattedNumber value={splitAmountToDisplay} prefix={split.currency === 'USD' ? '$' : 'Bs. '} />
                  </div>
              </div>
              <div className="space-y-1 lg:col-span-1">
                  <Label htmlFor={`split_currency_${split.id}`} className="text-xs">Moneda Pago</Label>
                  <Select value={split.currency} onValueChange={val => handleSplitChange(split.id, 'currency', val, formTypeForSplits)} disabled={isSubmitting }>
                      <SelectTrigger id={`split_currency_${split.id}`} className="h-9"><SelectValue /></SelectTrigger>
                      <SelectContent>
                          <SelectItem value="USD">USD</SelectItem>
                          <SelectItem value="VES" disabled={exchangeRate <= 0}>VES {exchangeRate <= 0 ? '(Tasa no disp.)' : ''}</SelectItem>
                      </SelectContent>
                  </Select>
              </div>
              <div className="space-y-1 lg:col-span-1">
                  <Label htmlFor={`split_method_${split.id}`} className="text-xs">Método</Label>
                  <Select value={split.paymentMethod} onValueChange={val => handleSplitChange(split.id, 'paymentMethod', val, formTypeForSplits)} disabled={isSubmitting || availablePaymentMethods.length === 0}>
                      <SelectTrigger id={`split_method_${split.id}`} className="h-9"><SelectValue /></SelectTrigger>
                      <SelectContent>
                          {availablePaymentMethods.map(m => <SelectItem key={m} value={m}>{m}</SelectItem>)}
                          {availablePaymentMethods.length === 0 && <SelectItem value="no-methods-available" disabled>N/A para moneda</SelectItem>}
                      </SelectContent>
                  </Select>
              </div>
                       {split.currency === 'VES' && (
                         <div className="space-y-1 lg:col-span-1">
                            <Label htmlFor={`split_exchange_rate_${split.id}`} className="text-xs">Tasa (Opc)</Label>
                            <Input id={`split_exchange_rate_${split.id}`} type="number" value={split.exchangeRateAtPayment || ''} onChange={e => handleSplitChange(split.id, 'exchangeRateAtPayment', parseFloat(e.target.value) || undefined, formTypeForSplits)} placeholder={`Global: ${exchangeRate > 0 ? exchangeRate.toFixed(2) : 'N/A'}`} disabled={isSubmitting || exchangeRate <=0} className="h-9"/>
                        </div>
                       )}
                        {(split.paymentMethod === 'Pago Móvil (VES)' || split.paymentMethod === 'Transferencia (VES)') && (
                            <div className="space-y-1 lg:col-span-1">
                                {index === 0 && <Label htmlFor={`split_ref_${split.id}`} className="text-xs">Ref. (6 dig)</Label>}
                                <Input id={`split_ref_${split.id}`} value={split.referenceNumber || ''} onChange={e => handleSplitChange(split.id, 'referenceNumber', e.target.value, formTypeForSplits)} placeholder="123456" disabled={isSubmitting} className="h-9" maxLength={6}/>
                            </div>
                        )}
            </div>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-3 items-end">
              <div className="space-y-1 lg:col-span-2">
                  <Label htmlFor={`split_branch_${split.id}`} className="text-xs">Sede Egreso</Label>
                  <Select value={split.paidToBranchId} onValueChange={val => handleSplitChange(split.id, 'paidToBranchId', val, formTypeForSplits)} disabled={isSubmitting}>
                      <SelectTrigger id={`split_branch_${split.id}`} className="h-9"><SelectValue /></SelectTrigger>
                      <SelectContent>{availableBranches.map(b => <SelectItem key={b.id} value={b.id}>{b.name}</SelectItem>)}</SelectContent>
                  </Select>
              </div>
              <div className="space-y-1 lg:col-span-2">
                  <Label htmlFor={`split_account_${split.id}`} className="text-xs">Cuenta Egreso</Label>
                    <Select value={split.paidToAccountId} onValueChange={val => handleSplitChange(split.id, 'paidToAccountId', val as AccountType, formTypeForSplits)} disabled={isSubmitting || availableAccounts.length === 0}>
                      <SelectTrigger id={`split_account_${split.id}`} className="h-9"><SelectValue /></SelectTrigger>
                      <SelectContent>
                          {availableAccounts.map(accId => {
                              const accountDetails = loadFromLocalStorageForBranch<CompanyAccountsData>(KEYS.COMPANY_ACCOUNTS, split.paidToBranchId || '', true)[accId as AccountType];
                              return (<SelectItem key={accId} value={accId}>{accountTypeNames[accId]} ({accountDetails?.currency})</SelectItem>);
                          })}
                          {availableAccounts.length === 0 && <SelectItem value="no-accounts-available" disabled>N/A para moneda/método</SelectItem>}
                      </SelectContent>
                  </Select>
              </div>
              <div className="flex items-end justify-end lg:col-span-1">
                <Button type="button" variant="ghost" size="icon" onClick={() => handleRemovePaymentSplit(split.id, formTypeForSplits)} disabled={isSubmitting || paymentSplitsToRender.length <=1} className="h-9 w-9 text-destructive hover:bg-destructive/10"><Trash className="h-4 w-4" /></Button>
              </div>
            </div>
            {renderItemsForSplitSection(index, split.items || [])}
          </div>
        )})}
        <Button type="button" variant="outline" size="sm" onClick={() => handleAddPaymentSplit(formTypeForSplits)} disabled={isSubmitting} className="mt-2">
            <DollarSign className="mr-2 h-4 w-4" /> Añadir Forma de Pago
        </Button>
      </div>
    );
  };

  const renderItemsForSplitSection = (splitIndex: number, currentItems: PurchaseOrderItemExtended[]) => {
    const currentSplit = (isEditingPO ? editPaymentSplits : newPaymentSplits)[splitIndex];
    if (!currentSplit) return null;
    const currentSplitCurrency = currentSplit.currency;
    return (
    <div className="space-y-2 border p-3 rounded-md mt-2 bg-muted/30">
        <Label className="font-medium text-xs">Artículos para esta Forma de Pago</Label>
        {currentItems.map((item, itemIndex) => {
            return (
            <div key={item.id} className="grid grid-cols-12 gap-x-2 gap-y-1 items-start border-b pb-2 mb-2 last:border-b-0 last:pb-0 last:mb-0">
                <div className="col-span-12 sm:col-span-6 lg:col-span-2 space-y-0.5">
                  {itemIndex === 0 && <Label htmlFor={`split${splitIndex}_item_name_${item.id}_oc`} className="text-xs">Materia Prima</Label>}
                  <Select value={item.rawMaterialName} onValueChange={(value) => handleItemChange(itemIndex, 'rawMaterialName', value, splitIndex)} disabled={isSubmitting}>
                    <SelectTrigger id={`split${splitIndex}_item_name_${item.id}_oc`} className="h-8 text-xs"><SelectValue placeholder="Material" className="truncate" /></SelectTrigger>
                    <SelectContent>{currentRawMaterialOptions.map(option => <SelectItem key={option} value={option}>{option}</SelectItem>)}</SelectContent>
                  </Select>
                  {item.bestPriceHint && (
                    <p className={cn("text-xs pt-1",
                        item.bestPriceHint.startsWith("Este proveedor") ? "text-green-600 dark:text-green-500" :
                        item.bestPriceHint.startsWith("💡") ? "text-amber-600 dark:text-amber-500" :
                        "text-muted-foreground"
                    )}>{item.bestPriceHint}</p>
                  )}
                </div>
                <div className="col-span-4 sm:col-span-2 lg:col-span-1 space-y-0.5">{itemIndex === 0 && <Label htmlFor={`split${splitIndex}_item_quantity_${item.id}_oc`} className="text-xs">Cant.</Label>}<Input id={`split${splitIndex}_item_quantity_${item.id}_oc`} type="number" placeholder="Cant." value={item.quantity ?? 0} onChange={(e) => handleItemChange(itemIndex, 'quantity', e.target.value, splitIndex)} min="0" className="h-8 text-xs" disabled={isSubmitting} /></div>
                <div className="col-span-4 sm:col-span-2 lg:col-span-1 space-y-0.5">{itemIndex === 0 && <Label htmlFor={`split${splitIndex}_item_unit_${item.id}_oc`} className="text-xs">Unidad</Label>}<Select value={item.unit} onValueChange={(value) => handleItemChange(itemIndex, 'unit', value, splitIndex)} disabled={isSubmitting}><SelectTrigger id={`split${splitIndex}_item_unit_${item.id}_oc`} className="h-8 text-xs"><SelectValue placeholder="Unidad" /></SelectTrigger><SelectContent>{commonUnitOptions.map(option => <SelectItem key={option} value={option}>{option}</SelectItem>)}</SelectContent></Select></div>
                <div className="col-span-4 sm:col-span-2 lg:col-span-1 space-y-0.5">
                    {itemIndex === 0 && <Label htmlFor={`split${splitIndex}_item_price_currency_${item.id}_oc`} className="text-xs">Moneda P.U.</Label>}
                    <Select value={currentSplitCurrency} disabled={true}>
                        <SelectTrigger id={`split${splitIndex}_item_price_currency_${item.id}_oc`} className="h-8 text-xs bg-muted/50"><SelectValue /></SelectTrigger>
                        <SelectContent><SelectItem value="VES">VES</SelectItem><SelectItem value="USD">USD</SelectItem></SelectContent>
                    </Select>
                </div>
                <div className="col-span-6 sm:col-span-3 lg:col-span-2 space-y-0.5">
                    {itemIndex === 0 && <Label htmlFor={`split${splitIndex}_item_unit_price_ves_${item.id}_oc`} className="text-xs">P. Unit (VES)</Label>}
                    <Input id={`split${splitIndex}_item_unit_price_ves_${item.id}_oc`} type="text" placeholder="Precio VES" value={item.unitPriceDisplayVES || ''} onChange={(e) => handleItemChange(itemIndex, 'unitPriceDisplayVES', e.target.value, splitIndex)} className="h-8 text-xs" disabled={isSubmitting || currentSplitCurrency !== 'VES' || exchangeRate <= 0}/>
                </div>
                 <div className="col-span-6 sm:col-span-3 lg:col-span-2 space-y-0.5">
                    {itemIndex === 0 && <Label htmlFor={`split${splitIndex}_item_unit_price_usd_${item.id}_oc`} className="text-xs">P. Unit (USD)</Label>}
                    <Input id={`split${splitIndex}_item_unit_price_usd_${item.id}_oc`} type="text" placeholder="Precio USD" value={item.unitPriceDisplayUSD || ''} onChange={(e) => handleItemChange(itemIndex, 'unitPriceDisplayUSD', e.target.value, splitIndex)} className="h-8 text-xs" disabled={isSubmitting || currentSplitCurrency !== 'USD'}/>
                </div>
                <div className="col-span-8 sm:col-span-2 lg:col-span-1 space-y-1 text-left sm:text-right">
                    {itemIndex === 0 && <Label className="text-xs md:hidden">Subtotal (USD)</Label>} {itemIndex === 0 && <Label className="text-xs hidden md:block">Subtotal (USD)</Label>} {itemIndex > 0 && <div className="md:hidden h-5"></div>} {itemIndex > 0 && <div className="hidden md:block h-5"></div>}
                    <div className="h-8 flex flex-col items-start sm:items-end justify-center">
                        <p className="text-sm font-medium">
                            <FormattedNumber value={item.subtotal} prefix="$" decimalPlaces={4} />
                        </p>
                        {item.subtotal > 0 && exchangeRate > 0 && (
                            <p className="text-xs text-muted-foreground">
                                <FormattedNumber value={item.subtotal * exchangeRate} prefix="Bs. " />
                            </p>
                        )}
                    </div>
                </div>
                <div className="col-span-4 sm:col-span-2 lg:col-span-2 flex items-center justify-end space-x-1">
                    <Button type="button" variant="ghost" size="icon" className="h-8 w-8 text-primary hover:bg-primary/10 shrink-0"
                      onClick={() => handleUpdateSupplierPriceListItemManually(selectedSupplierId, item.rawMaterialName, Number(item.unitPrice), item.unit, currentSplitCurrency === 'USD' ? 'usdCash' : 'default')}
                      disabled={isSubmitting || !selectedSupplierId || !item.rawMaterialName || item.unitPrice < 0 || !item.unit}
                      title={`Guardar precio en lista ${currentSplitCurrency === 'USD' ? 'USD Efectivo' : 'Estándar'} del proveedor`}>
                      <SaveIcon className="h-3.5 w-3.5" />
                    </Button>
                    <Button type="button" variant="ghost" size="icon" onClick={() => handleRemoveItemFromSplit(splitIndex, itemIndex)} className="h-8 w-8 text-destructive hover:bg-destructive/10" disabled={isSubmitting}><Trash className="h-3.5 w-3.5" /></Button>
                </div>
            </div>
        )})}
        <Button type="button" variant="outline" size="xs" className="mt-1" onClick={() => handleAddItemToSplit(splitIndex)} disabled={isSubmitting || currentRawMaterialOptions.length === 0}>
            <PlusCircle className="mr-1.5 h-3.5 w-3.5" /> Añadir Artículo a este Pago
        </Button>
    </div>
  )};

  return (
    <div className="space-y-6">
      <PageHeader title="Gestión de Órdenes de Compra" description={`Optimiza tu proceso de compra y rastrea los pedidos a proveedores para la sede actual: ${availableBranches.find(b=>b.id === getActiveBranchId())?.name || 'No Seleccionada'}.`} icon={Receipt}
        actions={ <div className="flex space-x-2"> <Button onClick={() => setIsManageMaterialsDialogOpen(true)} variant="outline" disabled={isSubmitting}><Settings className="mr-2 h-4 w-4" />Gestionar Materias Primas</Button> <Button onClick={() => setIsManageConversionsDialogOpen(true)} variant="outline" disabled={isSubmitting}><Settings2 className="mr-2 h-4 w-4" />Gestionar Conversiones (Global)</Button> <Button onClick={() => { resetAddForm(); setIsPODialogOpen(true); }} disabled={isSubmitting}><PlusCircle className="mr-2 h-4 w-4" />Crear Nueva OC</Button> </div> }
      />
      <Card className="shadow-lg">
        <CardHeader>
          <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
            <div>
              <CardTitle>Historial de Órdenes de Compra</CardTitle>
              <CardDescription>Registro de todas tus OCs para la sede actual.</CardDescription>
            </div>
            <div className="flex flex-col sm:flex-row items-center gap-2 w-full sm:w-auto">
                <Popover>
                  <PopoverTrigger asChild>
                    <Button id="date-filter-orders" variant={"outline"} className={cn("w-full sm:w-[260px] justify-start text-left font-normal",!dateRangeFilter && "text-muted-foreground")} disabled={isSubmitting}>
                      <CalendarIcon className="mr-2 h-4 w-4" />
                      {dateRangeFilter?.from ? (dateRangeFilter.to ? (<>{format(dateRangeFilter.from, "LLL dd, y", { locale: es })} - {format(dateRangeFilter.to, "LLL dd, y", { locale: es })}</>) : (format(dateRangeFilter.from, "LLL dd, y", { locale: es }))) : (<span>Filtrar por Fecha</span>)}
                    </Button>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0" align="end">
                    <Calendar initialFocus mode="range" defaultMonth={dateRangeFilter?.from} selected={dateRangeFilter} onSelect={setDateRangeFilter} numberOfMonths={2} locale={es} disabled={isSubmitting} />
                  </PopoverContent>
                </Popover>
                <Select value={filterSupplierId} onValueChange={setFilterSupplierId} disabled={isSubmitting || isLoading}>
                    <SelectTrigger className="w-full sm:w-[200px]"><SelectValue placeholder="Filtrar Proveedor" /></SelectTrigger>
                    <SelectContent>
                        <SelectItem value={ALL_SUPPLIERS_FILTER_VALUE}>Todos los Proveedores</SelectItem>
                        {currentSuppliers.sort((a,b) => a.name.localeCompare(b.name)).map(s => (<SelectItem key={s.id} value={s.id}>{s.name}</SelectItem>))}
                    </SelectContent>
                </Select>
                <div className="relative w-full sm:w-auto">
                    <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
                    <Input
                        type="search"
                        placeholder="Buscar por ID de OC..."
                        className="pl-8 sm:w-[200px]"
                        value={filterOrderId}
                        onChange={(e) => setFilterOrderId(e.target.value)}
                        disabled={isSubmitting || isLoading}
                    />
                </div>
                <Button onClick={handleClearFilters} variant="outline" className="w-full sm:w-auto" disabled={isSubmitting || isLoading}>Limpiar</Button>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader><TableRow><TableHead>ID</TableHead><TableHead>Proveedor</TableHead><TableHead>Fecha Pedido</TableHead><TableHead>Entrega</TableHead><TableHead>Artículos/Pagos</TableHead><TableHead className="text-right">Total (USD)</TableHead><TableHead>Estado</TableHead><TableHead className="text-right">Acciones</TableHead></TableRow></TableHeader>
            <TableBody>{filteredPurchaseOrders.map((po) => {
              const itemsToDisplay = po.status === 'Pagado' && po.paymentSplits ? formatPaymentSplitsForDisplay(po.paymentSplits) : formatItemsForDisplay(po.items);
              return (
                <TableRow key={po.id}>
                  <TableCell>{po.id}</TableCell>
                  <TableCell className="font-medium">{po.supplierName}</TableCell>
                  <TableCell>{po.orderDate && isValid(parseISO(po.orderDate)) ? format(parseISO(po.orderDate), "dd/MM/yy", { locale: es }) : '-'}</TableCell>
                  <TableCell>{po.expectedDelivery && isValid(parseISO(po.expectedDelivery)) ? format(parseISO(po.expectedDelivery), "dd/MM/yy", { locale: es }) : '-'}</TableCell>
                  <TableCell className="max-w-xs truncate" title={itemsToDisplay}>{itemsToDisplay}</TableCell>
                  <TableCell className="text-right"><FormattedNumber value={po.totalCost} prefix="$" decimalPlaces={4} /></TableCell>
                  <TableCell>
                    <Badge variant={po.status === 'Pagado' ? 'default' : po.status === 'Cancelado' ? 'destructive' : 'outline'} className={cn("whitespace-nowrap", po.status === 'Pagado' ? 'bg-green-500/20 text-green-700 dark:text-green-400 border-green-500/50' : '')}>
                      {po.status}
                    </Badge>
                  </TableCell>
                  <TableCell className="text-right">
                    <div className="flex items-center justify-end space-x-1">
                      <Button variant="ghost" size="icon" onClick={() => handleOpenViewDialog(po)} title="Ver Detalles de OC" disabled={isSubmitting}>
                        <Eye className="h-4 w-4" />
                      </Button>
                      <DropdownMenu>
                        <DropdownMenuTrigger asChild><Button variant="ghost" size="icon" disabled={isSubmitting} title="Más Acciones"><MoreHorizontal className="h-4 w-4" /></Button></DropdownMenuTrigger>
                         <DropdownMenuContent align="end">
                            {po.status !== 'Pagado' ? (
                                <DropdownMenuItem onClick={() => handleMarkAsPaid(po.id)} disabled={isSubmitting}>
                                <PackageCheck className="mr-2 h-4 w-4 text-green-600"/>Marcar Pagada
                                </DropdownMenuItem>
                            ) : null}
                            <DropdownMenuItem onClick={() => generatePurchaseOrderPDF(po)} disabled={isSubmitting}><InvoiceIcon className="mr-2 h-4 w-4" />Generar PDF</DropdownMenuItem>
                            <DropdownMenuItem onClick={() => handleOpenEditDialog(po)} disabled={isSubmitting}><Edit className="mr-2 h-4 w-4" />Editar</DropdownMenuItem>
                            <DropdownMenuItem onClick={() => handleOpenDeleteDialog(po.id)} className="text-destructive focus:text-destructive-foreground focus:bg-destructive" disabled={isSubmitting}><Trash2 className="mr-2 h-4 w-4" />Eliminar</DropdownMenuItem>
                        </DropdownMenuContent>
                      </DropdownMenu>
                    </div>
                  </TableCell>
                </TableRow>
              );
            })}</TableBody>
          </Table>
          {filteredPurchaseOrders.length === 0 && !isLoading && (<p className="text-center text-muted-foreground py-8">{dateRangeFilter?.from || filterSupplierId !== ALL_SUPPLIERS_FILTER_VALUE || filterOrderId ? "No hay OCs para filtros." : "No hay OCs."}</p>)}
        </CardContent>
      </Card>
      <Dialog open={isPODialogOpen} onOpenChange={(isOpen) => { if(!isSubmitting) {setIsPODialogOpen(isOpen); if (!isOpen) resetAddForm();} }}><DialogContent className="sm:max-w-7xl max-h-[90vh]"><DialogHeader><DialogTitle>{isEditingPO ? "Editar OC" : "Crear Nueva OC"}</DialogTitle><DialogDescription>{isEditingPO ? "Actualiza detalles." : "Completa detalles."}</DialogDescription></DialogHeader>
        <div className="p-4 border rounded-lg bg-muted/50">
          <Label className="font-semibold text-base">Autocompletar con Factura (Beta)</Label>
          <p className="text-sm text-muted-foreground mb-3">Sube una foto de la factura y la IA intentará rellenar los datos.</p>
          <div className="flex gap-2 items-center">
              <Input
                  id="invoice_upload"
                  type="file"
                  accept="image/*"
                  onChange={handleFileChange}
                  disabled={isSubmitting}
                  className="flex-grow"
              />
              <Button onClick={handleAnalyzeInvoice} disabled={isSubmitting || !invoiceFile}>
                  {isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Eye className="mr-2 h-4 w-4" />}
                  {isSubmitting ? 'Analizando...' : 'Analizar'}
              </Button>
          </div>
        </div>
      <ScrollArea className="max-h-[calc(80vh-320px)] p-1 pr-3"><div className="grid gap-4 py-4 "><div className="grid grid-cols-1 md:grid-cols-2 gap-4"><div className="space-y-1"><Label htmlFor="po_id_input">ID OC (Factura)</Label><Input id="po_id_input" value={isEditingPO ? currentEditablePOId : newOrderId} onChange={(e) => { if (isEditingPO) { setCurrentEditablePOId(e.target.value); } else { setNewOrderId(e.target.value); }}} placeholder="FAC-00123" disabled={isSubmitting} /></div><div className="space-y-1"><Label htmlFor="supplier_select">Proveedor</Label><Select value={selectedSupplierId} onValueChange={setSelectedSupplierId} disabled={isSubmitting}><SelectTrigger id="supplier_select"><SelectValue placeholder="Selecciona" /></SelectTrigger><SelectContent>{currentSuppliers.sort((a,b) => a.name.localeCompare(b.name)).map(s => (<SelectItem key={s.id} value={s.id}>{s.name}</SelectItem>))}</SelectContent></Select></div></div><div className="grid grid-cols-1 md:grid-cols-3 gap-4"><div className="space-y-1"><Label htmlFor="po_status_select">Estado</Label><Select value={currentOrderStatus} onValueChange={(value) => setCurrentOrderStatus(value as PurchaseOrderStatus)} disabled={isSubmitting}><SelectTrigger id="po_status_select"><SelectValue /></SelectTrigger><SelectContent>{purchaseOrderStatusList.map(s => (<SelectItem key={s} value={s}>{s}</SelectItem>))}</SelectContent></Select></div><div className="space-y-1"><Label htmlFor="order_date">Fecha Pedido</Label><Popover open={isOrderDatePickerOpen} onOpenChange={setIsOrderDatePickerOpen}><PopoverTrigger asChild><Button id="order_date" variant={"outline"} className={cn("w-full justify-start", !(isEditingPO ? editOrderDate : orderDate) && "text-muted-foreground")} disabled={isSubmitting}><CalendarIcon className="mr-2 h-4 w-4" />{(isEditingPO ? editOrderDate : orderDate) ? format((isEditingPO ? editOrderDate! : orderDate!), "PPP", { locale: es }) : <span>Elige</span>}</Button></PopoverTrigger><PopoverContent className="w-auto p-0"><Calendar mode="single" selected={isEditingPO ? editOrderDate : orderDate} onSelect={(date) => { if (isEditingPO) { setEditOrderDate(date); } else { setOrderDate(date); } setIsOrderDatePickerOpen(false); }} initialFocus locale={es} disabled={isSubmitting} /></PopoverContent></Popover></div><div className="space-y-1"><Label htmlFor="expected_delivery">Entrega Estimada</Label><Popover open={isDeliveryDatePickerOpen} onOpenChange={setIsDeliveryDatePickerOpen}><PopoverTrigger asChild><Button id="expected_delivery" variant={"outline"} className={cn("w-full justify-start", !(isEditingPO ? editExpectedDelivery : expectedDelivery) && "text-muted-foreground")} disabled={isSubmitting}><CalendarIcon className="mr-2 h-4 w-4" />{(isEditingPO ? editExpectedDelivery : expectedDelivery) ? format((isEditingPO ? editExpectedDelivery! : expectedDelivery!), "PPP", { locale: es }) : <span>Elige</span>}</Button></PopoverTrigger><PopoverContent className="w-auto p-0"><Calendar mode="single" selected={isEditingPO ? editExpectedDelivery : expectedDelivery} onSelect={(date) => { if (isEditingPO) { setEditExpectedDelivery(date); } else { setExpectedDelivery(date); } setIsDeliveryDatePickerOpen(false); }} initialFocus locale={es} disabled={isSubmitting} /></PopoverContent></Popover></div></div>
        {currentOrderStatus === 'Pagado' ? renderPaymentSplitsSection() : renderGlobalItemsSection(globalOrderItems)}
        <div className="space-y-1 mt-4">
            <Label htmlFor="po_notes">Observaciones (Opcional)</Label>
            <Textarea
                id="po_notes"
                value={isEditingPO ? editPONotes : newPONotes}
                onChange={(e) => {
                    if (isEditingPO) setEditPONotes(e.target.value);
                    else setNewPONotes(e.target.value);
                }}
                placeholder="Anotaciones internas sobre la orden, condiciones de pago especiales, etc."
                disabled={isSubmitting}
                className="min-h-[60px]"
            />
        </div>
        <div className="space-y-1 mt-4 text-right">
            {currentOrderStatus === 'Pagado' ? (
              (() => {
                const splits = isEditingPO ? editPaymentSplits : newPaymentSplits;
                const totalAmountVES_footer = (splits || [])
                  .filter(split => split.currency === 'VES')
                  .reduce((sum, split) => sum + (split.amount || 0), 0);
                const totalAmountUSD_footer = (splits || [])
                  .filter(split => split.currency === 'USD')
                  .reduce((sum, split) => sum + (split.amount || 0), 0);
                return (
                  <>
                    {totalAmountVES_footer > 0 && <Label className="text-sm font-semibold block">Total Pagado (VES): <FormattedNumber value={totalAmountVES_footer} prefix="Bs. " /></Label>}
                    {totalAmountUSD_footer > 0 && <Label className="text-sm font-semibold block">Total Pagado (USD): <FormattedNumber value={totalAmountUSD_footer} prefix="$" /></Label>}
                    {(totalAmountVES_footer > 0 || totalAmountUSD_footer > 0) && <Separator className="my-1" />}
                    <Label className="text-lg font-semibold block">
                      Neto Factura (USD): <FormattedNumber value={displayedTotalCost} prefix="$" decimalPlaces={4} />
                    </Label>
                    {displayedTotalCost > 0 && exchangeRate > 0 && (
                      <p className="text-xs text-muted-foreground">
                        Equivalente Neto Factura (VES): <FormattedNumber value={displayedTotalCost * exchangeRate} prefix="Bs. " />
                      </p>
                    )}
                  </>
                );
              })()
            ) : (
              <>
                <Label className="text-lg font-semibold">Costo Total (USD): <FormattedNumber value={displayedTotalCost} prefix="$" decimalPlaces={4} /></Label>
                {displayedTotalCost > 0 && exchangeRate > 0 && (
                  <p className="text-sm text-muted-foreground"><FormattedNumber value={displayedTotalCost * exchangeRate} prefix="Bs. " /></p>
                )}
              </>
            )}
        </div>
      </div></ScrollArea><DialogFooter className="pt-2 border-t"><DialogClose asChild><Button variant="outline" onClick={() => { if(!isSubmitting) {setIsPODialogOpen(false); resetAddForm();}}} disabled={isSubmitting}>Cancelar</Button></DialogClose><Button type="button" onClick={handleSubmitPO} disabled={isSubmitting}>{isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : isEditingPO ? <Edit className="mr-2 h-4 w-4" /> : <PlusCircle className="mr-2 h-4 w-4" />}{isSubmitting ? 'Guardando...' : (isEditingPO ? "Guardar Cambios" : "Guardar OC")}</Button></DialogFooter></DialogContent></Dialog>
      
      <Dialog open={isViewPODialogOpen} onOpenChange={(isOpen) => { if (!isSubmitting) setIsViewPODialogOpen(isOpen); }}>
        <DialogContent className="sm:max-w-2xl max-h-[85vh]">
          <DialogHeader>
            <DialogTitle>Detalles OC: {poToViewDetails?.id}</DialogTitle>
            <DialogDescription>Info completa.</DialogDescription>
          </DialogHeader>
          {poToViewDetails && (
            <>
            <ScrollArea className="max-h-[calc(70vh-100px)] p-1 pr-3">
              <div className="space-y-3 py-4 text-sm">
                  <div className="grid grid-cols-[max-content_1fr] gap-x-3 items-baseline">
                    <Label className="font-semibold">Proveedor:</Label>
                    <span>{poToViewDetails.supplierName}</span>
                  </div>
                  <div className="grid grid-cols-[max-content_1fr] gap-x-3 items-baseline">
                    <Label className="font-semibold">Fecha Orden:</Label>
                    <span>{poToViewDetails.orderDate && isValid(parseISO(poToViewDetails.orderDate)) ? format(parseISO(poToViewDetails.orderDate), "dd/MM/yyyy", { locale: es }) : '-'}</span>
                  </div>
                  <div className="grid grid-cols-[max-content_1fr] gap-x-3 items-baseline">
                    <Label className="font-semibold">Entrega Estimada:</Label>
                    <span>{poToViewDetails.expectedDelivery && isValid(parseISO(poToViewDetails.expectedDelivery)) ? format(parseISO(poToViewDetails.expectedDelivery), "dd/MM/yyyy", { locale: es }) : '-'}</span>
                  </div>
                   <div className="grid grid-cols-[max-content_1fr] gap-x-3 items-baseline">
                    <Label className="font-semibold">Sede Compra:</Label>
                    <span>{availableBranches.find(b => b.id === getActiveBranchId())?.name || 'Desconocida'}</span>
                  </div>
                  <div className="grid grid-cols-[max-content_1fr] gap-x-3 items-baseline">
                    <Label className="font-semibold">Estado:</Label>
                    <Badge variant={poToViewDetails.status === 'Pagado' ? 'default' : poToViewDetails.status === 'Cancelado' ? 'destructive' : 'outline'} className={cn("whitespace-nowrap justify-self-start", poToViewDetails.status === 'Pagado' ? 'bg-green-500/20 text-green-700 dark:text-green-400 border-green-500/50' : '')}>
                      {poToViewDetails.status}
                    </Badge>
                  </div>
                  <div className="grid grid-cols-[max-content_1fr] gap-x-3 items-baseline">
                    <Label className="font-semibold">Tasa Aplicada (PDF):</Label>
                    <span>{poToViewDetails.exchangeRateOnOrderDate && poToViewDetails.exchangeRateOnOrderDate > 0 ? poToViewDetails.exchangeRateOnOrderDate.toFixed(2) : (exchangeRate > 0 ? `${exchangeRate.toFixed(2)} (Actual)` : 'No disponible')}</span>
                  </div>

                  {poToViewDetails.notes && (
                    <div className="pt-2">
                        <Label className="font-semibold">Observaciones:</Label>
                        <p className="text-sm whitespace-pre-wrap bg-muted/50 p-2 rounded-md border mt-1">{poToViewDetails.notes}</p>
                    </div>
                  )}

                  <Separator className="my-3" />
                  <h4 className="font-semibold text-md mb-1">Artículos y Pagos:</h4>
                  <div>
                    {poToViewDetails.status === 'Pagado' && poToViewDetails.paymentSplits && poToViewDetails.paymentSplits.length > 0 ? (
                      poToViewDetails.paymentSplits.map((split, index) => (
                        <div key={split.id} className="mb-3 border rounded-md p-3 bg-muted/5">
                          <p className="text-xs font-semibold mb-1">Forma de Pago {index + 1}: {split.paymentMethod} ({split.currency})</p>
                          <p className="text-xs text-muted-foreground">Monto Pago Declarado: <FormattedNumber value={split.amount} prefix={split.currency === 'USD' ? '$' : 'Bs. '} /></p>
                          <p className="text-xs text-muted-foreground">Suma Ítems en Pago (USD): <FormattedNumber value={(split.items || []).reduce((sum, item) => sum + (item.subtotal || 0), 0)} prefix="$" decimalPlaces={4} /></p>
                          <p className="text-xs text-muted-foreground">Cuenta: {accountTypeNames[split.paidToAccountId]} (Sede: {availableBranches.find(b=>b.id===split.paidToBranchId)?.name || 'N/A'})</p>
                          {split.referenceNumber && <p className="text-xs text-muted-foreground">Referencia: {split.referenceNumber}</p>}
                          
                          <Table className="text-xs mt-1.5"><TableHeader><TableRow><TableHead>Material</TableHead><TableHead className="text-right">Cant.</TableHead><TableHead>Unidad</TableHead><TableHead className="text-right">P.Unit(USD)</TableHead><TableHead className="text-right">Subtotal(USD)</TableHead></TableRow></TableHeader>
                            <TableBody>{(split.items || []).map(item => (<TableRow key={item.id}><TableCell>{item.rawMaterialName}</TableCell><TableCell className="text-right"><FormattedNumber value={item.quantity} decimalPlaces={3}/></TableCell><TableCell>{item.unit}</TableCell><TableCell className="text-right"><FormattedNumber value={item.unitPrice} prefix="$" decimalPlaces={4}/></TableCell><TableCell className="text-right"><FormattedNumber value={item.subtotal} prefix="$" decimalPlaces={4}/></TableCell></TableRow>))}</TableBody>
                          </Table>
                        </div>
                      ))
                    ) : (
                      <Table><TableHeader><TableRow><TableHead>Material</TableHead><TableHead className="text-right">Cant.</TableHead><TableHead>Unidad</TableHead><TableHead className="text-right">P.Unit(USD)</TableHead><TableHead className="text-right">Subtotal(USD)</TableHead></TableRow></TableHeader>
                        <TableBody>{poToViewDetails.items.map(item => (<TableRow key={item.id}><TableCell>{item.rawMaterialName}</TableCell><TableCell className="text-right"><FormattedNumber value={item.quantity} decimalPlaces={3}/></TableCell><TableCell>{item.unit}</TableCell><TableCell className="text-right"><FormattedNumber value={item.unitPrice} prefix="$" decimalPlaces={4}/></TableCell><TableCell className="text-right"><FormattedNumber value={item.subtotal} prefix="$" decimalPlaces={4}/></TableCell></TableRow>))}</TableBody>
                      </Table>
                    )}
                  </div>
                  <Separator className="my-3" />
                   <div className="mt-3 text-right">
                    {poToViewDetails.status === 'Pagado' && poToViewDetails.paymentSplits && poToViewDetails.paymentSplits.length > 0 ? (
                      (() => {
                        const totalAmountVES_footer_view = poToViewDetails.paymentSplits
                          .filter(split => split.currency === 'VES')
                          .reduce((sum, split) => sum + (split.amount || 0), 0);
                        const totalAmountUSD_footer_view = poToViewDetails.paymentSplits
                          .filter(split => split.currency === 'USD')
                          .reduce((sum, split) => sum + (split.amount || 0), 0);
                        return (
                          <>
                            {totalAmountVES_footer_view > 0 && <p className="text-sm font-semibold">Total Pagado (VES): <FormattedNumber value={totalAmountVES_footer_view} prefix="Bs. " /></p>}
                            {totalAmountUSD_footer_view > 0 && <p className="text-sm font-semibold">Total Pagado (USD): <FormattedNumber value={totalAmountUSD_footer_view} prefix="$" /></p>}
                            {(totalAmountVES_footer_view > 0 || totalAmountUSD_footer_view > 0) && <Separator className="my-1" />}
                            <p className="font-semibold text-base">Neto Factura (USD): <FormattedNumber value={poToViewDetails.totalCost} prefix="$" decimalPlaces={4} /></p>
                            {poToViewDetails.totalCost > 0 && (poToViewDetails.exchangeRateOnOrderDate || exchangeRate) > 0 && (
                              <p className="text-xs text-muted-foreground">
                                Equivalente Neto Factura (VES): <FormattedNumber value={poToViewDetails.totalCost * (poToViewDetails.exchangeRateOnOrderDate || exchangeRate)} prefix="Bs. " />
                              </p>
                            )}
                          </>
                        );
                      })()
                    ) : (
                      <>
                        <p className="font-semibold text-base">Costo Total (USD): <FormattedNumber value={poToViewDetails.totalCost} prefix="$" decimalPlaces={4} /></p>
                        {poToViewDetails.totalCost > 0 && (poToViewDetails.exchangeRateOnOrderDate || exchangeRate) > 0 && (
                            <p className="text-xs text-muted-foreground"><FormattedNumber value={poToViewDetails.totalCost * (poToViewDetails.exchangeRateOnOrderDate || exchangeRate)} prefix="Bs. " /></p>
                        )}
                      </>
                    )}
                  </div>
                </div>
            </ScrollArea>
            <DialogFooter className="pt-4 border-t">
                <DialogClose asChild><Button variant="outline">Cerrar</Button></DialogClose>
                <Button onClick={() => generateInvoicePDF(poToViewDetails)} disabled={isSubmitting}><InvoiceIcon className="mr-2 h-4 w-4" />Generar PDF</Button>
            </DialogFooter>
            </>
          )}
        </DialogContent>
      </Dialog>

      <Dialog open={isDeleteConfirmDialogOpen} onOpenChange={(isOpen) => { if(!isSubmitting) setIsDeleteConfirmDialogOpen(isOpen)}}><DialogContent className="sm:max-w-md"><DialogHeader><DialogTitle>Confirmar Eliminación</DialogTitle><DialogDescription>¿Eliminar OC? Ajustará stock/cuentas si estaba pagada.</DialogDescription></DialogHeader><DialogFooter className="sm:justify-end"><DialogClose asChild><Button variant="outline" onClick={() => {if(!isSubmitting) {setIsDeleteConfirmDialogOpen(false); setPoToDeleteId(null)}}} disabled={isSubmitting}>Cancelar</Button></DialogClose><Button variant="destructive" onClick={handleConfirmDelete} disabled={isSubmitting}>{isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Trash2 className="mr-2 h-4 w-4" />}{isSubmitting ? 'Eliminando...' : 'Eliminar OC'}</Button></DialogFooter></DialogContent></Dialog>
      <Dialog open={isManageMaterialsDialogOpen} onOpenChange={(isOpen) => { if(!isSubmitting) setIsManageMaterialsDialogOpen(isOpen); }}><DialogContent className="sm:max-w-lg"><DialogHeader><DialogTitle>Gestionar Materias Primas</DialogTitle><DialogDescription>Añade/elimina opciones de la lista global.</DialogDescription></DialogHeader><div className="grid gap-4 py-4"><div className="flex items-center space-x-2"><Input id="new_material_name" value={newMaterialName} onChange={(e) => setNewMaterialName(e.target.value)} placeholder="Nueva materia" disabled={isSubmitting} /><Button type="button" onClick={handleAddNewRawMaterial} disabled={isSubmitting}><ListPlus className="mr-2 h-4 w-4"/> Añadir</Button></div><Separator className="my-4" /><Label>Materias Primas Existentes:</Label>{currentRawMaterialOptions.length > 0 ? (<ScrollArea className="h-48 rounded-md border p-2">{currentRawMaterialOptions.map(option => (<div key={option} className="flex items-center justify-between py-1.5 hover:bg-muted/50 px-2 rounded-md"><span>{option}</span><Button variant="ghost" size="icon" className="h-7 w-7 text-destructive hover:bg-destructive/10" onClick={() => openDeleteMaterialConfirm(option)} disabled={isSubmitting}><XCircle className="h-4 w-4" /></Button></div>))}</ScrollArea>) : (<p className="text-sm text-muted-foreground">No hay materias.</p>)}</div><DialogFooter><DialogClose asChild><Button variant="outline" onClick={() => {if(!isSubmitting) setIsManageMaterialsDialogOpen(false);}} disabled={isSubmitting}>Cerrar</Button></DialogClose></DialogFooter></DialogContent></Dialog>
      <Dialog open={isDeleteMaterialConfirmOpen} onOpenChange={(isOpen) => { if(!isSubmitting) setIsDeleteMaterialConfirmOpen(isOpen); }}><DialogContent className="sm:max-w-md"><DialogHeader><DialogTitle>Confirmar Eliminación</DialogTitle><DialogDescription>¿Eliminar materia prima "{materialToDelete}"?</DialogDescription></DialogHeader><DialogFooter><DialogClose asChild><Button variant="outline" onClick={() => {if(!isSubmitting) setIsDeleteMaterialConfirmOpen(false);}} disabled={isSubmitting}>Cancelar</Button></DialogClose><Button variant="destructive" onClick={handleConfirmDeleteMaterial} disabled={isSubmitting}>{isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Trash2 className="mr-2 h-4 w-4" />}{isSubmitting ? 'Eliminando...' : 'Eliminar'}</Button></DialogFooter></DialogContent></Dialog>

      <ManageConversionsDialog
        isOpen={isManageConversionsDialogOpen}
        onOpenChange={setIsManageConversionsDialogOpen}
        onConversionsUpdated={handleConversionsUpdated}
      />
    </div>
  );
}

// --- payment-verification ---



"use client";

import React, { useState, useEffect, useCallback } from 'react';
import { PageHeader } from '@/components/page-header';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogClose } from '@/components/ui/dialog';
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { CheckCircle2, XCircle, Loader2, History, Hourglass, Edit, Trash2, Filter, Search, Eye } from 'lucide-react';
import { useToast } from "@/hooks/use-toast";
import {
  paymentsData as initialPaymentsDataGlobal,
  savePaymentsData,
  type Payment,
  customersData as initialCustomersDataGlobal,
  saveCustomersData,
  type Customer,
  type AccountTransaction,
  saveCompanyAccountsData, 
  type CompanyAccountsData,
  type AccountType,
  accountTypeNames,
  loadExchangeRate,
  userProfileData,
  salesData as initialSalesDataGlobal,
  saveSalesData,
  type Sale,
  KEYS,
  loadFromLocalStorageForBranch, 
  saveToLocalStorageForBranch, 
  calculateCustomerBalance,
  pendingFundTransfersData as initialPendingFundTransfersDataGlobal,
  savePendingFundTransfersData,
  type PendingFundTransfer,
  availableBranches,
  getInvoiceStatus,
  loadCompanyAccountsData,
  updateGlobalSaleDataAndFinances
} from '@/lib/data-storage';
import { format, parseISO, isValid, differenceInDays, isWithinInterval, startOfDay, endOfDay } from 'date-fns';
import type { DateRange } from "react-day-picker";
import { es } from 'date-fns/locale';
import { Badge } from '@/components/ui/badge';
import { cn } from '@/lib/utils';
import { FormattedNumber } from '@/components/ui/formatted-number';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Popover, PopoverTrigger, PopoverContent } from '@/components/ui/popover';
import { Calendar } from "@/components/ui/calendar";
import { Calendar as CalendarIcon } from 'lucide-react';
import { ScrollArea } from '@/components/ui/scroll-area';
import { paymentMethodList, type PaymentMethodType } from '@/lib/data-storage';

const DEBT_ADJUSTMENT_ID = "DEBT_ADJUSTMENT_PAYMENT";
const ALL_CUSTOMERS_FILTER_VALUE = "__ALL_CUSTOMERS__";


export default function PaymentVerificationPage() {
  const { toast } = useToast();
  const [allPayments, setAllPayments] = useState<Payment[]>([]);
  const [pendingPayments, setPendingPayments] = useState<Payment[]>([]);
  const [processedPayments, setProcessedPayments] = useState<Payment[]>([]);
  const [filteredProcessedPayments, setFilteredProcessedPayments] = useState<Payment[]>([]);

  const [isLoading, setIsLoading] = useState(true);
  const [isProcessing, setIsProcessing] = useState<string | null>(null);
  const [globalExchangeRate, setGlobalExchangeRate] = useState<number>(0);

  // Estados para filtros del historial
  const [filterDateRange, setFilterDateRange] = useState<DateRange | undefined>(undefined);
  const [filterCustomerId, setFilterCustomerId] = useState<string>(ALL_CUSTOMERS_FILTER_VALUE);
  const [filterReference, setFilterReference] = useState<string>('');

  const [isNotesDialogOpen, setIsNotesDialogOpen] = useState(false);
  const [notesToView, setNotesToView] = useState<string>('');


  const [isEditPaymentDialogOpen, setIsEditPaymentDialogOpen] = useState(false);
  const [editingPayment, setEditingPayment] = useState<Payment | null>(null);

  const [paymentDate, setPaymentDate] = useState<Date | undefined>(new Date());
  const [paymentAmountInput, setPaymentAmountInput] = useState('');
  const [paymentCurrency, setPaymentCurrency] = useState<'USD' | 'VES'>('USD');
  const [paymentExchangeRate, setPaymentExchangeRate] = useState('');
  const [currentPaymentMethod, setCurrentPaymentMethod] = useState<PaymentMethodType>(paymentMethodList[0]);
  const [paymentReferenceNumber, setPaymentReferenceNumber] = useState('');
  const [paymentNotes, setPaymentNotes] = useState('');
  const [paidToBranchIdDialog, setPaidToBranchIdDialog] = useState<string>('');
  const [paidToAccountIdDialog, setPaidToAccountIdDialog] = useState<AccountType>('vesElectronic');
  const [isPaymentDatePickerOpen, setIsPaymentDatePickerOpen] = useState(false);
  const [selectedInvoiceId, setSelectedInvoiceId] = useState<string>('');
  const [pendingInvoicesForCustomer, setPendingInvoicesForCustomer] = useState<Sale[]>([]);
  const [balanceFromAdjustment, setBalanceFromAdjustment] = useState<number>(0);
  
  const [isDeleteConfirmOpen, setIsDeleteConfirmOpen] = useState(false);
  const [paymentToDelete, setPaymentToDelete] = useState<Payment | null>(null);


  const loadPayments = useCallback(() => {
    setIsLoading(true);
    const currentPayments = [...initialPaymentsDataGlobal].sort((a, b) => {
      const dateA = a.paymentDate && isValid(parseISO(a.paymentDate)) ? parseISO(a.paymentDate).getTime() : 0;
      const dateB = b.paymentDate && isValid(parseISO(b.paymentDate)) ? parseISO(b.paymentDate).getTime() : 0;
      return dateB - dateA; 
    });
    setAllPayments(currentPayments);
    setPendingPayments(currentPayments.filter(p => p.status === 'pendiente de verificación'));
    const processed = currentPayments.filter(p => p.status === 'verificado' || p.status === 'rechazado');
    setProcessedPayments(processed);
    setFilteredProcessedPayments(processed);
    setGlobalExchangeRate(loadExchangeRate());
    setIsLoading(false);
  }, []);

  const applyFilters = useCallback(() => {
    let paymentsToFilter = [...processedPayments];

    if (filterDateRange?.from) {
        const toDate = filterDateRange.to ? endOfDay(filterDateRange.to) : endOfDay(filterDateRange.from);
        paymentsToFilter = paymentsToFilter.filter(payment => {
            if (!payment.paymentDate || !isValid(parseISO(payment.paymentDate))) return false;
            return isWithinInterval(parseISO(payment.paymentDate), { start: startOfDay(filterDateRange.from!), end: toDate });
        });
    }

    if (filterCustomerId !== ALL_CUSTOMERS_FILTER_VALUE) {
        paymentsToFilter = paymentsToFilter.filter(payment => payment.customerId === filterCustomerId);
    }

    if (filterReference.trim() !== '') {
        paymentsToFilter = paymentsToFilter.filter(payment => 
            payment.referenceNumber?.toLowerCase().includes(filterReference.trim().toLowerCase())
        );
    }
    
    setFilteredProcessedPayments(paymentsToFilter);
  }, [processedPayments, filterDateRange, filterCustomerId, filterReference]);

  useEffect(() => {
    applyFilters();
  }, [processedPayments, filterDateRange, filterCustomerId, filterReference, applyFilters]);
  
  const handleApplyFilters = () => applyFilters();
  const handleClearFilters = () => {
    setFilterDateRange(undefined);
    setFilterCustomerId(ALL_CUSTOMERS_FILTER_VALUE);
    setFilterReference('');
  };


  useEffect(() => {
    loadPayments();
    const handleDataUpdate = (event: Event) => {
        const customEvent = event as CustomEvent;
        if (customEvent.detail?.key === KEYS.PAYMENTS || 
            customEvent.detail?.key === KEYS.SALES ||
            customEvent.detail?.key === KEYS.CUSTOMERS ||
            customEvent.detail?.key === KEYS.COMPANY_ACCOUNTS ||
            customEvent.detail?.key === KEYS.ACCOUNT_TRANSACTIONS ||
            customEvent.detail?.key === KEYS.PENDING_FUND_TRANSFERS
           ) {
            loadPayments();
        }
    };
    window.addEventListener('data-updated', handleDataUpdate);
    return () => {
        window.removeEventListener('data-updated', handleDataUpdate);
    };
  }, [loadPayments]);

  const handleVerifyPayment = (paymentId: string) => {
    setIsProcessing(paymentId);
    let currentGlobalPayments = [...initialPaymentsDataGlobal];
    const paymentIndex = currentGlobalPayments.findIndex(p => p.id === paymentId);

    if (paymentIndex === -1) {
      toast({ title: "Error", description: "Pago no encontrado.", variant: "destructive" });
      setIsProcessing(null);
      return;
    }
    const paymentToVerify = { ...currentGlobalPayments[paymentIndex] };
    
    paymentToVerify.status = 'verificado';
    paymentToVerify.verifiedBy = userProfileData.fullName;
    paymentToVerify.verificationDate = new Date().toISOString();
    
    currentGlobalPayments[paymentIndex] = paymentToVerify;
    savePaymentsData(currentGlobalPayments);

    // This single call handles all financial updates now.
    updateGlobalSaleDataAndFinances(paymentToVerify, 'add');
    
    toast({ title: "Pago Verificado", description: `El pago de ${paymentToVerify.customerName} ha sido verificado y aplicado.` });
    loadPayments();
    setIsProcessing(null);
  };

  const handleRejectPayment = (paymentId: string) => {
    setIsProcessing(paymentId);
    let allPaymentsToSave = [...initialPaymentsDataGlobal];
    const paymentIndex = allPaymentsToSave.findIndex(p => p.id === paymentId);

     if (paymentIndex === -1) {
      toast({ title: "Error", description: "Pago no encontrado.", variant: "destructive" });
      setIsProcessing(null);
      return;
    }
    const payment = { ...allPaymentsToSave[paymentIndex] };
    payment.status = 'rechazado';
    payment.verifiedBy = userProfileData.fullName;
    payment.verificationDate = new Date().toISOString();
    allPaymentsToSave[paymentIndex] = payment;

    savePaymentsData(allPaymentsToSave);
    toast({ title: "Pago Rechazado", description: `El pago de ${payment.customerName} ha sido marcado como rechazado.` });
    loadPayments();
    setIsProcessing(null);
  };
  
  const handleSaveEditedPayment = () => {
     if (!editingPayment || !paymentDate || !paymentAmountInput) {
        toast({ title: "Error", description: "Faltan datos para editar el pago.", variant: "destructive" });
        return;
    }
    const amountNum = parseFloat(paymentAmountInput);
    if (isNaN(amountNum) || amountNum <= 0) {
      toast({ title: "Error", description: "Monto inválido.", variant: "destructive" });
      return;
    }
    
    let currentGlobalPayments = [...initialPaymentsDataGlobal];
    const paymentIndex = currentGlobalPayments.findIndex(p => p.id === editingPayment.id);
    if(paymentIndex === -1) {
        toast({ title: "Error", description: "Pago no encontrado para actualizar.", variant: "destructive" });
        return;
    }
    
    const updatedPayment = { ...currentGlobalPayments[paymentIndex] };
    
    updatedPayment.paymentDate = format(paymentDate, "yyyy-MM-dd");
    updatedPayment.amountPaidInput = amountNum;
    updatedPayment.currencyPaidInput = paymentCurrency;
    updatedPayment.paymentMethod = currentPaymentMethod;
    updatedPayment.referenceNumber = paymentReferenceNumber;
    updatedPayment.notes = paymentNotes;
    updatedPayment.paidToBranchId = paidToBranchIdDialog;
    updatedPayment.paidToAccountId = paidToAccountIdDialog;

    let paymentExchangeRateValue = parseFloat(paymentExchangeRate);
    if (paymentCurrency === 'VES' && (isNaN(paymentExchangeRateValue) || paymentExchangeRateValue <= 0)) {
        toast({ title: "Error", description: "La tasa de cambio para el pago en VES debe ser un número positivo.", variant: "destructive" });
        return;
    }
    updatedPayment.exchangeRateAtPayment = paymentCurrency === 'VES' ? paymentExchangeRateValue : undefined;
    updatedPayment.amountAppliedToDebtUSD = paymentCurrency === 'VES' ? amountNum / paymentExchangeRateValue : amountNum;
    
    updatedPayment.appliedToInvoiceId = selectedInvoiceId === DEBT_ADJUSTMENT_ID ? undefined : selectedInvoiceId;
    updatedPayment.paymentSource = selectedInvoiceId === DEBT_ADJUSTMENT_ID ? 'balance_adjustment' : 'invoice';

    currentGlobalPayments[paymentIndex] = updatedPayment;
    savePaymentsData(currentGlobalPayments);

    toast({ title: "Éxito", description: "El pago pendiente ha sido actualizado." });
    setIsEditPaymentDialogOpen(false);
    setEditingPayment(null);
  };
  
 const handleDeletePayment = () => {
    if (!paymentToDelete) return;
    setIsProcessing(paymentToDelete.id);

    // Revertir efectos financieros si el pago estaba verificado
    if (paymentToDelete.status === 'verificado') {
        updateGlobalSaleDataAndFinances(paymentToDelete, 'subtract');
    }

    // Filtrar pago
    let currentPayments = [...initialPaymentsDataGlobal];
    const initialPaymentCount = currentPayments.length;
    currentPayments = currentPayments.filter(p => p.id !== paymentToDelete.id);
    
    if (currentPayments.length < initialPaymentCount) {
        savePaymentsData(currentPayments);
    }
    
    // Filtrar transferencias de fondos si el pago eliminado estaba verificado
    if (paymentToDelete.status === 'verificado' && paymentToDelete.parentPaymentId) {
        let currentTransfers = [...initialPendingFundTransfersDataGlobal];
        const initialTransferCount = currentTransfers.length;
        currentTransfers = currentTransfers.filter(t => !t.id.includes(paymentToDelete.id.slice(0, 15))); // Heurística para encontrar transferencias relacionadas
        if (currentTransfers.length < initialTransferCount) {
            savePendingFundTransfersData(currentTransfers);
        }
    }


    toast({title: "Pago Eliminado", description: "El pago y sus efectos financieros asociados (si aplica) han sido eliminados."});
    setIsProcessing(null);
    setPaymentToDelete(null);
    setIsDeleteConfirmOpen(false);
    loadPayments();
}


  const handleOpenEditDialog = (payment: Payment) => {
    setEditingPayment(payment);
    const customer = initialCustomersDataGlobal.find(c => c.id === payment.customerId);

    setPaymentDate(parseISO(payment.paymentDate));
    setPaymentAmountInput(payment.amountPaidInput.toString());
    setPaymentCurrency(payment.currencyPaidInput);
    setPaymentExchangeRate(payment.exchangeRateAtPayment?.toString() || (payment.currencyPaidInput === 'VES' ? globalExchangeRate.toString() : ''));
    setCurrentPaymentMethod(payment.paymentMethod);
    setPaymentReferenceNumber(payment.referenceNumber || '');
    setPaymentNotes(payment.notes || '');
    setPaidToBranchIdDialog(payment.paidToBranchId || '');
    setPaidToAccountIdDialog(payment.paidToAccountId || 'vesElectronic');
    
    if (payment.paymentSource === 'invoice' && payment.appliedToInvoiceId) {
        setSelectedInvoiceId(payment.appliedToInvoiceId);
    } else {
        setSelectedInvoiceId(DEBT_ADJUSTMENT_ID);
    }
    
    if (customer) {
        const invoices = initialSalesDataGlobal.filter(
            s => s.customerId === customer.id && getInvoiceStatus(s, initialPaymentsDataGlobal) !== 'Completada'
        ).sort((a,b) => parseISO(a.date).getTime() - parseISO(b.date).getTime());
        setPendingInvoicesForCustomer(invoices);

        const customerBalance = calculateCustomerBalance(customer.id, initialSalesDataGlobal, initialPaymentsDataGlobal);
        setBalanceFromAdjustment(customerBalance < -0.01 ? Math.abs(customerBalance) : 0);
    }

    setIsEditPaymentDialogOpen(true);
  }


  const renderPaymentsTable = (paymentsToList: Payment[], isPendingTable: boolean) => (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>Fecha Pago</TableHead>
          <TableHead>Cliente</TableHead>
          <TableHead>Monto Pagado</TableHead>
          <TableHead>Monto Aplicado (USD)</TableHead>
          <TableHead>Método</TableHead>
          <TableHead>Referencia</TableHead>
          <TableHead>Fuente</TableHead>
          <TableHead>Sede Ingreso</TableHead>
          {!isPendingTable && <TableHead>Estado</TableHead>}
          <TableHead className="text-right">Acciones</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {paymentsToList.map((payment) => (
          <TableRow key={payment.id}>
            <TableCell>{payment.paymentDate && isValid(parseISO(payment.paymentDate)) ? format(parseISO(payment.paymentDate), "dd/MM/yyyy", { locale: es }) : '-'}</TableCell>
            <TableCell>{payment.customerName}</TableCell>
            <TableCell><FormattedNumber value={payment.amountPaidInput} prefix={payment.currencyPaidInput === 'VES' ? 'Bs. ' : '$'} /></TableCell>
            <TableCell><FormattedNumber value={payment.amountAppliedToDebtUSD} prefix="$" /></TableCell>
            <TableCell>{payment.paymentMethod}</TableCell>
            <TableCell>{payment.referenceNumber || '-'}</TableCell>
            <TableCell>{payment.paymentSource === 'invoice' ? `Factura: ${payment.appliedToInvoiceId}` : 'Abono Saldo'}</TableCell>
            <TableCell>{payment.paidToBranchId ? availableBranches.find(b=>b.id === payment.paidToBranchId)?.name : 'N/A'}</TableCell>
            {!isPendingTable && (
              <TableCell>
                <Badge
                  variant={payment.status === 'verificado' ? 'default' : payment.status === 'rechazado' ? 'destructive' : 'secondary'}
                  className={cn( "whitespace-nowrap", payment.status === 'verificado' ? 'bg-green-500/20 text-green-700 dark:text-green-400 border-green-500/50' : payment.status === 'rechazado' ? 'bg-red-500/20 text-red-700 dark:text-red-400 border-red-500/50' : 'bg-yellow-500/20 text-yellow-700 dark:text-yellow-400 border-yellow-500/50' )}>
                  {payment.status.charAt(0).toUpperCase() + payment.status.slice(1)}
                </Badge>
              </TableCell>
            )}
            <TableCell className="text-right space-x-1">
              <Button size="sm" variant="ghost" onClick={() => { setNotesToView(payment.notes || 'No hay notas para este pago.'); setIsNotesDialogOpen(true); }} disabled={isProcessing === payment.id}>
                <Eye className="h-4 w-4" />
              </Button>
              {isPendingTable && (
                  <>
                    <Button size="sm" variant="outline" onClick={() => handleOpenEditDialog(payment)} disabled={isProcessing === payment.id}><Edit className="mr-1 h-3 w-3" /> Editar</Button>
                    <Button size="sm" variant="outline" onClick={() => handleVerifyPayment(payment.id)} disabled={isProcessing === payment.id} className="bg-green-500/20 hover:bg-green-500/30 text-green-700 border-green-500/50 dark:text-green-400 dark:border-green-500/70 dark:hover:bg-green-500/40">
                      {isProcessing === payment.id ? <Loader2 className="h-4 w-4 animate-spin" /> : <CheckCircle2 className="h-4 w-4" />}
                    </Button>
                    <Button size="sm" variant="destructive" onClick={() => handleRejectPayment(payment.id)} disabled={isProcessing === payment.id}>
                      {isProcessing === payment.id ? <Loader2 className="h-4 w-4 animate-spin" /> : <XCircle className="h-4 w-4" />}
                    </Button>
                  </>
              )}
              
               <Button size="sm" variant="ghost" onClick={() => { setPaymentToDelete(payment); setIsDeleteConfirmOpen(true); }} disabled={isProcessing === payment.id} className="text-destructive hover:bg-destructive/10">
                  <Trash2 className="h-4 w-4" />
               </Button>
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );


  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[calc(100vh-10rem)]">
        <Loader2 className="h-12 w-12 animate-spin text-primary" />
        <p className="ml-4 text-lg">Cargando pagos...</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <PageHeader
        title="Verificación de Pagos (Global)"
        description="Verifica o rechaza los pagos (Pago Móvil, Transferencias) registrados globalmente. El ingreso se registra en la sede seleccionada al registrar el pago y se generan transferencias de fondos pendientes si la factura es multi-sede."
        icon={Hourglass} 
      />

      <Tabs defaultValue="pending">
        <TabsList className="grid w-full grid-cols-2 sm:w-[400px]">
          <TabsTrigger value="pending"><Hourglass className="mr-2 h-4 w-4" /> Pendientes ({pendingPayments.length})</TabsTrigger>
          <TabsTrigger value="history"><History className="mr-2 h-4 w-4" /> Historial Procesados ({processedPayments.length})</TabsTrigger>
        </TabsList>
        <TabsContent value="pending">
          <Card className="shadow-lg"><CardHeader><CardTitle>Pagos Pendientes de Verificación</CardTitle><CardDescription>Pagos que necesitan ser verificados. La verificación aplicará el pago a la factura/saldo, registrará el ingreso en la sede y creará transferencias de fondos pendientes si aplica.</CardDescription></CardHeader><CardContent>{pendingPayments.length > 0 ? (renderPaymentsTable(pendingPayments, true)) : (!isLoading && <p className="text-center text-muted-foreground py-8">No hay pagos pendientes de verificación.</p>)}</CardContent></Card>
        </TabsContent>
        <TabsContent value="history">
            <Card className="shadow-lg">
                <CardHeader>
                    <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
                        <div>
                            <CardTitle>Historial de Pagos Procesados</CardTitle>
                            <CardDescription>Pagos globales ya verificados o rechazados.</CardDescription>
                        </div>
                        <div className="flex flex-col sm:flex-row items-center gap-2 w-full sm:w-auto">
                            <Popover>
                                <PopoverTrigger asChild>
                                    <Button id="date-filter-payments" variant={"outline"} className={cn("w-full sm:w-[260px] justify-start text-left font-normal", !filterDateRange && "text-muted-foreground")} disabled={isLoading}>
                                        <CalendarIcon className="mr-2 h-4 w-4" />
                                        {filterDateRange?.from ? (filterDateRange.to ? (<>{format(filterDateRange.from, "LLL dd, y", { locale: es })} - {format(filterDateRange.to, "LLL dd, y", { locale: es })}</>) : (format(filterDateRange.from, "LLL dd, y", { locale: es }))) : (<span>Filtrar por Fecha</span>)}
                                    </Button>
                                </PopoverTrigger>
                                <PopoverContent className="w-auto p-0" align="end">
                                    <Calendar initialFocus mode="range" defaultMonth={filterDateRange?.from} selected={filterDateRange} onSelect={setFilterDateRange} numberOfMonths={2} locale={es} disabled={isLoading} />
                                </PopoverContent>
                            </Popover>
                            <Select value={filterCustomerId} onValueChange={setFilterCustomerId} disabled={isLoading}>
                                <SelectTrigger className="w-full sm:w-[200px]"><SelectValue placeholder="Filtrar Cliente" /></SelectTrigger>
                                <SelectContent>
                                    <SelectItem value={ALL_CUSTOMERS_FILTER_VALUE}>Todos los Clientes</SelectItem>
                                    {initialCustomersDataGlobal.sort((a,b) => a.name.localeCompare(b.name)).map(customer => (<SelectItem key={customer.id} value={customer.id}>{customer.name}</SelectItem>))}
                                </SelectContent>
                            </Select>
                             <div className="relative w-full sm:w-auto">
                                <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
                                <Input type="search" placeholder="Buscar por Ref..." className="pl-8 sm:w-[150px]" value={filterReference} onChange={(e) => setFilterReference(e.target.value)} disabled={isLoading} />
                            </div>
                            <Button onClick={handleApplyFilters} className="w-full sm:w-auto" disabled={isLoading}><Filter className="mr-2 h-4 w-4" /> Aplicar</Button>
                            <Button onClick={handleClearFilters} variant="outline" className="w-full sm:w-auto" disabled={isLoading}>Limpiar</Button>
                        </div>
                    </div>
                </CardHeader>
                <CardContent>
                    {filteredProcessedPayments.length > 0 ? (renderPaymentsTable(filteredProcessedPayments, false)) : (!isLoading && <p className="text-center text-muted-foreground py-8">No hay pagos procesados que coincidan con los filtros.</p>)}
                </CardContent>
            </Card>
        </TabsContent>
      </Tabs>
      
      <Dialog open={isDeleteConfirmOpen} onOpenChange={setIsDeleteConfirmOpen}>
        <DialogContent><DialogHeader><DialogTitle>Confirmar Eliminación</DialogTitle><DialogDescription>¿Estás seguro? Se eliminará el pago. Si fue verificado, se revertirá el abono a la deuda, el ingreso en cuentas, y las transferencias de fondos asociadas. Esta acción no se puede deshacer.</DialogDescription></DialogHeader><DialogFooter><DialogClose asChild><Button variant="outline" disabled={isProcessing}>Cancelar</Button></DialogClose><Button variant="destructive" onClick={handleDeletePayment} disabled={isProcessing}>{isProcessing?<Loader2 className="mr-2 h-4 w-4 animate-spin"/>:"Eliminar Pago y Revertir"}</Button></DialogFooter></DialogContent>
      </Dialog>
      
      <Dialog open={isEditPaymentDialogOpen} onOpenChange={(isOpen) => {if(!isProcessing) setIsEditPaymentDialogOpen(isOpen)}}><DialogContent className="sm:max-w-lg"><DialogHeader><DialogTitle>Editar Pago Pendiente</DialogTitle><DialogDescription>Ajusta los detalles del pago antes de verificarlo.</DialogDescription></DialogHeader>
        <ScrollArea className="max-h-[70vh] p-1 pr-3"><div className="grid gap-4 py-4">
            <div className="space-y-1"><Label htmlFor="apply_to_invoice_edit">Aplicar Pago a*</Label>
                <Select value={selectedInvoiceId} onValueChange={setSelectedInvoiceId} disabled={isProcessing}><SelectTrigger id="apply_to_invoice_edit"><SelectValue placeholder="Selecciona..." /></SelectTrigger>
                  <SelectContent>{balanceFromAdjustment > 0 && (<SelectItem value={DEBT_ADJUSTMENT_ID}>Abono a Saldo Inicial (${balanceFromAdjustment.toFixed(2)})</SelectItem>)}{pendingInvoicesForCustomer.map(invoice => { let dueDateInfo = ""; if (invoice.dueDate && isValid(parseISO(invoice.dueDate))) { const daysDiff = differenceInDays(new Date(), parseISO(invoice.dueDate)); if (daysDiff > 0) dueDateInfo = ` (Vencida hace ${daysDiff} días)`; else if (daysDiff === 0) dueDateInfo = " (Vence Hoy)"; } const invoiceGlobalBalance = invoice.totalAmount - (initialPaymentsDataGlobal.filter(p=>p.appliedToInvoiceId === invoice.id && p.status === 'verificado').reduce((sum,p) => sum + p.amountAppliedToDebtUSD, 0)); return (<SelectItem key={invoice.id} value={invoice.id}>Factura ID: {invoice.id} ({format(parseISO(invoice.date), "dd/MM/yy")}) - Saldo: ${invoiceGlobalBalance.toFixed(2)}{dueDateInfo}</SelectItem>);})}</SelectContent>
                </Select></div>
            <div className="grid grid-cols-2 gap-4"><div className="space-y-1"><Label htmlFor="payment_date_edit">Fecha</Label><Popover open={isPaymentDatePickerOpen} onOpenChange={setIsPaymentDatePickerOpen}><PopoverTrigger asChild><Button id="payment_date_edit" variant={"outline"} className={cn("w-full justify-start text-left font-normal", !paymentDate && "text-muted-foreground")} disabled={isProcessing}><CalendarIcon className="mr-2 h-4 w-4" />{paymentDate ? format(paymentDate, "PPP", { locale: es }) : <span>Elige</span>}</Button></PopoverTrigger><PopoverContent className="w-auto p-0"><Calendar mode="single" selected={paymentDate} onSelect={(date) => { setPaymentDate(date); setIsPaymentDatePickerOpen(false); }} initialFocus locale={es} disabled={isProcessing}/></PopoverContent></Popover></div><div className="space-y-1"><Label htmlFor="payment_method_edit">Método</Label><Select value={currentPaymentMethod} onValueChange={(value) => setCurrentPaymentMethod(value as PaymentMethodType)} disabled={isProcessing}><SelectTrigger id="payment_method_edit"><SelectValue/></SelectTrigger><SelectContent>{paymentMethodList.map(method => (<SelectItem key={method} value={method}>{method}</SelectItem>))}</SelectContent></Select></div></div>
            <div className="grid grid-cols-2 gap-4"><div className="space-y-1"><Label htmlFor="payment_currency_edit">Moneda</Label><Select value={paymentCurrency} onValueChange={(value) => setPaymentCurrency(value as 'USD' | 'VES')} disabled={isProcessing}><SelectTrigger id="payment_currency_edit"><SelectValue/></SelectTrigger><SelectContent><SelectItem value="USD">USD</SelectItem><SelectItem value="VES">VES</SelectItem></SelectContent></Select></div><div className="space-y-1"><Label htmlFor="payment_amount_edit">Monto ({paymentCurrency})</Label><Input id="payment_amount_edit" type="number" value={paymentAmountInput} onChange={(e) => setPaymentAmountInput(e.target.value)} disabled={isProcessing}/></div></div>
            {(paymentCurrency === 'VES') && (<div className="space-y-1"><Label htmlFor="payment_exchange_rate_edit">Tasa Cambio</Label><Input id="payment_exchange_rate_edit" type="number" value={paymentExchangeRate} onChange={(e) => setPaymentExchangeRate(e.target.value)} disabled={isProcessing}/></div>)}
            <div className="space-y-1"><Label htmlFor="payment_ref_edit">Referencia</Label><Input id="payment_ref_edit" value={paymentReferenceNumber} onChange={(e) => setPaymentReferenceNumber(e.target.value)} disabled={isProcessing}/></div>
            <div className="grid grid-cols-2 gap-4"><div className="space-y-1"><Label htmlFor="paid_to_branch_edit">Sede Ingreso</Label><Select value={paidToBranchIdDialog} onValueChange={setPaidToBranchIdDialog} disabled={isProcessing}><SelectTrigger id="paid_to_branch_edit"><SelectValue/></SelectTrigger><SelectContent>{availableBranches.map(b => <SelectItem key={b.id} value={b.id}>{b.name}</SelectItem>)}</SelectContent></Select></div><div className="space-y-1"><Label htmlFor="paid_to_account_edit">Cuenta Ingreso</Label><Select value={paidToAccountIdDialog} onValueChange={(value) => setPaidToAccountIdDialog(value as AccountType)} disabled={isProcessing}><SelectTrigger id="paid_to_account_edit"><SelectValue/></SelectTrigger><SelectContent>{(Object.keys(accountTypeNames) as AccountType[]).map(accType => (<SelectItem key={accType} value={accType}>{accountTypeNames[accType]}</SelectItem>))}</SelectContent></Select></div></div>
        </div></ScrollArea><DialogFooter><DialogClose asChild><Button variant="outline" disabled={isProcessing}>Cancelar</Button></DialogClose><Button onClick={handleSaveEditedPayment} disabled={isProcessing}>Guardar Cambios</Button></DialogFooter></DialogContent></Dialog>
        <Dialog open={isNotesDialogOpen} onOpenChange={setIsNotesDialogOpen}>
            <DialogContent>
                <DialogHeader>
                    <DialogTitle>Notas del Pago</DialogTitle>
                </DialogHeader>
                <div className="py-4">
                    <p className="text-sm text-muted-foreground whitespace-pre-wrap">{notesToView}</p>
                </div>
                <DialogFooter>
                    <Button variant="outline" onClick={() => setIsNotesDialogOpen(false)}>Cerrar</Button>
                </DialogFooter>
            </DialogContent>
        </Dialog>
    </div>
  );
}

// --- pending-fund-transfers ---



"use client";

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { PageHeader } from '@/components/page-header';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription, CardFooter } from '@/components/ui/card';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from '@/components/ui/alert-dialog';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogClose } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { CheckCircle2, History, Loader2, Shuffle, Edit, Save, DollarSign, Banknote, Landmark, Trash2 } from 'lucide-react';
import { useToast } from "@/hooks/use-toast";
import {
  pendingFundTransfersData as initialPendingFundTransfersData,
  savePendingFundTransfersData,
  type PendingFundTransfer,
  loadFromLocalStorageForBranch,
  saveToLocalStorageForBranch,
  type CompanyAccountsData,
  type AccountTransaction,
  accountTypeNames,
  type AccountType,
  KEYS,
  loadExchangeRate, 
} from '@/lib/data-storage';
import { format, parseISO, isValid } from 'date-fns';
import { es } from 'date-fns/locale';
import { Badge } from '@/components/ui/badge';
import { cn } from '@/lib/utils';
import { FormattedNumber } from '@/components/ui/formatted-number';

type TransferGroup = {
  groupKey: string; // e.g., 'vesElectronic-VES'
  count: number;
  totalAmount: number;
  currency: 'USD' | 'VES';
  icon: React.ElementType;
  title: string;
};

export default function PendingFundTransfersPage() {
  const { toast } = useToast();
  const [pendingTransfers, setPendingTransfers] = useState<PendingFundTransfer[]>([]);
  const [completedTransfers, setCompletedTransfers] = useState<PendingFundTransfer[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isProcessing, setIsProcessing] = useState<string | null>(null);

  const [isEditNotesDialogOpen, setIsEditNotesDialogOpen] = useState(false);
  const [editingTransferNotes, setEditingTransferNotes] = useState<PendingFundTransfer | null>(null);
  const [currentNotes, setCurrentNotes] = useState('');

  const [isDeleteConfirmOpen, setIsDeleteConfirmOpen] = useState(false);
  const [transferToDeleteId, setTransferToDeleteId] = useState<string | null>(null);
  const [isDeleteNCConfirmOpen, setIsDeleteNCConfirmOpen] = useState(false);

  const loadTransfers = useCallback(() => {
    setIsLoading(true);
    const allTransfers = [...initialPendingFundTransfersData].sort((a, b) =>
      parseISO(b.creationTimestamp).getTime() - parseISO(a.creationTimestamp).getTime()
    );
    setPendingTransfers(allTransfers.filter(t => t.status === 'pendiente'));
    setCompletedTransfers(allTransfers.filter(t => t.status === 'completada'));
    setIsLoading(false);
  }, []);

  useEffect(() => {
    loadTransfers();
    const handleDataUpdate = (event: Event) => {
      const customEvent = event as CustomEvent;
      if (customEvent.detail?.key === KEYS.PENDING_FUND_TRANSFERS ||
          customEvent.detail?.key === KEYS.COMPANY_ACCOUNTS ||
          customEvent.detail?.key === KEYS.ACCOUNT_TRANSACTIONS) {
        loadTransfers();
      }
    };
    window.addEventListener('data-updated', handleDataUpdate);
    return () => {
      window.removeEventListener('data-updated', handleDataUpdate);
    };
  }, [loadTransfers]);

  const handleCompleteTransfer = (transferId: string, notes?: string) => {
    setIsProcessing(transferId);
    let currentTransfers = [...initialPendingFundTransfersData];
    const transferIndex = currentTransfers.findIndex(t => t.id === transferId);

    if (transferIndex === -1) {
      toast({ title: "Error", description: "Transferencia no encontrada.", variant: "destructive" });
      setIsProcessing(null);
      return;
    }

    const transfer = { ...currentTransfers[transferIndex] };
    if (transfer.status === 'completada') {
      toast({ title: "Info", description: "Esta transferencia ya fue completada.", variant: "default" });
      setIsProcessing(null);
      return;
    }
    
    // Prioritize stored rate, then load historical, finally load current as last resort
    const rate = transfer.exchangeRateAtPayment || loadExchangeRate(parseISO(transfer.creationTimestamp));

    const fromAccountTypeToUse: AccountType = transfer.originalPaymentAccountId || 'usdCash';
    const toAccountTypeToUse: AccountType = transfer.originalPaymentAccountId || 'usdCash';
    const transactionCurrencyBase: 'USD' | 'VES' = transfer.amountVES && transfer.amountVES > 0 ? 'VES' : (transfer.originalPaymentCurrency || 'USD');


    // 1. Egreso de la sede origen (fromBranchId)
    let fromBranchAccounts = loadFromLocalStorageForBranch<CompanyAccountsData>(KEYS.COMPANY_ACCOUNTS, transfer.fromBranchId, true);
    let fromBranchTransactions = loadFromLocalStorageForBranch<AccountTransaction[]>(KEYS.ACCOUNT_TRANSACTIONS, transfer.fromBranchId);
    const fromAccount = fromBranchAccounts[fromAccountTypeToUse];

    if (!fromAccount) {
        toast({title: "Error Cuenta Origen", description: `Cuenta ${accountTypeNames[fromAccountTypeToUse]} no hallada en ${transfer.fromBranchName}.`, variant:"destructive"});
        setIsProcessing(null); return;
    }
     if (fromAccount.currency !== transactionCurrencyBase) {
        toast({title: "Error de Moneda", description: `La cuenta de origen ${accountTypeNames[fromAccountTypeToUse]} en ${transfer.fromBranchName} es ${fromAccount.currency} pero la transferencia es en ${transactionCurrencyBase}. No se puede procesar.`, variant:"destructive", duration: 8000});
        setIsProcessing(null); return;
    }
    
    let amountInFromCurrency = 0;
    let fromOtherAmount: number | undefined = undefined;

    if (transactionCurrencyBase === 'VES') {
        amountInFromCurrency = transfer.amountVES || 0;
        if (rate > 0) {
            fromOtherAmount = amountInFromCurrency / rate; 
        }
    } else { // transactionCurrencyBase === 'USD'
        amountInFromCurrency = transfer.amountUSD; 
        if (rate > 0) {
            fromOtherAmount = transfer.amountUSD * rate; 
        }
    }


    const egressTx: AccountTransaction = {
      id: `TRN-TFO-${transfer.id}-${Date.now().toString().slice(-3)}`,
      date: format(new Date(), "yyyy-MM-dd"),
      description: `Transferencia de fondos a ${transfer.toBranchName} (Venta: ${transfer.saleId}) desde cta. ${accountTypeNames[fromAccountTypeToUse]}`,
      type: 'egreso',
      accountId: fromAccountTypeToUse,
      amount: parseFloat(amountInFromCurrency.toFixed(2)),
      currency: transactionCurrencyBase,
      exchangeRateOnTransactionDate: rate > 0 ? rate : undefined,
      amountInOtherCurrency: fromOtherAmount ? parseFloat(fromOtherAmount.toFixed(2)) : undefined,
      category: 'Transferencia de Fondos',
      sourceModule: 'Transferencia de Fondos',
      sourceId: transfer.id,
      timestamp: new Date().toISOString(),
    };
    fromAccount.balance = parseFloat((fromAccount.balance - amountInFromCurrency).toFixed(2));
    egressTx.balanceAfterTransaction = fromAccount.balance;
    fromAccount.lastTransactionDate = new Date().toISOString();
    fromBranchTransactions = [egressTx, ...fromBranchTransactions];
    saveToLocalStorageForBranch<CompanyAccountsData>(KEYS.COMPANY_ACCOUNTS, transfer.fromBranchId, fromBranchAccounts);
    saveToLocalStorageForBranch<AccountTransaction[]>(KEYS.ACCOUNT_TRANSACTIONS, transfer.fromBranchId, fromBranchTransactions);

    // 2. Ingreso a la sede destino (toBranchId)
    let toBranchAccounts = loadFromLocalStorageForBranch<CompanyAccountsData>(KEYS.COMPANY_ACCOUNTS, transfer.toBranchId, true);
    let toBranchTransactions = loadFromLocalStorageForBranch<AccountTransaction[]>(KEYS.ACCOUNT_TRANSACTIONS, transfer.toBranchId);
    const toAccount = toBranchAccounts[toAccountTypeToUse];

    if (!toAccount) {
        toast({title: "Error Cuenta Destino", description: `Cuenta ${accountTypeNames[toAccountTypeToUse]} no hallada en ${transfer.toBranchName}.`, variant:"destructive"});
        fromAccount.balance = parseFloat((fromAccount.balance + amountInFromCurrency).toFixed(2)); // Revertir
        fromBranchTransactions = fromBranchTransactions.filter(tx => tx.id !== egressTx.id);
        saveToLocalStorageForBranch<CompanyAccountsData>(KEYS.COMPANY_ACCOUNTS, transfer.fromBranchId, fromBranchAccounts);
        saveToLocalStorageForBranch<AccountTransaction[]>(KEYS.ACCOUNT_TRANSACTIONS, transfer.fromBranchId, fromBranchTransactions);
        setIsProcessing(null); return;
    }
    if (toAccount.currency !== transactionCurrencyBase) {
        toast({title: "Error de Moneda", description: `La cuenta destino ${accountTypeNames[toAccountTypeToUse]} en ${transfer.toBranchName} es ${toAccount.currency} pero la transferencia es en ${transactionCurrencyBase}. Transferencia revertida.`, variant:"destructive", duration: 8000});
        fromAccount.balance = parseFloat((fromAccount.balance + amountInFromCurrency).toFixed(2)); 
        fromBranchTransactions = fromBranchTransactions.filter(tx => tx.id !== egressTx.id);
        saveToLocalStorageForBranch<CompanyAccountsData>(KEYS.COMPANY_ACCOUNTS, transfer.fromBranchId, fromBranchAccounts);
        saveToLocalStorageForBranch<AccountTransaction[]>(KEYS.ACCOUNT_TRANSACTIONS, transfer.fromBranchId, fromBranchTransactions);
        setIsProcessing(null); return;
    }

    let amountInToCurrency = amountInFromCurrency;
    let toOtherAmount = fromOtherAmount;

    const ingressTx: AccountTransaction = {
      id: `TRN-TFI-${transfer.id}-${Date.now().toString().slice(-3)}`,
      date: format(new Date(), "yyyy-MM-dd"),
      description: `Recepción de fondos de ${transfer.fromBranchName} (Venta: ${transfer.saleId}) a cta. ${accountTypeNames[toAccountTypeToUse]}`,
      type: 'ingreso',
      accountId: toAccountTypeToUse,
      amount: parseFloat(amountInToCurrency.toFixed(2)),
      currency: transactionCurrencyBase,
      exchangeRateOnTransactionDate: rate > 0 ? rate : undefined,
      amountInOtherCurrency: toOtherAmount ? parseFloat(toOtherAmount.toFixed(2)) : undefined,
      category: 'Transferencia de Fondos',
      sourceModule: 'Transferencia de Fondos',
      sourceId: transfer.id,
      timestamp: new Date().toISOString(),
    };
    toAccount.balance = parseFloat((toAccount.balance + amountInToCurrency).toFixed(2));
    ingressTx.balanceAfterTransaction = toAccount.balance;
    toAccount.lastTransactionDate = new Date().toISOString();
    toBranchTransactions = [ingressTx, ...toBranchTransactions];
    saveToLocalStorageForBranch<CompanyAccountsData>(KEYS.COMPANY_ACCOUNTS, transfer.toBranchId, toBranchAccounts);
    saveToLocalStorageForBranch<AccountTransaction[]>(KEYS.ACCOUNT_TRANSACTIONS, transfer.toBranchId, toBranchTransactions);

    // 3. Actualizar estado de la transferencia pendiente
    transfer.status = 'completada';
    transfer.completionTimestamp = new Date().toISOString();
    transfer.notes = notes || transfer.notes;
    transfer.fromAccountId = fromAccountTypeToUse; 
    transfer.toAccountId = toAccountTypeToUse;     
    transfer.exchangeRateAtPayment = rate; // Guardar la tasa que se usó
    currentTransfers[transferIndex] = transfer;
    savePendingFundTransfersData(currentTransfers);

    toast({ title: "Transferencia Completada", description: `Fondos (${transactionCurrencyBase}) transferidos de ${transfer.fromBranchName} (${accountTypeNames[fromAccountTypeToUse]}) a ${transfer.toBranchName} (${accountTypeNames[toAccountTypeToUse]}).` });
    setIsProcessing(null);
  };
  
  const handleCompleteBatch = (groupKey: string) => {
    const transfersToComplete = pendingTransfers.filter(t => {
      if (!t.originalPaymentAccountId) return false;
      const currency = (t.amountVES !== undefined && t.amountVES > 0) ? 'VES' : 'USD';
      return `${t.originalPaymentAccountId}-${currency}` === groupKey;
    });

    if (transfersToComplete.length === 0) {
      toast({ title: "Info", description: "No hay transferencias para este grupo.", variant: "default"});
      return;
    }
    
    transfersToComplete.forEach(transfer => {
      handleCompleteTransfer(transfer.id);
    });
    
    // Recargar los datos al final del lote
    loadTransfers();
  };

  const handleOpenDeleteDialog = (transferId: string) => {
    setTransferToDeleteId(transferId);
    setIsDeleteConfirmOpen(true);
  };
  
  const handleConfirmDeleteTransfer = () => {
    if (!transferToDeleteId) return;
    setIsProcessing(transferToDeleteId);
    
    let currentTransfers = [...initialPendingFundTransfersData];
    const initialLength = currentTransfers.length;
    
    currentTransfers = currentTransfers.filter(t => t.id !== transferToDeleteId);

    if (currentTransfers.length < initialLength) {
        savePendingFundTransfersData(currentTransfers);
        toast({ title: "Transferencia Eliminada", description: "La transferencia pendiente ha sido eliminada del sistema."});
        loadTransfers(); // Recargar la data para reflejar el cambio
    } else {
        toast({ title: "Error", description: "No se pudo encontrar la transferencia para eliminar.", variant: "destructive" });
    }
    
    setIsDeleteConfirmOpen(false);
    setTransferToDeleteId(null);
    setIsProcessing(null);
  };

  const handleDeleteAllCreditNoteTransfers = () => {
    setIsProcessing('batch-delete-nc');
    const currentTransfers = [...initialPendingFundTransfersData];
    const transfersToKeep = currentTransfers.filter(t => !t.isFromCreditNote);

    if (transfersToKeep.length === currentTransfers.length) {
        toast({
            title: "Sin Cambios",
            description: "No se encontraron transferencias generadas por Notas de Crédito para eliminar.",
            variant: "default"
        });
        setIsProcessing(null);
        setIsDeleteNCConfirmOpen(false);
        return;
    }

    savePendingFundTransfersData(transfersToKeep);
    toast({
        title: "Operación Exitosa",
        description: "Todas las transferencias de fondos generadas por Notas de Crédito han sido eliminadas."
    });
    loadTransfers();
    setIsProcessing(null);
    setIsDeleteNCConfirmOpen(false);
  };

  const handleOpenEditNotesDialog = (transfer: PendingFundTransfer) => {
    setEditingTransferNotes(transfer);
    setCurrentNotes(transfer.notes || '');
    setIsEditNotesDialogOpen(true);
  };

  const handleSaveNotesAndComplete = () => {
    if (editingTransferNotes) {
      handleCompleteTransfer(editingTransferNotes.id, currentNotes);
      // Cerrar el diálogo después de completar
      setIsEditNotesDialogOpen(false); 
      setEditingTransferNotes(null);
    }
  };
  
  const transferGroups = useMemo((): TransferGroup[] => {
    const groups: { [key: string]: { count: number; totalAmount: number; currency: 'USD' | 'VES'; accountId: AccountType } } = {};
    
    pendingTransfers.forEach(t => {
      if (t.isFromCreditNote) return; // No agrupar las de NC
      const accountId = t.originalPaymentAccountId;
      if (!accountId) return;

      const currency: 'USD' | 'VES' = (t.amountVES !== undefined && t.amountVES > 0) ? 'VES' : 'USD';
      const groupKey = `${accountId}-${currency}`;

      if (!groups[groupKey]) {
        groups[groupKey] = { count: 0, totalAmount: 0, currency, accountId };
      }
      
      groups[groupKey].count++;
      if (currency === 'VES') {
        groups[groupKey].totalAmount += t.amountVES || 0;
      } else {
        groups[groupKey].totalAmount += t.amountUSD;
      }
    });

    return Object.entries(groups).map(([groupKey, groupData]) => {
        const { accountId, currency } = groupData;
        return {
            groupKey,
            count: groupData.count,
            totalAmount: groupData.totalAmount,
            currency,
            icon: accountId === 'usdCash' ? DollarSign : accountId === 'vesCash' ? Banknote : Landmark,
            title: `${accountTypeNames[accountId]} (${currency})`
        };
    });
  }, [pendingTransfers]);

  const hasCreditNoteTransfers = useMemo(() => pendingTransfers.some(t => t.isFromCreditNote), [pendingTransfers]);

  const renderTransfersTable = (transfersToList: PendingFundTransfer[], isPending: boolean) => (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>ID Venta/Transf.</TableHead>
          <TableHead>De Sede</TableHead>
          <TableHead>A Sede</TableHead>
          <TableHead className="text-right">Monto Original</TableHead>
          <TableHead className="text-right">Monto (USD)</TableHead>
          <TableHead>Cta. Pago Original</TableHead>
          <TableHead className="text-right">Tasa Aplicada</TableHead>
          <TableHead>Fecha Creación</TableHead>
          <TableHead>Estado</TableHead>
          {!isPending && <TableHead>De Cuenta</TableHead>}
          {!isPending && <TableHead>A Cuenta</TableHead>}
          {!isPending && <TableHead>Fecha Completado</TableHead>}
          <TableHead>Notas</TableHead>
          {isPending && <TableHead className="text-right">Acciones</TableHead>}
        </TableRow>
      </TableHeader>
      <TableBody>
        {transfersToList.map((transfer, index) => {
            let originalAmountDisplay = <FormattedNumber value={transfer.amountUSD} prefix="$" decimalPlaces={3} />;
            const rateForDisplay = transfer.exchangeRateAtPayment || loadExchangeRate(parseISO(transfer.creationTimestamp));

            if (transfer.amountVES !== undefined && transfer.amountVES > 0) {
                originalAmountDisplay = <FormattedNumber value={transfer.amountVES} prefix="Bs. " />;
            } else if (transfer.originalPaymentCurrency === 'VES') {
                const amountVES = rateForDisplay > 0 ? transfer.amountUSD * rateForDisplay : 0;
                originalAmountDisplay = <FormattedNumber value={amountVES} prefix="Bs. " />;
            }

            return (
          <TableRow key={`${transfer.id}-${transfer.creationTimestamp}-${index}`} className={cn(transfer.isFromCreditNote && 'bg-destructive/10')}>
            <TableCell>
                <div className="font-mono text-xs">{transfer.saleId}</div>
                <div className="text-xs text-muted-foreground font-mono">{transfer.id}</div>
            </TableCell>
            <TableCell>{transfer.fromBranchName}</TableCell><TableCell>{transfer.toBranchName}</TableCell>
            <TableCell className="text-right font-semibold">{originalAmountDisplay}</TableCell>
            <TableCell className="text-right text-muted-foreground"><FormattedNumber value={transfer.amountUSD} prefix="$" decimalPlaces={3} /></TableCell>
            <TableCell>{transfer.originalPaymentAccountId ? accountTypeNames[transfer.originalPaymentAccountId] : '-'}</TableCell>
            <TableCell className="text-right text-muted-foreground text-xs">
                {transfer.originalPaymentCurrency === 'VES' ? (rateForDisplay > 0 ? rateForDisplay.toFixed(4) : 'N/A') : '-'}
            </TableCell>
            <TableCell>{format(parseISO(transfer.creationTimestamp), "dd/MM/yy HH:mm", { locale: es })}</TableCell>
            <TableCell>
              <Badge variant={transfer.status === 'completada' ? 'default' : 'secondary'}
                className={cn(transfer.status === 'completada' ? 'bg-green-500/20 text-green-700 dark:text-green-400 border-green-500/50' : 'bg-yellow-500/20 text-yellow-700 dark:text-yellow-400 border-yellow-500/50')}
              >
                {transfer.status === 'pendiente' ? 'Pendiente' : 'Completada'}
              </Badge>
            </TableCell>
            {!isPending && <TableCell>{transfer.fromAccountId ? accountTypeNames[transfer.fromAccountId] : '-'}</TableCell>}
            {!isPending && <TableCell>{transfer.toAccountId ? accountTypeNames[transfer.toAccountId] : '-'}</TableCell>}
            {!isPending && <TableCell>{transfer.completionTimestamp ? format(parseISO(transfer.completionTimestamp), "dd/MM/yy HH:mm", { locale: es }) : '-'}</TableCell>}
            <TableCell className="max-w-xs truncate" title={transfer.notes}>{transfer.notes || '-'}</TableCell>
            {isPending && (
              <TableCell className="text-right space-x-1">
                <Button
                  size="sm"
                  variant="outline"
                  onClick={() => handleOpenEditNotesDialog(transfer)}
                  disabled={isProcessing === transfer.id || transfer.isFromCreditNote}
                  className="bg-primary/10 hover:bg-primary/20 text-primary border-primary/50"
                >
                  {isProcessing === transfer.id ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <CheckCircle2 className="mr-2 h-4 w-4" />}
                  Completar
                </Button>
                <AlertDialog>
                  <AlertDialogTrigger asChild>
                     <Button variant="ghost" size="icon" className="text-destructive h-8 w-8" disabled={isProcessing === transfer.id} onClick={() => handleOpenDeleteDialog(transfer.id)}>
                       <Trash2 className="h-4 w-4" />
                    </Button>
                  </AlertDialogTrigger>
                  <AlertDialogContent>
                    <AlertDialogHeader>
                      <AlertDialogTitle>Confirmar Eliminación</AlertDialogTitle>
                      <AlertDialogDescription>
                          ¿Estás seguro de que deseas eliminar esta transferencia pendiente? Esta acción no se puede deshacer y no afectará los saldos de las cuentas.
                      </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                      <AlertDialogCancel onClick={() => setTransferToDeleteId(null)}>Cancelar</AlertDialogCancel>
                      <AlertDialogAction onClick={() => handleConfirmDeleteTransfer()} disabled={!!isProcessing}>
                          {isProcessing ? <Loader2 className="mr-2 h-4 w-4 animate-spin"/> : 'Sí, Eliminar'}
                      </AlertDialogAction>
                    </AlertDialogFooter>
                  </AlertDialogContent>
                </AlertDialog>
              </TableCell>
            )}
          </TableRow>
        )})}
      </TableBody>
    </Table>
  );

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[calc(100vh-10rem)]">
        <Loader2 className="h-12 w-12 animate-spin text-primary" />
        <p className="ml-4 text-lg">Cargando transferencias de fondos...</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <PageHeader
        title="Transferencias de Fondos Pendientes entre Sedes"
        description="Gestiona las transferencias de dinero que deben realizarse entre sedes para conciliar pagos globales. Al completar, se crearán los movimientos en las cuentas de ambas sedes."
        icon={Shuffle}
        actions={
            <div className="flex space-x-2">
                {hasCreditNoteTransfers && (
                    <AlertDialog open={isDeleteNCConfirmOpen} onOpenChange={setIsDeleteNCConfirmOpen}>
                      <AlertDialogTrigger asChild>
                         <Button variant="destructive" disabled={isProcessing !== null}>
                            <Trash2 className="mr-2 h-4 w-4"/>Eliminar Transferencias de NC
                         </Button>
                      </AlertDialogTrigger>
                      <AlertDialogContent>
                        <AlertDialogHeader>
                            <AlertDialogTitle>Confirmar Eliminación en Lote</AlertDialogTitle>
                            <AlertDialogDescription>
                                ¿Estás seguro de que deseas eliminar TODAS las transferencias de fondos pendientes generadas por Notas de Crédito? Esta acción no se puede deshacer.
                            </AlertDialogDescription>
                        </AlertDialogHeader>
                        <AlertDialogFooter>
                            <AlertDialogCancel disabled={isProcessing !== null}>Cancelar</AlertDialogCancel>
                            <AlertDialogAction onClick={handleDeleteAllCreditNoteTransfers} disabled={isProcessing !== null} className={cn(isProcessing === 'batch-delete-nc' && 'pointer-events-none')}>
                               {isProcessing === 'batch-delete-nc' ? <Loader2 className="mr-2 h-4 w-4 animate-spin"/> : 'Sí, Eliminar Todas'}
                            </AlertDialogAction>
                        </AlertDialogFooter>
                      </AlertDialogContent>
                    </AlertDialog>
                )}
            </div>
        }
      />
      
      <Tabs defaultValue="pending">
        <TabsList className="grid w-full grid-cols-2 sm:w-[400px]">
          <TabsTrigger value="pending">
            <CheckCircle2 className="mr-2 h-4 w-4 text-yellow-600" /> Pendientes ({pendingTransfers.length})
          </TabsTrigger>
          <TabsTrigger value="completed">
            <History className="mr-2 h-4 w-4" /> Completadas ({completedTransfers.length})
          </TabsTrigger>
        </TabsList>

        <TabsContent value="pending">
            {pendingTransfers.length > 0 && (
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
              {transferGroups.map(group => (
                <Card key={group.groupKey} className="shadow-md">
                  <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                    <CardTitle className="text-sm font-medium">{group.title}</CardTitle>
                    <group.icon className="h-4 w-4 text-muted-foreground" />
                  </CardHeader>
                  <CardContent>
                    <div className="text-2xl font-bold">
                        <FormattedNumber value={group.totalAmount} prefix={group.currency === 'USD' ? '$' : 'Bs. '} />
                    </div>
                    <p className="text-xs text-muted-foreground">{group.count} transferencia(s) pendiente(s)</p>
                  </CardContent>
                  <CardFooter>
                    <AlertDialog>
                      <AlertDialogTrigger asChild>
                         <Button className="w-full" size="sm" disabled={isProcessing !== null || group.count === 0}><CheckCircle2 className="mr-2 h-4 w-4"/>Completar Todas</Button>
                      </AlertDialogTrigger>
                      <AlertDialogContent>
                          <AlertDialogHeader>
                            <AlertDialogTitle>¿Confirmar lote?</AlertDialogTitle>
                            <AlertDialogDescription>
                                Se completarán {group.count} transferencias por un total de <FormattedNumber value={group.totalAmount} prefix={group.currency === 'USD' ? '$' : 'Bs. '} />. Esta acción no se puede deshacer.
                            </AlertDialogDescription>
                          </AlertDialogHeader>
                           <AlertDialogFooter>
                            <AlertDialogCancel>Cancelar</AlertDialogCancel>
                            <AlertDialogAction onClick={() => handleCompleteBatch(group.groupKey)}>Confirmar y Procesar</AlertDialogAction>
                           </AlertDialogFooter>
                      </AlertDialogContent>
                    </AlertDialog>
                  </CardFooter>
                </Card>
              ))}
            </div>
            )}
          <Card className="shadow-lg">
            <CardHeader>
              <CardTitle>Transferencias Pendientes</CardTitle>
              <CardDescription>
                {pendingTransfers.length > 0
                  ? "Fondos que deben ser movidos entre las cuentas de las sedes."
                  : "No hay transferencias de fondos pendientes."}
              </CardDescription>
            </CardHeader>
            <CardContent>
              {pendingTransfers.length > 0 ? (
                renderTransfersTable(pendingTransfers, true)
              ) : (
                <p className="text-center text-muted-foreground py-8">No hay transferencias pendientes.</p>
              )}
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="completed">
          <Card className="shadow-lg">
            <CardHeader>
              <CardTitle>Historial de Transferencias Completadas</CardTitle>
              <CardDescription>Transferencias de fondos entre sedes que ya han sido procesadas.</CardDescription>
            </CardHeader>
            <CardContent>
              {completedTransfers.length > 0 ? (
                renderTransfersTable(completedTransfers, false)
              ) : (
                <p className="text-center text-muted-foreground py-8">No hay transferencias completadas en el historial.</p>
              )}
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
      
      <Dialog open={isEditNotesDialogOpen} onOpenChange={(isOpen) => { if (!isProcessing) setIsEditNotesDialogOpen(isOpen); }}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Completar Transferencia de Fondos</DialogTitle>
            {editingTransferNotes && (
              <DialogDescription>
                <p>Estás a punto de marcar la transferencia <strong>{editingTransferNotes.id}</strong> como completada.
                Esto moverá el equivalente a <strong><FormattedNumber value={editingTransferNotes.amountUSD} prefix="$" decimalPlaces={3} /> USD</strong>
                desde la cuenta <strong>{editingTransferNotes.originalPaymentAccountId ? accountTypeNames[editingTransferNotes.originalPaymentAccountId] : 'Desconocida'} ({editingTransferNotes.originalPaymentCurrency || 'USD'})</strong> de la sede <strong>{editingTransferNotes.fromBranchName}</strong>
                hacia la sede <strong>{editingTransferNotes.toBranchName}</strong>.</p>
                {editingTransferNotes.originalPaymentCurrency === 'VES' && (
                    <p className="text-xs text-muted-foreground mt-2">
                        Tasa a aplicar (del día del pago): <FormattedNumber value={editingTransferNotes.exchangeRateAtPayment || loadExchangeRate(parseISO(editingTransferNotes.creationTimestamp))} decimalPlaces={4} />
                    </p>
                )}
              </DialogDescription>
            )}
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="space-y-1">
              <Label htmlFor="transfer_notes">Notas Adicionales (Opcional)</Label>
              <Textarea
                id="transfer_notes"
                value={currentNotes}
                onChange={(e) => setCurrentNotes(e.target.value)}
                placeholder="ej., Transferencia bancaria #123, Entregado en efectivo por..."
                disabled={isProcessing === editingTransferNotes?.id}
              />
            </div>
          </div>
          <DialogFooter>
            <DialogClose asChild><Button variant="outline" disabled={isProcessing === editingTransferNotes?.id}>Cancelar</Button></DialogClose>
            <Button onClick={handleSaveNotesAndComplete} disabled={isProcessing === editingTransferNotes?.id}>
              {isProcessing === editingTransferNotes?.id ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Save className="mr-2 h-4 w-4" />}
              Confirmar y Completar
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}

// --- price-comparison ---


"use client";

import React, { useState, useEffect, useMemo } from 'react';
import { PageHeader } from '@/components/page-header';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { ListFilter, Loader2, Star, Info } from 'lucide-react'; // Removed TrendingUp
import {
  suppliersData as initialSuppliersData,
  getCurrentRawMaterialOptions,
  type Supplier,
  type SupplierPriceListItem, // Esta es la interfaz original
  type PriceHistoryEntry,     // Importar PriceHistoryEntry
  loadExchangeRate,
  getBestPriceInfo,
  type BestPriceInfo,
  convertMaterialToBaseUnit,
  getCurrentPriceFromHistory // Asegurar que esta función esté importada y se use
} from '@/lib/data-storage';
import { format, parseISO } from 'date-fns';
import { es } from 'date-fns/locale';
import { Badge } from '@/components/ui/badge';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { Button } from "@/components/ui/button";
import { FormattedNumber } from '@/components/ui/formatted-number';

// Definición actualizada de ComparedPriceItem
interface ComparedPriceItem {
  // Propiedades de SupplierPriceListItem que queremos mantener explícitamente
  id: string;
  rawMaterialName: string;
  unit: string;
  // priceHistory: PriceHistoryEntry[]; // Opcional: mantenerla si es útil para depuración o futuras características

  // Propiedades específicas/calculadas para la vista de comparación
  supplierId: string;
  supplierName: string;
  unitPrice: number; // Precio de compra actual de la unidad original (ej. precio por saco, precio por caja)
  lastUpdated: string; // Fecha del `unitPrice` actual
  pricePerBaseUnit?: number; // Precio calculado por unidad base (ej. precio por kg, precio por L)
  baseUnitForComparison?: string; // La unidad base usada para pricePerBaseUnit (ej. kg, L)
}


export default function PriceComparisonPage() {
  const [allSuppliers, setAllSuppliers] = useState<Supplier[]>([]);
  const [rawMaterialOptions, setRawMaterialOptions] = useState<string[]>([]);
  const [selectedRawMaterial, setSelectedRawMaterial] = useState<string>('');

  const [allPricesForSelectedMaterial, setAllPricesForSelectedMaterial] = useState<ComparedPriceItem[]>([]);
  const [bestPriceInfo, setBestPriceInfo] = useState<BestPriceInfo | null>(null);

  const [isLoading, setIsLoading] = useState(true);
  const [exchangeRate, setExchangeRate] = useState<number>(0);

  useEffect(() => {
    setIsLoading(true);
    setAllSuppliers([...initialSuppliersData]);
    const options = getCurrentRawMaterialOptions().sort((a,b) => a.localeCompare(b));
    setRawMaterialOptions(options);
    setExchangeRate(loadExchangeRate());
    setIsLoading(false);
  }, []);

  useEffect(() => {
    if (selectedRawMaterial && allSuppliers.length > 0) {
      const bestPrice = getBestPriceInfo(selectedRawMaterial);
      setBestPriceInfo(bestPrice);

      const allPrices: ComparedPriceItem[] = [];
      allSuppliers.forEach(supplier => {
        if (supplier.priceList) {
          supplier.priceList.forEach(priceItem => { // priceItem es SupplierPriceListItem
            if (priceItem.rawMaterialName === selectedRawMaterial) {
              const currentPriceEntry = getCurrentPriceFromHistory(priceItem.priceHistory);
              
              const resolvedUnitPrice = currentPriceEntry ? currentPriceEntry.price : 0;
              const resolvedLastUpdated = currentPriceEntry ? currentPriceEntry.date : new Date().toISOString().split('T')[0];

              const conversion = convertMaterialToBaseUnit(1, priceItem.unit, priceItem.rawMaterialName);
              const baseUnitsPerPurchaseUnit = conversion.quantity;
              const pricePerBase = baseUnitsPerPurchaseUnit > 0 && resolvedUnitPrice >= 0
                                   ? resolvedUnitPrice / baseUnitsPerPurchaseUnit
                                   : Infinity;

              allPrices.push({
                // Propiedades de SupplierPriceListItem
                id: priceItem.id,
                rawMaterialName: priceItem.rawMaterialName,
                unit: priceItem.unit,
                // priceHistory: priceItem.priceHistory, // Opcional si no se necesita más

                // Propiedades añadidas/calculadas
                supplierId: supplier.id,
                supplierName: supplier.name,
                unitPrice: resolvedUnitPrice,
                lastUpdated: resolvedLastUpdated,
                pricePerBaseUnit: pricePerBase,
                baseUnitForComparison: conversion.unit,
              });
            }
          });
        }
      });

      allPrices.sort((a, b) => {
        if ((a.pricePerBaseUnit ?? Infinity) < (b.pricePerBaseUnit ?? Infinity)) return -1;
        if ((a.pricePerBaseUnit ?? Infinity) > (b.pricePerBaseUnit ?? Infinity)) return 1;
        if (a.unit.localeCompare(b.unit) !== 0) return a.unit.localeCompare(b.unit);
        return a.supplierName.localeCompare(b.supplierName);
      });
      setAllPricesForSelectedMaterial(allPrices);

    } else {
      setBestPriceInfo(null);
      setAllPricesForSelectedMaterial([]);
    }
  }, [selectedRawMaterial, allSuppliers]);

  return (
    <div className="space-y-6">
      <PageHeader
        title="Comparación de Precios de Materia Prima"
        description="Selecciona una materia prima para ver la mejor opción de proveedor y una lista comparativa de todos los precios disponibles."
        icon={ListFilter}
      />

      <Card className="shadow-lg">
        <CardHeader>
          <CardTitle>Seleccionar Materia Prima</CardTitle>
          <Select
            value={selectedRawMaterial}
            onValueChange={setSelectedRawMaterial}
            disabled={isLoading || rawMaterialOptions.length === 0}
          >
            <SelectTrigger className="w-full md:w-1/2 lg:w-1/3">
              <SelectValue placeholder="Elige una materia prima..." />
            </SelectTrigger>
            <SelectContent>
              {rawMaterialOptions.length > 0 ? (
                rawMaterialOptions.map(option => (
                  <SelectItem key={option} value={option}>{option}</SelectItem>
                ))
              ) : (
                <SelectItem value="no-options" disabled>
                  No hay materias primas disponibles. Añádelas en Órdenes de Compra &gt; Gestionar.
                </SelectItem>
              )}
            </SelectContent>
          </Select>
        </CardHeader>
        {isLoading && (
          <CardContent className="flex justify-center items-center py-8">
            <Loader2 className="h-8 w-8 animate-spin text-primary" />
            <p className="ml-2">Cargando datos...</p>
          </CardContent>
        )}

        {!isLoading && selectedRawMaterial && bestPriceInfo && (
          <CardContent className="pt-4">
            <Card className="bg-primary/5 border-primary shadow-md">
              <CardHeader>
                <CardTitle className="flex items-center text-lg text-primary">
                  <Star className="mr-2 h-5 w-5 text-yellow-500 fill-yellow-400" />
                  Mejor Opción de Proveedor para: {selectedRawMaterial}
                </CardTitle>
                <CardDescription>
                  Basado en el precio por unidad base ({bestPriceInfo.baseUnit}) y la última actualización.
                </CardDescription>
              </CardHeader>
              <CardContent className="space-y-2">
                <p><strong className="font-semibold">Proveedor:</strong> {bestPriceInfo.supplierName}</p>
                <div className="flex items-center">
                  <strong className="font-semibold">Precio por {bestPriceInfo.baseUnit}:</strong>
                  <Badge variant="secondary" className="ml-2 text-base">
                    <FormattedNumber value={bestPriceInfo.pricePerBaseUnit} prefix="$" decimalPlaces={3} />
                  </Badge>
                  <span className="text-sm text-muted-foreground ml-1">
                    (<FormattedNumber value={exchangeRate > 0 ? bestPriceInfo.pricePerBaseUnit * exchangeRate : undefined} prefix="Bs. " />)
                  </span>
                </div>
                <p>
                    <strong className="font-semibold">Precio Original Proveedor:</strong> <FormattedNumber value={bestPriceInfo.originalUnitPrice} prefix="$" /> por {bestPriceInfo.originalUnit}
                </p>
                <p><strong className="font-semibold">Última Actualización:</strong> {format(parseISO(bestPriceInfo.lastUpdated), "dd/MM/yyyy", { locale: es })}</p>
              </CardContent>
            </Card>
          </CardContent>
        )}

        {!isLoading && selectedRawMaterial && (
          <CardContent className="pt-4">
            <CardHeader className="px-0 pt-0 pb-4">
              <CardTitle className="text-lg">Todos los Precios Disponibles para: {selectedRawMaterial}</CardTitle>
              <CardDescription>Lista completa de precios de todos los proveedores para la materia prima seleccionada, ordenados por el precio más bajo por unidad base.</CardDescription>
            </CardHeader>
            {allPricesForSelectedMaterial.length > 0 ? (
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Proveedor</TableHead>
                    <TableHead className="text-right">Precio Unit. Original (USD)</TableHead>
                    <TableHead>Unidad Original</TableHead>
                    <TableHead className="text-right">
                      Precio por Unidad Base (USD/{allPricesForSelectedMaterial[0]?.baseUnitForComparison || 'Unidad Base'})
                       <TooltipProvider>
                        <Tooltip>
                            <TooltipTrigger asChild><Button variant="ghost" size="icon" className="ml-1 h-4 w-4 p-0 align-middle"><Info className="h-3 w-3 text-muted-foreground" /></Button></TooltipTrigger>
                            <TooltipContent className="max-w-xs"><p>Precio convertido a una unidad base común (ej. kg, L) para comparación equitativa.</p></TooltipContent>
                        </Tooltip>
                      </TooltipProvider>
                    </TableHead>
                    <TableHead>Última Actualización</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {allPricesForSelectedMaterial.map((item) => (
                    <TableRow key={`${item.supplierId}-${item.id}`} className={item.supplierId === bestPriceInfo?.supplierId && item.unitPrice === bestPriceInfo?.originalUnitPrice ? "bg-green-500/10" : ""}>
                      <TableCell className="font-medium">{item.supplierName}</TableCell>
                      <TableCell className="text-right">
                        <FormattedNumber value={item.unitPrice} prefix="$" />
                      </TableCell>
                      <TableCell>{item.unit}</TableCell>
                      <TableCell className="text-right">
                        {item.pricePerBaseUnit && isFinite(item.pricePerBaseUnit)
                          ? <FormattedNumber value={item.pricePerBaseUnit} prefix="$" decimalPlaces={3} />
                          : 'N/A'}
                      </TableCell>
                      <TableCell>{format(parseISO(item.lastUpdated), "dd/MM/yyyy", { locale: es })}</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            ) : (
              <p className="text-center text-muted-foreground py-8">
                No se encontraron precios para "{selectedRawMaterial}" en las listas de tus proveedores.
              </p>
            )}
          </CardContent>
        )}
        {!isLoading && !selectedRawMaterial && (
           <CardContent>
                <p className="text-center text-muted-foreground py-8">Por favor, selecciona una materia prima para ver la comparación de precios.</p>
           </CardContent>
        )}
      </Card>
    </div>
  );
}

// --- production ---


"use client";

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { PageHeader } from '@/components/page-header';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from '@/components/ui/alert-dialog';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogClose } from '@/components/ui/dialog';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';
import { Layers, PlusCircle, Calendar as CalendarIcon, Edit, Trash2, MoreHorizontal, Loader2, Filter, Info, Search, Trash } from 'lucide-react';
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Calendar } from "@/components/ui/calendar";
import { format, parseISO, isWithinInterval, startOfDay, endOfDay, isSameMonth, isSameYear, startOfWeek, endOfWeek, addDays, isValid } from "date-fns";
import type { DateRange } from "react-day-picker";
import { es } from "date-fns/locale";
import { cn } from "@/lib/utils";
import { useToast } from "@/hooks/use-toast";
import {
  type Product,
  saveProductionLogData,
  type ProductionLogEntry,
  saveRawMaterialInventoryData,
  loadRawMaterialInventoryData,
  type RawMaterialInventoryItem,
  normalizeUnit,
  convertMaterialToBaseUnit,
  loadExchangeRate,
  savePurchaseOrdersData,
  type PurchaseOrder,
  getBestPriceInfo,
  KEYS,
  type Recipe,
  calculateDynamicRecipeCost,
  type Employee,
  loadExpenseFixedCategories,
  type ExpenseFixedCategory,
  WEEKS_IN_MONTH,
  getDirectIngredientsForRecipe,
  VALID_BASE_UNITS,
  getActiveBranchId,
  availableBranches,
  loadFromLocalStorageForBranch,
  saveToLocalStorageForBranch,
  loadProductsForBranch,
  saveProductsDataForBranch,
  calculateGoalStatus,
  loadPurchaseOrdersFromStorage,
  calculatePackagingCost,
  type Branch,
  inventoryTransfersData,
  saveInventoryTransfersData,
  type InventoryTransfer
} from '@/lib/data-storage';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { FormattedNumber } from '@/components/ui/formatted-number';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';


const batchSizeOptions = [
  { label: "1/4 Saco", value: 0.25 },
  { label: "1/2 Saco", value: 0.5 },
  { label: "3/4 Saco", value: 0.75 },
  { label: "1 Saco", value: 1.0 },
  { label: "1.5 Sacos", value: 1.5 },
  { label: "2 Sacos", value: 2.0 },
  { label: "2.5 Sacos", value: 2.5 },
  { label: "3 Sacos", value: 3.0 },
  { label: "3.5 Sacos", value: 3.5 },
  { label: "4 Sacos", value: 4.0 },
  { label: "4.5 Sacos", value: 4.5 },
  { label: "5 Sacos", value: 5.0 },
  { label: "5.5 Sacos", value: 5.5 },
  { label: "6 Sacos", value: 6.0 },
  { label: "6.5 Sacos", value: 6.5 },
  { label: "7 Sacos", value: 7.0 },
  { label: "7.5 Sacos", value: 7.5 },
  { label: "8 Sacos", value: 8.0 },
  { label: "8.5 Sacos", value: 8.5 },
  { label: "9 Sacos", value: 9.0 },
  { label: "9.5 Sacos", value: 9.5 },
  { label: "10 Sacos", value: 10.0 },
];


export default function ProductionPage() {
  const { toast } = useToast();

  const [productOptionsFromRecipes, setProductOptionsFromRecipes] = useState<{id: string, name: string}[]>([]);

  const [allProductionLog, setAllProductionLog] = useState<ProductionLogEntry[]>([]);
  const [filteredProductionLog, setFilteredProductionLog] = useState<ProductionLogEntry[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [exchangeRate, setExchangeRate] = useState<number>(0);

  const [newProductName, setNewProductName] = useState<string>('');
  const [newBatchSizeMultiplier, setNewBatchSizeMultiplier] = useState<number>(1.0);
  const [newExpectedQuantity, setNewExpectedQuantity] = useState<string>('');
  const [newActualQuantity, setNewActualQuantity] = useState<string>('');
  const [newDate, setNewDate] = React.useState<Date | undefined>(new Date());
  const [newStaff, setNewStaff] = useState<string>('');
  const [newUnitPrice, setNewUnitPrice] = useState<string>('');
  const [newBatchNumber, setNewBatchNumber] = useState<string>('');
  const [selectedBagName, setSelectedBagName] = useState<string>('Bolsas 22x60');
  const [selectedLabelName, setSelectedLabelName] = useState<string>('Etiquetas');
  const [availableBags, setAvailableBags] = useState<string[]>([]);
  const [availableLabels, setAvailableLabels] = useState<string[]>([]);

  const [isEditLogDialogOpen, setIsEditLogDialogOpen] = useState(false);
  const [editingLogEntry, setEditingLogEntry] = useState<ProductionLogEntry | null>(null);
  const [originalLogEntryForEdit, setOriginalLogEntryForEdit] = useState<ProductionLogEntry | null>(null);
  const [editProduct, setEditProduct] = useState<string>('');
  const [editBatchSizeMultiplier, setEditBatchSizeMultiplier] = useState<number>(1.0);
  const [editExpectedQuantity, setEditExpectedQuantity] = useState<string>('');
  const [editActualQuantity, setEditActualQuantity] = useState<string>('');
  const [editDate, setEditDate] = React.useState<Date | undefined>(undefined);
  const [editStaff, setEditStaff] = useState<string>('');
  const [editUnitPrice, setEditUnitPrice] = useState<string>('');
  const [editBatchNumber, setEditBatchNumber] = useState<string>('');
  const [editSelectedBagName, setEditSelectedBagName] = useState<string>('');
  const [editSelectedLabelName, setEditSelectedLabelName] = useState<string>('');

  const [isDeleteConfirmDialogOpen, setIsDeleteConfirmDialogOpen] = useState(false);
  const [logToDeleteId, setLogToDeleteId] = useState<string | null>(null);

  const [dateRangeFilter, setDateRangeFilter] = useState<DateRange | undefined>(undefined);
  const [filterProductName, setFilterProductName] = useState<string>('');

  const [showDeficitAlert, setShowDeficitAlert] = useState(false);
  const [deficitMaterials, setDeficitMaterials] = useState<{ name: string; needed: number; unit: string; available?: number; inventoryUnit?: string, isIntermediate?: boolean }[]>([]);
  const [currentProductionDeficitData, setCurrentProductionDeficitData] = useState<{productName: string, batchMultiplier: number} | null>(null);
  const [deficitType, setDeficitType] = useState<'raw_material_shortage' | 'intermediate_stock_shortage' | 'intermediate_missing_components_available' | 'intermediate_missing_components_missing' | null>(null);
  
  const [bestTransferSourceInfo, setBestTransferSourceInfo] = useState<{ branch: Branch; transferableItems: { name: string; needed: number; available: number; unit: string }[] } | null>(null);

  const [dataVersion, setDataVersion] = useState(0);
  const [costPerSackThisWeek, setCostPerSackThisWeek] = useState<number | null>(null);
  const [isNewDatePickerOpen, setIsNewDatePickerOpen] = useState(false);
  const [isEditDatePickerOpen, setIsEditDatePickerOpen] = useState(false);


  const loadPageData = useCallback(() => {
    setIsLoading(true);
    const activeBranch = getActiveBranchId();
    if (!activeBranch) {
      toast({ title: "Error", description: "No se ha seleccionado una sede activa.", variant: "destructive"});
      setIsLoading(false);
      return;
    }

    const sortedLogData = [...loadFromLocalStorageForBranch<ProductionLogEntry[]>(KEYS.PRODUCTION_LOG, activeBranch)].sort((a, b) => {
        const dateA = a.timestamp ? parseISO(a.timestamp).getTime() : (a.date ? parseISO(a.date).getTime() : 0);
        const dateB = b.timestamp ? parseISO(b.timestamp).getTime() : (b.date ? parseISO(b.date).getTime() : 0);
        return dateB - dateA;
    });
    setAllProductionLog(sortedLogData);

    const recipesForBranch = loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, activeBranch);
    const currentRecipeOptions = recipesForBranch
      .filter(r => !r.name.toLowerCase().startsWith('no despachable'))
      .map(r => ({ id: r.id, name: r.name }))
      .sort((a, b) => a.name.localeCompare(b.name));
    setProductOptionsFromRecipes(currentRecipeOptions);

    const rawMaterials = loadRawMaterialInventoryData(activeBranch);
    const bags = rawMaterials.filter(item => item.name.toLowerCase().includes('bolsa') && normalizeUnit(item.unit) === 'unidad').map(item => item.name).sort();
    const labels = rawMaterials.filter(item => item.name.toLowerCase().includes('etiqueta') && normalizeUnit(item.unit) === 'unidad').map(item => item.name).sort();
    setAvailableBags(bags);
    setAvailableLabels(labels);

    setExchangeRate(loadExchangeRate());
    
    const fixedCategories = loadExpenseFixedCategories(activeBranch);
    const employees = loadFromLocalStorageForBranch<Employee[]>(KEYS.EMPLOYEES, activeBranch);

    const currentFixedWeekly = fixedCategories
      .filter(cat => cat.name.toLowerCase() !== 'nómina' && cat.monthlyAmount && cat.monthlyAmount > 0)
      .reduce((sum, cat) => sum + (cat.monthlyAmount! / WEEKS_IN_MONTH), 0);
    const currentPayrollWeekly = employees.reduce((sum, emp) => sum + (emp.salary || 0), 0);
    const totalWeeklyOpCost = currentFixedWeekly + currentPayrollWeekly;
    
    const todayForCost = new Date();
    const startOfCurrentWeekForCost = startOfWeek(todayForCost, { weekStartsOn: 1 });
    const endOfCurrentWeekForCost = endOfWeek(todayForCost, { weekStartsOn: 1 });

    const productionThisWeekForCost = sortedLogData.filter(log => {
        if (!log.date || !isValid(parseISO(log.date))) return false;
        const logDate = parseISO(log.date);
        return isWithinInterval(logDate, { start: startOfCurrentWeekForCost, end: endOfCurrentWeekForCost });
    });

    const totalSacksFinalProductsForCost = productionThisWeekForCost.reduce((sum, log) => {
        const recipeDetails = recipesForBranch.find(r => r.name === log.product);
        if (recipeDetails && !recipeDetails.isIntermediate) {
            return sum + (log.batchSizeMultiplier || 0);
        }
        return sum;
    }, 0);

    if (totalWeeklyOpCost >= 0) { 
        if (totalSacksFinalProductsForCost > 0) {
            setCostPerSackThisWeek(totalWeeklyOpCost / totalSacksFinalProductsForCost);
        } else {
            setCostPerSackThisWeek(0); 
        }
    } else {
        setCostPerSackThisWeek(null); 
    }
    
    setIsLoading(false);
  }, [toast]); 

  useEffect(() => {
    loadPageData();
  }, [loadPageData, dataVersion]);

  useEffect(() => {
    const activeBranch = getActiveBranchId();
    if (!activeBranch) return;

    if (productOptionsFromRecipes.length > 0) {
      const isCurrentNewProductValid = productOptionsFromRecipes.some(p => p.name === newProductName);
      if (!newProductName || !isCurrentNewProductValid) { 
        setNewProductName(productOptionsFromRecipes[0].name);
      }
    } else { 
      if (newProductName !== '') { 
        setNewProductName('');
      }
    }
  }, [productOptionsFromRecipes, newProductName]);


  useEffect(() => {
    const activeBranch = getActiveBranchId();
    if (!activeBranch) return;
    const recipesForBranch = loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, activeBranch);

    if (newProductName) {
      const selectedRecipe = recipesForBranch.find(r => r.name === newProductName);
      if (selectedRecipe) {
        const baseYield = selectedRecipe.expectedYield || 0;
        setNewExpectedQuantity((baseYield * newBatchSizeMultiplier).toString());
        setNewUnitPrice(selectedRecipe.isIntermediate ? '0' : (selectedRecipe.costPerUnit ? selectedRecipe.costPerUnit.toString() : ''));
      } else {
        setNewExpectedQuantity('');
        setNewUnitPrice('');
      }
    } else {
        setNewExpectedQuantity('');
        setNewUnitPrice('');
    }
  }, [newProductName, newBatchSizeMultiplier]);


  useEffect(() => {
    const activeBranch = getActiveBranchId();
    if (!activeBranch) return;
    const recipesForBranch = loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, activeBranch);

    if (isEditLogDialogOpen && editProduct) {
      const selectedRecipe = recipesForBranch.find(r => r.name === editProduct);
      if (selectedRecipe) {
        const baseYield = selectedRecipe.expectedYield || 0;
        setEditExpectedQuantity((baseYield * editBatchSizeMultiplier).toString());
        setEditUnitPrice(selectedRecipe.isIntermediate ? '0' : (selectedRecipe.costPerUnit ? selectedRecipe.costPerUnit.toString() : ''));
      } else {
        setEditExpectedQuantity('');
        setEditUnitPrice('');
      }
    }
  }, [editProduct, editBatchSizeMultiplier, isEditLogDialogOpen]);


  const applyFilters = useCallback(() => {
    let logsToDisplay = [...allProductionLog];
    if (dateRangeFilter?.from) {
      const toDate = dateRangeFilter.to ? endOfDay(dateRangeFilter.to) : endOfDay(dateRangeFilter.from);
      logsToDisplay = logsToDisplay.filter(log =>
        log.date && isValid(parseISO(log.date)) && isWithinInterval(parseISO(log.date), { start: startOfDay(dateRangeFilter.from!), end: toDate })
      );
    }
    if (filterProductName) {
        logsToDisplay = logsToDisplay.filter(log =>
            log.product.toLowerCase().includes(filterProductName.toLowerCase())
        );
    }
    setFilteredProductionLog(logsToDisplay);
  }, [allProductionLog, dateRangeFilter, filterProductName]);

  useEffect(() => {
    applyFilters();
  }, [allProductionLog, dateRangeFilter, filterProductName, applyFilters]);

  useEffect(() => {
    const handleDataUpdate = (event: Event) => {
        const customEvent = event as CustomEvent;
        if (customEvent.detail?.key === KEYS.PRODUCTION_LOG || 
            customEvent.detail?.key === KEYS.RECIPES || 
            customEvent.detail?.key === KEYS.RAW_MATERIAL_INVENTORY || 
            customEvent.detail?.key === KEYS.PRODUCTS ||
            customEvent.detail?.key === KEYS.EMPLOYEES ||
            customEvent.detail?.key === KEYS.EXPENSE_FIXED_CATEGORIES ||
            customEvent.detail?.key === KEYS.ACTIVE_BRANCH_ID
           ) {
          setDataVersion(prev => prev + 1);
        }
      };

      window.addEventListener('data-updated', handleDataUpdate);
      return () => {
        window.removeEventListener('data-updated', handleDataUpdate);
      };
  }, []);

  const resetAddForm = useCallback(() => {
    const firstProduct = productOptionsFromRecipes.length > 0 ? productOptionsFromRecipes[0].name : '';
    setNewProductName(firstProduct);
    
    const activeBranch = getActiveBranchId();
    if (activeBranch) {
        const recipesForBranch = loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, activeBranch);
        const firstRecipe = recipesForBranch.find(r => r.name === firstProduct);
        const initialMultiplier = 1.0;
        setNewBatchSizeMultiplier(initialMultiplier);
        setNewExpectedQuantity(firstRecipe && firstRecipe.expectedYield ? (firstRecipe.expectedYield * initialMultiplier).toString() : '');
        setNewUnitPrice(firstRecipe && !firstRecipe.isIntermediate ? (firstRecipe.costPerUnit ? firstRecipe.costPerUnit.toString() : '') : '0');
    }
    
    setNewActualQuantity('');
    setNewDate(new Date());
    setNewStaff('');
    setNewBatchNumber('');
    setSelectedBagName('Bolsas 22x60');
    setSelectedLabelName('Etiquetas');
  }, [productOptionsFromRecipes]);
  
  const updateProductionGoals = useCallback((
    productName: string,
    quantity: number,
    productionDateStr: string,
    operation: 'add' | 'subtract'
  ) => {
    const activeBranch = getActiveBranchId();
    if (!activeBranch) return;

    const productionDate = parseISO(productionDateStr);
    if (!isValid(productionDate)) return;

    // Update Weekly Goals
    const weeklyGoals = loadFromLocalStorageForBranch<ProductionGoal[]>(KEYS.WEEKLY_GOALS, activeBranch);
    let weeklyGoalsUpdated = false;
    const updatedWeeklyGoals = weeklyGoals.map(goal => {
      const goalStartDate = goal.startDate ? parseISO(goal.startDate) : null;
      if (goalStartDate && goal.product === productName && isWithinInterval(productionDate, { start: startOfWeek(goalStartDate, { weekStartsOn: 1 }), end: endOfWeek(goalStartDate, { weekStartsOn: 1 }) })) {
        const newAchieved = operation === 'add'
          ? goal.achieved + quantity
          : Math.max(0, goal.achieved - quantity);
        
        if (goal.achieved !== newAchieved) {
          weeklyGoalsUpdated = true;
          return {
            ...goal,
            achieved: newAchieved,
            status: calculateGoalStatus(goal.target, newAchieved)
          };
        }
      }
      return goal;
    });

    if (weeklyGoalsUpdated) {
      saveToLocalStorageForBranch<ProductionGoal[]>(KEYS.WEEKLY_GOALS, activeBranch, updatedWeeklyGoals);
    }

    // Update Monthly Goals
    const monthlyGoals = loadFromLocalStorageForBranch<ProductionGoal[]>(KEYS.MONTHLY_GOALS, activeBranch);
    let monthlyGoalsUpdated = false;
    const updatedMonthlyGoals = monthlyGoals.map(goal => {
      const goalStartDate = goal.startDate ? parseISO(goal.startDate) : null;
      if (goalStartDate && goal.product === productName && isSameMonth(productionDate, goalStartDate) && isSameYear(productionDate, goalStartDate)) {
        const newAchieved = operation === 'add'
          ? goal.achieved + quantity
          : Math.max(0, goal.achieved - quantity);
        
        if (goal.achieved !== newAchieved) {
            monthlyGoalsUpdated = true;
            return {
                ...goal,
                achieved: newAchieved,
                status: calculateGoalStatus(goal.target, newAchieved)
            };
        }
      }
      return goal;
    });

    if (monthlyGoalsUpdated) {
      saveToLocalStorageForBranch<ProductionGoal[]>(KEYS.MONTHLY_GOALS, activeBranch, updatedMonthlyGoals);
    }
  }, []);

  const updatePackagingMaterials = useCallback((
    quantity: number,
    operation: 'consume' | 'revert',
    packagingItems: { bagName?: string, labelName?: string }
  ): { success: boolean; deficits?: { name: string; available: number }[] } => {
    const activeBranch = getActiveBranchId();
    if (!activeBranch || quantity <= 0) return { success: true };

    const materialsToProcess: string[] = [];
    if (packagingItems.bagName) materialsToProcess.push(packagingItems.bagName);
    if (packagingItems.labelName) materialsToProcess.push(packagingItems.labelName);

    if (materialsToProcess.length === 0) return { success: true };

    let currentRawMaterialsInventory = loadRawMaterialInventoryData(activeBranch);
    let inventoryChanged = false;
    const currentDeficits: { name: string; available: number }[] = [];

    // Pre-check for consumption
    if (operation === 'consume') {
      for (const materialName of materialsToProcess) {
        const materialUnit = "unidad";
        const materialIndex = currentRawMaterialsInventory.findIndex(
          item => item.name.toLowerCase() === materialName.toLowerCase() && normalizeUnit(item.unit) === materialUnit
        );

        if (materialIndex === -1) {
          currentDeficits.push({ name: materialName, available: 0 });
        } else {
          const currentStock = currentRawMaterialsInventory[materialIndex].quantity;
          if (currentStock < quantity) {
            currentDeficits.push({ name: materialName, available: currentStock });
          }
        }
      }
      if (currentDeficits.length > 0) {
        return { success: false, deficits: currentDeficits };
      }
    }

    // If pre-check passes or it's a revert, perform the operation
    materialsToProcess.forEach(materialName => {
      const materialUnit = "unidad";
      const materialIndex = currentRawMaterialsInventory.findIndex(
        item => item.name.toLowerCase() === materialName.toLowerCase() && normalizeUnit(item.unit) === materialUnit
      );

      if (materialIndex !== -1) {
        if (operation === 'consume') {
          currentRawMaterialsInventory[materialIndex].quantity -= quantity;
        } else { // revert
          currentRawMaterialsInventory[materialIndex].quantity += quantity;
        }
        inventoryChanged = true;
      } else if (operation === 'revert') {
        currentRawMaterialsInventory.push({name: materialName, quantity: quantity, unit: materialUnit});
        inventoryChanged = true;
      }
    });

    if (inventoryChanged) {
      saveRawMaterialInventoryData(activeBranch, currentRawMaterialsInventory.filter(item => item.quantity > 0.0001));
    }
    return { success: true };
  }, []);

  const consumeOrRevertMaterials = useCallback((
    productName: string,
    batchMultiplier: number,
    operation: 'consume' | 'revert'
  ): {
    success: boolean;
    materialsDeficit?: { name: string; needed: number; unit: string; available?: number; inventoryUnit?: string, isIntermediate?: boolean }[];
    deficitType?: 'raw_material_shortage' | 'intermediate_stock_shortage' | 'intermediate_missing_components_available' | 'intermediate_missing_components_missing' | null;
    bestTransferSourceInfo?: { branch: Branch; transferableItems: { name: string; needed: number; available: number; unit: string }[] } | null
  } => {
    const activeBranchId = getActiveBranchId();
    if (!activeBranchId) return { success: false };

    const recipesForBranch = loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, activeBranchId);
    let inventory = loadRawMaterialInventoryData(activeBranchId);

    const directIngredients = getDirectIngredientsForRecipe(productName, batchMultiplier, recipesForBranch);

    if (directIngredients.length === 0) {
        const recipe = recipesForBranch.find(r => r.name === productName);
        if (recipe && recipe.ingredients.length > 0) {
          return { success: false };
        }
        return { success: true };
    }

    const deficits: { name: string; needed: number; unit: string; available?: number; inventoryUnit?: string, isIntermediate?: boolean }[] = [];
    let currentDeficitType: 'raw_material_shortage' | 'intermediate_stock_shortage' | 'intermediate_missing_components_available' | 'intermediate_missing_components_missing' | null = null;
    let bestBranchForTransfer: { branch: Branch; transferableItems: { name: string; needed: number; available: number; unit: string }[] } | null = null;

    if (operation === 'consume') {
      for (const ingredient of directIngredients) {
        const inventoryItemIndex = inventory.findIndex(item =>
          item.name.toLowerCase() === ingredient.name.toLowerCase() &&
          normalizeUnit(item.unit) === normalizeUnit(ingredient.unit)
        );

        if (inventoryItemIndex === -1 || inventory[inventoryItemIndex].quantity < ingredient.quantity) {
          const availableQuantity = inventoryItemIndex !== -1 ? inventory[inventoryItemIndex].quantity : 0;
          deficits.push({
            name: ingredient.name, needed: ingredient.quantity, unit: ingredient.unit,
            available: availableQuantity,
            inventoryUnit: inventoryItemIndex !== -1 ? inventory[inventoryItemIndex].unit : undefined,
            isIntermediate: ingredient.isIntermediate
          });
        }
      }
    }

    if (deficits.length > 0 && operation === 'consume') {
        const firstDeficit = deficits[0];
        if (firstDeficit.isIntermediate) {
            const hasRawMaterialDeficit = deficits.some(d => !d.isIntermediate);
            if (hasRawMaterialDeficit) currentDeficitType = 'intermediate_missing_components_missing';
            else currentDeficitType = 'intermediate_missing_components_available';
        } else {
            currentDeficitType = 'raw_material_shortage';
        }
        
        const otherBranches = availableBranches.filter(b => b.id !== activeBranchId);
        let bestScore = 0;
        for (const branch of otherBranches) {
            const sourceInventory = loadRawMaterialInventoryData(branch.id);
            let score = 0;
            const transferableItems: { name: string; needed: number; available: number; unit: string }[] = [];
            
            for (const deficit of deficits) {
                const sourceItem = sourceInventory.find(i => i.name.toLowerCase() === deficit.name.toLowerCase() && normalizeUnit(i.unit) === normalizeUnit(deficit.unit));
                if (sourceItem && sourceItem.quantity > 0.0001) {
                    const availableForTransfer = sourceItem.quantity;
                    const canCover = availableForTransfer >= deficit.needed;
                    if(canCover) score += 2; else score +=1;
                    transferableItems.push({ name: deficit.name, needed: deficit.needed, available: availableForTransfer, unit: deficit.unit });
                }
            }
            if (score > bestScore) {
                bestScore = score;
                bestBranchForTransfer = { branch, transferableItems };
            }
        }
        
        return { success: false, materialsDeficit: deficits, deficitType: currentDeficitType, bestTransferSourceInfo: bestBranchForTransfer };
    }

    for (const ingredient of directIngredients) {
      const itemIndex = inventory.findIndex(item =>
        item.name.toLowerCase() === ingredient.name.toLowerCase() &&
        normalizeUnit(item.unit) === normalizeUnit(ingredient.unit)
      );

      if (itemIndex !== -1) {
        if (operation === 'consume') inventory[itemIndex].quantity -= ingredient.quantity;
        else inventory[itemIndex].quantity += ingredient.quantity;
      } else if (operation === 'revert') {
        inventory.push({ name: ingredient.name, quantity: ingredient.quantity, unit: ingredient.unit });
      }
    }

    saveRawMaterialInventoryData(activeBranchId, inventory.filter(item => item.quantity > 0.0001));
    return { success: true };
  }, []);

  const handleCreatePOFromDeficit = () => {
    const activeBranchId = getActiveBranchId();
    if (!activeBranchId) {
      toast({ title: "Error", description: "No hay sede activa para crear OC.", variant: "destructive" });
      return;
    }
    if (!currentProductionDeficitData || deficitMaterials.length === 0) return;
    setIsSubmitting(true);

    const supplierScores: { [supplierId: string]: { count: number; supplierName: string } } = {};
    const bestPricePerItem: { [materialName: string]: any | null } = {};

    deficitMaterials.filter(m => !m.isIntermediate).forEach(material => {
      const bestPrice = getBestPriceInfo(material.name);
      bestPricePerItem[material.name] = bestPrice;
      if (bestPrice) {
        if (!supplierScores[bestPrice.supplierId]) {
          supplierScores[bestPrice.supplierId] = { count: 0, supplierName: bestPrice.supplierName };
        }
        supplierScores[bestPrice.supplierId].count++;
      }
    });

    let primarySupplierId: string | null = null;
    let primarySupplierName = "Proveedor por Asignar (Automático)";
    let maxScore = 0;

    for (const supplierId in supplierScores) {
      if (supplierScores[supplierId].count > maxScore) {
        maxScore = supplierScores[supplierId].count;
        primarySupplierId = supplierId;
        primarySupplierName = supplierScores[supplierId].supplierName;
      }
    }
     if (!primarySupplierId && Object.values(bestPricePerItem).filter(bp => bp !== null).length > 0) {
        const firstAvailableBestPrice = Object.values(bestPricePerItem).find(bp => bp !== null);
        if (firstAvailableBestPrice) {
            primarySupplierId = firstAvailableBestPrice.supplierId;
            primarySupplierName = firstAvailableBestPrice.supplierName;
        }
    }

    const poItems: PurchaseOrderItem[] = deficitMaterials
        .filter(material => !material.isIntermediate)
        .map((material, index) => {
          const netDeficitInBaseUnit = Math.max(0, material.needed - (material.available || 0));
          if (netDeficitInBaseUnit <= 0.0001) return null;

          let purchaseUnitToUse: string = material.unit;
          let unitPriceForOCItem: number = 0;
          let quantityToOrderInPurchaseUnit: number = Math.ceil(netDeficitInBaseUnit); 
          
          const bestPriceInfo = bestPricePerItem[material.name];

          if (bestPriceInfo) {
            const conversionFromPurchaseUnitToBase = convertMaterialToBaseUnit(1, bestPriceInfo.originalUnit, material.name);
            
            if (normalizeUnit(conversionFromPurchaseUnitToBase.unit) === normalizeUnit(material.unit) && conversionFromPurchaseUnitToBase.quantity > 0) {
              purchaseUnitToUse = bestPriceInfo.originalUnit;
              unitPriceForOCItem = bestPriceInfo.originalUnitPrice;
              quantityToOrderInPurchaseUnit = Math.ceil(netDeficitInBaseUnit / conversionFromPurchaseUnitToBase.quantity);
            } else if (normalizeUnit(bestPriceInfo.baseUnit) === normalizeUnit(material.unit)) {
              purchaseUnitToUse = material.unit; 
              unitPriceForOCItem = bestPriceInfo.pricePerBaseUnit;
              quantityToOrderInPurchaseUnit = Math.ceil(netDeficitInBaseUnit);
            } else {
              console.warn(`Cannot match units for ${material.name} from supplier ${bestPriceInfo.supplierName}. Deficit unit: ${material.unit}, Supplier best price unit: ${bestPriceInfo.originalUnit} (base: ${bestPriceInfo.baseUnit}). Using default price 0 and deficit unit.`);
            }
          }
          
          if (netDeficitInBaseUnit > 0 && quantityToOrderInPurchaseUnit <= 0) {
            quantityToOrderInPurchaseUnit = 1; 
            if (bestPriceInfo && purchaseUnitToUse !== bestPriceInfo.originalUnit) {
                 if (unitPriceForOCItem === bestPriceInfo.originalUnitPrice) {
                    purchaseUnitToUse = bestPriceInfo.originalUnit;
                 }
            }
          }
          if (unitPriceForOCItem < 0) unitPriceForOCItem = 0;


          return {
            id: `POC-ITEM-${Date.now()}-${index}`,
            rawMaterialName: material.name,
            quantity: quantityToOrderInPurchaseUnit,
            unit: purchaseUnitToUse,
            unitPrice: parseFloat(unitPriceForOCItem.toFixed(2)),
            subtotal: parseFloat((quantityToOrderInPurchaseUnit * unitPriceForOCItem).toFixed(2)),
          };
        })
        .filter(item => item !== null && item.quantity > 0) as PurchaseOrderItem[];


    if (poItems.length === 0) {
        toast({ title: "Info", description: "No se requieren ítems en la orden de compra después de considerar el stock disponible o compatibilidad de unidades.", variant: "default" });
        setShowDeficitAlert(false);
        setDeficitMaterials([]);
        setCurrentProductionDeficitData(null);
        setDeficitType(null);
        setIsSubmitting(false);
        return;
    }


    const totalPOCost = poItems.reduce((sum, item) => sum + item.subtotal, 0);

    const newPurchaseOrder: PurchaseOrder = {
      id: `POC-DEF-${Date.now().toString().slice(-5)}`,
      supplierId: primarySupplierId || "AUTO_POC_SUPPLIER",
      supplierName: primarySupplierName,
      orderDate: format(new Date(), "yyyy-MM-dd"),
      expectedDelivery: format(addDays(new Date(), 3), "yyyy-MM-dd"),
      items: poItems,
      totalCost: totalPOCost,
      status: 'Pendiente',
      timestamp: new Date().toISOString(),
    };

    const currentPurchaseOrders = loadPurchaseOrdersFromStorage(activeBranchId);
    const updatedPOs = [newPurchaseOrder, ...currentPurchaseOrders].sort((a, b) => {
      const timeA = a.orderDate && isValid(parseISO(a.orderDate)) ? parseISO(a.orderDate).getTime() : 0;
      const timeB = b.orderDate && isValid(parseISO(b.orderDate)) ? parseISO(b.orderDate).getTime() : 0;
      if (timeB === 0 && timeA === 0) return 0;
      if (timeB === 0) return -1;
      if (timeA === 0) return 1;
      return timeB - timeA;
    });
    savePurchaseOrdersData(activeBranchId, updatedPOs);
    toast({ title: "Orden de Compra Creada", description: `OC Pendiente ${newPurchaseOrder.id} creada para materiales faltantes con ${primarySupplierName}. Por favor, revisa precios y unidades en la OC.` });

    setShowDeficitAlert(false);
    setDeficitMaterials([]);
    setCurrentProductionDeficitData(null);
    setDeficitType(null);
    setIsSubmitting(false);
  };

  const handleCreateTransferFromDeficit = (
    sourceBranchId: string, 
    transferableItems: { name: string; needed: number; available: number; unit: string }[]
  ) => {
    const destBranchId = getActiveBranchId();
    if (!destBranchId || !sourceBranchId) {
      toast({ title: "Error", description: "Sede de origen o destino no válida.", variant: "destructive"});
      return;
    }
    setIsSubmitting(true);

    const sourceBranch = availableBranches.find(b => b.id === sourceBranchId);
    const destBranch = availableBranches.find(b => b.id === destBranchId);
    if (!sourceBranch || !destBranch) {
        toast({ title: "Error", description: "Sede de origen o destino no encontrada.", variant: "destructive"});
        setIsSubmitting(false);
        return;
    }
    
    let sourceInventory = loadRawMaterialInventoryData(sourceBranchId);
    let destInventory = loadRawMaterialInventoryData(destBranchId);
    let currentTransfers = inventoryTransfersData;

    const transfersToCreate: InventoryTransfer[] = [];

    for (const item of transferableItems) {
        const neededQuantityInBase = item.needed;
        
        let totalAvailableInBase = 0;
        const sourceItemsForMaterial = sourceInventory.filter(i => i.name.toLowerCase() === item.name.toLowerCase());
        
        for (const sourceItem of sourceItemsForMaterial) {
            const conversion = convertMaterialToBaseUnit(sourceItem.quantity, sourceItem.unit, sourceItem.name);
            if(normalizeUnit(conversion.unit) === normalizeUnit(item.unit)) {
                totalAvailableInBase += conversion.quantity;
            }
        }
        
        const transferQuantity = Math.min(neededQuantityInBase, totalAvailableInBase);
        if (transferQuantity <= 0.0001) continue;

        let remainingToDeduct = transferQuantity;
        for (const sourceItem of sourceItemsForMaterial) {
            if (remainingToDeduct <= 0.0001) break;
            const conversion = convertMaterialToBaseUnit(sourceItem.quantity, sourceItem.unit, sourceItem.name);
             if(normalizeUnit(conversion.unit) === normalizeUnit(item.unit)) {
                const deductionInBase = Math.min(remainingToDeduct, conversion.quantity);
                const { quantity: deductionInOriginalUnit } = convertMaterialToBaseUnit(deductionInBase, item.unit, item.name); // Esto podría necesitar una función inversa
                // A simpler approach for now, assuming base units are consistent or direct.
                // For simplicity, let's assume we can deduct from the base-unit-equivalent entry.
                const sourceItemIndex = sourceInventory.findIndex(i => i.name === sourceItem.name && i.unit === sourceItem.unit);
                sourceInventory[sourceItemIndex].quantity -= deductionInBase; // THIS IS RISKY if units mismatch.
                remainingToDeduct -= deductionInBase;
             }
        }


        const destItemIndex = destInventory.findIndex(i => i.name.toLowerCase() === item.name.toLowerCase() && normalizeUnit(i.unit) === normalizeUnit(item.unit));
        if (destItemIndex !== -1) {
            destInventory[destItemIndex].quantity += transferQuantity;
        } else {
            destInventory.push({ name: item.name, quantity: transferQuantity, unit: item.unit });
        }
        
        const newTransfer: InventoryTransfer = {
            id: `TRNFR-DEF-${Date.now().toString().slice(-5)}-${transfersToCreate.length}`,
            date: format(new Date(), "yyyy-MM-dd"),
            fromBranchId: sourceBranchId,
            fromBranchName: sourceBranch.name,
            toBranchId: destBranchId,
            toBranchName: destBranch.name,
            materialName: item.name,
            quantity: transferQuantity,
            unit: item.unit,
            notes: `Transferencia automática por déficit para producción de: ${currentProductionDeficitData?.productName || 'N/A'}.`,
            timestamp: new Date().toISOString(),
        };
        transfersToCreate.push(newTransfer);
    }
    
    if (transfersToCreate.length > 0) {
        saveRawMaterialInventoryData(sourceBranchId, sourceInventory.filter(item => item.quantity > 0.0001));
        saveRawMaterialInventoryData(destBranchId, destInventory.filter(item => item.quantity > 0.0001));
        saveInventoryTransfersData([...currentTransfers, ...transfersToCreate]);
        toast({ title: "Transferencia Parcial Creada", description: `Se transfirieron ${transfersToCreate.length} ítem(s) desde ${sourceBranch.name}. Intenta registrar la producción de nuevo o crea una OC para lo restante.` });
    } else {
        toast({ title: "Sin ítems transferibles", description: "No se encontraron ítems con stock suficiente para transferir.", variant: "default" });
    }
    
    setShowDeficitAlert(false);
    setDeficitMaterials([]);
    setCurrentProductionDeficitData(null);
    setDeficitType(null);
    setBestTransferSourceInfo(null);
    setIsSubmitting(false);
};


  const handleAddLogEntry = () => {
    setIsSubmitting(true);
    const activeBranch = getActiveBranchId();
    if (!activeBranch) {
      toast({ title: "Error de Sede", description: "No hay sede activa.", variant: "destructive"});
      setIsSubmitting(false); return;
    }
    const recipesForBranch = loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, activeBranch);

    const recipeDetails = recipesForBranch.find(r => r.name.toLowerCase() === newProductName.toLowerCase());
    const isIntermediateProduct = recipeDetails?.isIntermediate || false;

    if (!newProductName || !newActualQuantity || !newDate || !newStaff || !newExpectedQuantity) {
      toast({ title: "Error", description: "Producto, cantidad esperada, cantidad real, fecha y personal son obligatorios.", variant: "destructive" });
      setIsSubmitting(false);
      return;
    }

    let unitPriceNum = parseFloat(newUnitPrice);
    if (!isIntermediateProduct && (isNaN(unitPriceNum) || unitPriceNum < 0)) {
        toast({ title: "Error", description: "El precio unitario debe ser un número válido no negativo para productos finales.", variant: "destructive" });
        setIsSubmitting(false);
        return;
    } else if (isIntermediateProduct) {
        unitPriceNum = parseFloat(newUnitPrice) || 0;
    }

    const expectedNum = parseInt(newExpectedQuantity, 10);
    const actualNum = parseInt(newActualQuantity, 10);

    if (isNaN(expectedNum) || expectedNum <= 0 || isNaN(actualNum) || actualNum < 0) {
        toast({ title: "Error", description: "Cantidades deben ser números válidos (esperada positiva, real no negativa).", variant: "destructive" });
        setIsSubmitting(false);
        return;
    }

    const productDateStr = format(newDate!, "yyyy-MM-dd");
    const currentTimestamp = new Date().toISOString();

    const materialConsumptionResult = consumeOrRevertMaterials(newProductName, newBatchSizeMultiplier, 'consume');

    if (!materialConsumptionResult.success) {
        if (materialConsumptionResult.materialsDeficit) {
            setDeficitMaterials(materialConsumptionResult.materialsDeficit);
            setCurrentProductionDeficitData({ productName: newProductName, batchMultiplier: newBatchSizeMultiplier });
            setDeficitType(materialConsumptionResult.deficitType || 'raw_material_shortage');
            setBestTransferSourceInfo(materialConsumptionResult.bestTransferSourceInfo || null);
            setShowDeficitAlert(true);
        } else {
             toast({ title: "Error de Materiales", description: "No se pudo consumir la materia prima necesaria.", variant: "destructive" });
        }
        setIsSubmitting(false);
        return;
    }
    
    if (!isIntermediateProduct && actualNum > 0) {
      const packagingResult = updatePackagingMaterials(actualNum, 'consume', { bagName: selectedBagName, labelName: selectedLabelName });
      if (!packagingResult.success) {
        toast({
          title: "Error: Faltan Materiales de Empaque",
          description: `No hay suficiente stock para: ${packagingResult.deficits?.map(d => `${d.name} (Disp: ${d.available})`).join(', ')}. Necesitas ${actualNum}.`,
          variant: "destructive",
          duration: 8000
        });
        // Revert material consumption if packaging fails
        consumeOrRevertMaterials(newProductName, newBatchSizeMultiplier, 'revert');
        setIsSubmitting(false);
        return;
      }
    }


    if (isIntermediateProduct && recipeDetails) {
      let currentRawInventory = loadRawMaterialInventoryData(activeBranch);
      const existingIntermediateIndex = currentRawInventory.findIndex(
        item => item.name.toLowerCase() === recipeDetails.name.toLowerCase()
      );
      
      let intermediateUnitToUse = normalizeUnit(recipeDetails.outputUnit);
      if (!VALID_BASE_UNITS.includes(intermediateUnitToUse)) {
        const defaultIntermediateUnit = recipeDetails.name.toLowerCase().includes("melado") || recipeDetails.name.toLowerCase().includes("jarabe") ? "l" : "kg";
        console.warn(`Unidad de salida '${recipeDetails.outputUnit}' para preparación intermedia '${recipeDetails.name}' no es una unidad base válida. Usando '${defaultIntermediateUnit}' por defecto. La cantidad ${actualNum} se guardará en esta unidad base.`);
        intermediateUnitToUse = defaultIntermediateUnit;
      }

      if (existingIntermediateIndex !== -1) {
        if (normalizeUnit(currentRawInventory[existingIntermediateIndex].unit) === intermediateUnitToUse) {
            currentRawInventory[existingIntermediateIndex].quantity += actualNum;
        } else {
             console.warn(`Preparación intermedia '${recipeDetails.name}' existe con unidad ${currentRawInventory[existingIntermediateIndex].unit}, añadiendo nueva entrada con ${intermediateUnitToUse}.`);
             currentRawInventory.push({ name: recipeDetails.name, quantity: actualNum, unit: intermediateUnitToUse });
        }
      } else {
        currentRawInventory.push({ name: recipeDetails.name, quantity: actualNum, unit: intermediateUnitToUse });
      }
      saveRawMaterialInventoryData(activeBranch, currentRawInventory.filter(item => item.quantity > 0.0001));
      toast({ title: "Éxito", description: `Preparación intermedia '${recipeDetails.name}' registrada y añadida al inventario como ${actualNum} ${intermediateUnitToUse}.` });
    } else {
      let currentProducts = loadProductsForBranch(activeBranch);
      const productIndex = currentProducts.findIndex(p => p.name.toLowerCase() === newProductName.toLowerCase());
      if (productIndex !== -1) {
        currentProducts[productIndex].stock += actualNum;
        currentProducts[productIndex].lastUpdated = productDateStr;
        currentProducts[productIndex].unitPrice = unitPriceNum;
      } else {
        currentProducts.unshift({
            id: `PROD_NEW_${Date.now()}`,
            name: newProductName,
            category: recipeDetails?.category || "General",
            stock: actualNum,
            unitPrice: unitPriceNum,
            lastUpdated: productDateStr,
            image: "https://placehold.co/40x40.png",
            aiHint: recipeDetails?.aiHint || "producto panaderia",
            sourceBranchId: activeBranch, 
            sourceBranchName: availableBranches.find(b => b.id === activeBranch)?.name || 'Desconocida'
        });
      }
      saveProductsDataForBranch(activeBranch, currentProducts);
      if (!isIntermediateProduct) {
        updateProductionGoals(newProductName, actualNum, productDateStr, 'add');
      }
      toast({ title: "Éxito", description: `Producción de '${newProductName}' registrada.` });
    }

    const newLogEntry: ProductionLogEntry = {
      id: `PL${Date.now().toString().slice(-3)}${Math.floor(Math.random()*100)}`,
      product: newProductName,
      batchSizeMultiplier: newBatchSizeMultiplier,
      expectedQuantity: expectedNum,
      actualQuantity: actualNum,
      date: productDateStr,
      staff: newStaff.trim(),
      unitPrice: unitPriceNum,
      batchNumber: newBatchNumber.trim() || undefined,
      timestamp: currentTimestamp,
      bagUsed: selectedBagName || undefined,
      labelUsed: selectedLabelName || undefined,
    };

    const currentLogsForBranch = loadFromLocalStorageForBranch<ProductionLogEntry[]>(KEYS.PRODUCTION_LOG, activeBranch);
    const updatedLogs = [newLogEntry, ...currentLogsForBranch].sort((a, b) => {
        const dateA = a.timestamp ? parseISO(a.timestamp).getTime() : (a.date ? parseISO(a.date).getTime() : 0);
        const dateB = b.timestamp ? parseISO(b.timestamp).getTime() : (b.date ? parseISO(b.date).getTime() : 0);
        return dateB - dateA;
    });
    saveProductionLogData(updatedLogs); 
    setAllProductionLog(updatedLogs);

    resetAddForm();
    setIsSubmitting(false);
  };

  const handleOpenEditDialog = (logEntry: ProductionLogEntry) => {
    setEditingLogEntry(logEntry);
    setOriginalLogEntryForEdit(JSON.parse(JSON.stringify(logEntry)));
    setEditProduct(logEntry.product);
    setEditBatchSizeMultiplier(logEntry.batchSizeMultiplier);

    const activeBranch = getActiveBranchId();
    if (!activeBranch) return;
    const recipesForBranch = loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, activeBranch);
    const recipeForEdit = recipesForBranch.find(r => r.name === logEntry.product);
    const baseYieldForEdit = recipeForEdit?.expectedYield || 0;
    setEditExpectedQuantity((baseYieldForEdit * logEntry.batchSizeMultiplier).toString());
    setEditActualQuantity(logEntry.actualQuantity.toString());
    setEditDate(logEntry.date && isValid(parseISO(logEntry.date)) ? parseISO(logEntry.date) : new Date());
    setEditStaff(logEntry.staff);
    setEditUnitPrice(logEntry.unitPrice.toString());
    setEditBatchNumber(logEntry.batchNumber || '');
    setEditSelectedBagName(logEntry.bagUsed || '');
    setEditSelectedLabelName(logEntry.labelUsed || '');

    setIsEditLogDialogOpen(true);
  };

  const handleUpdateLogEntry = () => {
    setIsSubmitting(true);
    const activeBranch = getActiveBranchId();
    if (!activeBranch || !editingLogEntry || !originalLogEntryForEdit) {
      toast({ title: "Error", description: "Faltan datos para editar o no hay sede activa.", variant: "destructive" });
      setIsSubmitting(false); return;
    }
    const recipesForBranch = loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, activeBranch);

    const recipeDetailsOriginal = recipesForBranch.find(r => r.name.toLowerCase() === originalLogEntryForEdit.product.toLowerCase());
    const isIntermediateOriginal = recipeDetailsOriginal?.isIntermediate || false;
    const recipeDetailsNew = recipesForBranch.find(r => r.name.toLowerCase() === editProduct.toLowerCase());
    const isIntermediateNew = recipeDetailsNew?.isIntermediate || false;

    if (!editProduct || !editDate || !editStaff || !editExpectedQuantity || !editActualQuantity) {
      toast({ title: "Error", description: "Faltan campos obligatorios para editar.", variant: "destructive" });
      setIsSubmitting(false);
      return;
    }

    const updatedExpectedNum = parseInt(editExpectedQuantity, 10);
    const updatedActualNum = parseInt(editActualQuantity, 10);
    let updatedUnitPriceNum = parseFloat(editUnitPrice);

    if (isNaN(updatedExpectedNum) || updatedExpectedNum <= 0 || isNaN(updatedActualNum) || updatedActualNum < 0 ) {
        toast({ title: "Error", description: "Cantidades deben ser números válidos (esperada positiva, real no negativa).", variant: "destructive" });
        setIsSubmitting(false);
        return;
    }

    if (!isIntermediateNew && (isNaN(updatedUnitPriceNum) || updatedUnitPriceNum < 0)) {
        toast({ title: "Error", description: "El precio unitario debe ser un número válido no negativo para productos finales.", variant: "destructive" });
        setIsSubmitting(false);
        return;
    } else if (isIntermediateNew) {
        updatedUnitPriceNum = parseFloat(editUnitPrice) || 0;
    }

    const productDateStrNew = format(editDate!, "yyyy-MM-dd");
    const originalProductDateStr = originalLogEntryForEdit.date;
    const currentTimestamp = new Date().toISOString();

    const revertOriginalMaterialsResult = consumeOrRevertMaterials(originalLogEntryForEdit.product, originalLogEntryForEdit.batchSizeMultiplier, 'revert');
    if (!revertOriginalMaterialsResult.success) {
      toast({ title: "Error al Revertir Original", description: "No se pudo revertir el consumo de materiales original al editar. Contacta soporte.", variant: "destructive" });
      setIsSubmitting(false);
      return;
    }

    if (!isIntermediateOriginal && originalLogEntryForEdit.actualQuantity > 0) {
      updatePackagingMaterials(originalLogEntryForEdit.actualQuantity, 'revert', { bagName: originalLogEntryForEdit.bagUsed, labelName: originalLogEntryForEdit.labelUsed });
    }

    if (isIntermediateOriginal && recipeDetailsOriginal) {
        let currentRawInventory = loadRawMaterialInventoryData(activeBranch);
        const idx = currentRawInventory.findIndex(item => item.name.toLowerCase() === recipeDetailsOriginal.name.toLowerCase());
        if (idx !== -1) {
            currentRawInventory[idx].quantity -= originalLogEntryForEdit.actualQuantity;
            if (currentRawInventory[idx].quantity <= 0.0001) currentRawInventory.splice(idx, 1);
        }
        saveRawMaterialInventoryData(activeBranch, currentRawInventory.filter(item => item.quantity > 0.0001));
    } else {
        let tempProducts = loadProductsForBranch(activeBranch);
        const productIndex = tempProducts.findIndex(p => p.name.toLowerCase() === originalLogEntryForEdit.product.toLowerCase());
        if (productIndex !== -1) {
            tempProducts[productIndex].stock -= originalLogEntryForEdit.actualQuantity;
            if (tempProducts[productIndex].stock < 0) tempProducts[productIndex].stock = 0;
            saveProductsDataForBranch(activeBranch, tempProducts);
        }
    }
    if (!isIntermediateOriginal && recipeDetailsOriginal) {
        updateProductionGoals(originalLogEntryForEdit.product, originalLogEntryForEdit.actualQuantity, originalProductDateStr, 'subtract');
    }

    const consumeUpdatedMaterialsResult = consumeOrRevertMaterials(editProduct, editBatchSizeMultiplier, 'consume');
    if (!consumeUpdatedMaterialsResult.success) {
        consumeOrRevertMaterials(originalLogEntryForEdit.product, originalLogEntryForEdit.batchSizeMultiplier, 'consume'); 
        if (!isIntermediateOriginal && originalLogEntryForEdit.actualQuantity > 0) { 
          updatePackagingMaterials(originalLogEntryForEdit.actualQuantity, 'consume', { bagName: originalLogEntryForEdit.bagUsed, labelName: originalLogEntryForEdit.labelUsed });
        }

        if (consumeUpdatedMaterialsResult.materialsDeficit) {
            setDeficitMaterials(consumeUpdatedMaterialsResult.materialsDeficit);
            setCurrentProductionDeficitData({ productName: editProduct, batchMultiplier: editBatchSizeMultiplier });
            setDeficitType(consumeUpdatedMaterialsResult.deficitType || 'raw_material_shortage');
            setBestTransferSourceInfo(consumeUpdatedMaterialsResult.bestTransferSourceInfo || null);
            setShowDeficitAlert(true);
        } else {
            toast({ title: "Error al Editar: Consumo de Materiales", description: "No se pudo actualizar el consumo de materiales para la edición.", variant: "destructive" });
        }
        setIsSubmitting(false);
        return;
    }

    if (!isIntermediateNew && updatedActualNum > 0) {
      const packagingResult = updatePackagingMaterials(updatedActualNum, 'consume', { bagName: editSelectedBagName, labelName: editSelectedLabelName });
      if (!packagingResult.success) {
        toast({
          title: "Error al Editar: Faltan Materiales de Empaque",
          description: `No hay suficiente stock para: ${packagingResult.deficits?.map(d => `${d.name} (Disp: ${d.available})`).join(', ')}. Necesitas ${updatedActualNum}. Cambios revertidos.`,
          variant: "destructive",
          duration: 8000
        });
        // Revert material consumption and the revert of original state
        consumeOrRevertMaterials(editProduct, editBatchSizeMultiplier, 'revert'); // Revert the new consumption
        consumeOrRevertMaterials(originalLogEntryForEdit.product, originalLogEntryForEdit.batchSizeMultiplier, 'consume'); // Re-apply original material consumption
        if (!isIntermediateOriginal && originalLogEntryForEdit.actualQuantity > 0) {
          updatePackagingMaterials(originalLogEntryForEdit.actualQuantity, 'consume', { bagName: originalLogEntryForEdit.bagUsed, labelName: originalLogEntryForEdit.labelUsed }); // Re-apply original packaging consumption
        }
        setIsSubmitting(false);
        return;
      }
    }


    if (isIntermediateNew && recipeDetailsNew) {
        let currentRawInventory = loadRawMaterialInventoryData(activeBranch);
        const idx = currentRawInventory.findIndex(item => item.name.toLowerCase() === recipeDetailsNew.name.toLowerCase());
        let intermediateUnitNew = normalizeUnit(recipeDetailsNew.outputUnit || (recipeDetailsNew.name.toLowerCase().includes("melado") || recipeDetailsNew.name.toLowerCase().includes("jarabe") ? "l" : "kg"));
         if (!VALID_BASE_UNITS.includes(intermediateUnitNew)) {
            const defaultIntermediateUnitNew = recipeDetailsNew.name.toLowerCase().includes("melado") || recipeDetailsNew.name.toLowerCase().includes("jarabe") ? "l" : "kg";
            console.warn(`Unidad de salida '${recipeDetailsNew.outputUnit}' para preparación intermedia '${recipeDetailsNew.name}' no es una unidad base válida. Usando '${defaultIntermediateUnitNew}' por defecto. La cantidad ${updatedActualNum} se guardará en esta unidad base.`);
            intermediateUnitNew = defaultIntermediateUnitNew;
        }
        if (idx !== -1) {
            if(normalizeUnit(currentRawInventory[idx].unit) === intermediateUnitNew) {
                currentRawInventory[idx].quantity += updatedActualNum;
            } else {
                 console.warn(`Preparación intermedia '${recipeDetailsNew.name}' existe con unidad ${currentRawInventory[idx].unit}, añadiendo nueva entrada con ${intermediateUnitNew}.`);
                 currentRawInventory.push({ name: recipeDetailsNew.name, quantity: updatedActualNum, unit: intermediateUnitNew });
            }
        } else {
            currentRawInventory.push({ name: recipeDetailsNew.name, quantity: updatedActualNum, unit: intermediateUnitNew });
        }
        saveRawMaterialInventoryData(activeBranch, currentRawInventory.filter(item => item.quantity > 0.0001));
    } else {
        let tempProducts = loadProductsForBranch(activeBranch);
        const productIndex = tempProducts.findIndex(p => p.name.toLowerCase() === editProduct.toLowerCase());
        if (productIndex !== -1) {
            tempProducts[productIndex].stock += updatedActualNum;
            tempProducts[productIndex].lastUpdated = productDateStrNew;
            tempProducts[productIndex].unitPrice = updatedUnitPriceNum;
        } else {
             tempProducts.unshift({
                id: `PROD_NEW_EDIT_${Date.now()}`, name: editProduct, category: recipeDetailsNew?.category || "General",
                stock: updatedActualNum, unitPrice: updatedUnitPriceNum, lastUpdated: productDateStrNew,
                image: "https://placehold.co/40x40.png", aiHint: recipeDetailsNew?.aiHint || "producto panaderia",
                sourceBranchId: activeBranch,
                sourceBranchName: availableBranches.find(b => b.id === activeBranch)?.name || 'Desconocida'
            });
        }
        saveProductsDataForBranch(activeBranch, tempProducts);
    }
    if (!isIntermediateNew && recipeDetailsNew) {
        updateProductionGoals(editProduct, updatedActualNum, productDateStrNew, 'add');
    }

    const currentLogsForBranch = loadFromLocalStorageForBranch<ProductionLogEntry[]>(KEYS.PRODUCTION_LOG, activeBranch);
    const updatedLogs = currentLogsForBranch.map(log =>
      log.id === editingLogEntry.id
        ? {
            ...log,
            product: editProduct,
            batchSizeMultiplier: editBatchSizeMultiplier,
            expectedQuantity: updatedExpectedNum,
            actualQuantity: updatedActualNum,
            date: productDateStrNew,
            staff: editStaff.trim(),
            unitPrice: updatedUnitPriceNum,
            batchNumber: editBatchNumber.trim() || undefined,
            bagUsed: editSelectedBagName || undefined,
            labelUsed: editSelectedLabelName || undefined,
            timestamp: currentTimestamp, 
          }
        : log
    ).sort((a, b) => {
        const dateA = a.timestamp ? parseISO(a.timestamp).getTime() : (a.date ? parseISO(a.date).getTime() : 0);
        const dateB = b.timestamp ? parseISO(b.timestamp).getTime() : (b.date ? parseISO(b.date).getTime() : 0);
        return dateB - dateA;
    });
    saveProductionLogData(updatedLogs); 
    setAllProductionLog(updatedLogs);

    toast({ title: "Éxito", description: "Registro de producción actualizado." });
    setIsEditLogDialogOpen(false);
    setEditingLogEntry(null);
    setOriginalLogEntryForEdit(null);
    setIsSubmitting(false);
  };

  const handleOpenDeleteDialog = (logEntryId: string) => {
    setLogToDeleteId(logEntryId);
    setIsDeleteConfirmDialogOpen(true);
  };

  const handleConfirmDelete = () => {
    setIsSubmitting(true);
    const activeBranch = getActiveBranchId();
    if (!activeBranch || !logToDeleteId) {
        toast({title: "Error", description: "No hay sede activa o ID de registro para eliminar.", variant: "destructive"});
        setIsSubmitting(false); return;
    }
    const currentLogsForBranch = loadFromLocalStorageForBranch<ProductionLogEntry[]>(KEYS.PRODUCTION_LOG, activeBranch);
    const logEntryToDelete = currentLogsForBranch.find(entry => entry.id === logToDeleteId);

    if (!logEntryToDelete) {
      toast({ title: "Error", description: "Registro no encontrado.", variant: "destructive" });
      setIsSubmitting(false);
      setIsDeleteConfirmDialogOpen(false);
      return;
    }
    const recipesForBranch = loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, activeBranch);
    const recipeDetails = recipesForBranch.find(r => r.name.toLowerCase() === logEntryToDelete.product.toLowerCase());
    const materialsRevertedResult = consumeOrRevertMaterials(logEntryToDelete.product, logEntryToDelete.batchSizeMultiplier, 'revert');

    if (!materialsRevertedResult.success) {
        toast({ title: "Error", description: "No se pudo revertir el consumo de materiales al eliminar.", variant: "destructive" });
        setIsSubmitting(false);
        return;
    }

    if (recipeDetails && !recipeDetails.isIntermediate && logEntryToDelete.actualQuantity > 0) {
      updatePackagingMaterials(logEntryToDelete.actualQuantity, 'revert', { bagName: logEntryToDelete.bagUsed, labelName: logEntryToDelete.labelUsed });
    }

    if (recipeDetails && recipeDetails.isIntermediate) {
        let currentRawInventory = loadRawMaterialInventoryData(activeBranch);
        const idx = currentRawInventory.findIndex(
            item => item.name.toLowerCase() === recipeDetails.name.toLowerCase()
        );
        if (idx !== -1) {
            currentRawInventory[idx].quantity -= logEntryToDelete.actualQuantity;
            if(currentRawInventory[idx].quantity <= 0.0001) {
                currentRawInventory.splice(idx, 1);
            }
        }
        saveRawMaterialInventoryData(activeBranch, currentRawInventory.filter(item => item.quantity > 0.0001));
    } else {
        let currentProducts = loadProductsForBranch(activeBranch);
        const productIndex = currentProducts.findIndex(p => p.name.toLowerCase() === logEntryToDelete.product.toLowerCase());
        if (productIndex !== -1) {
            currentProducts[productIndex].stock -= logEntryToDelete.actualQuantity;
            if (currentProducts[productIndex].stock < 0) currentProducts[productIndex].stock = 0;
            saveProductsDataForBranch(activeBranch, currentProducts);
        }
        if (recipeDetails && !recipeDetails.isIntermediate) {
            updateProductionGoals(logEntryToDelete.product, logEntryToDelete.actualQuantity, logEntryToDelete.date, 'subtract');
        }
    }

    const updatedLogs = currentLogsForBranch.filter(log => log.id !== logToDeleteId).sort((a, b) => {
        const dateA = a.timestamp ? parseISO(a.timestamp).getTime() : (a.date ? parseISO(a.date).getTime() : 0);
        const dateB = b.timestamp ? parseISO(b.timestamp).getTime() : (b.date ? parseISO(b.date).getTime() : 0);
        return dateB - dateA;
    });
    saveProductionLogData(updatedLogs); 
    setAllProductionLog(updatedLogs);

    toast({ title: "Éxito", description: "Registro de producción eliminado y stock ajustado." });
    setIsDeleteConfirmDialogOpen(false);
    setLogToDeleteId(null);
    setIsSubmitting(false);
  };

  const formatBatchSize = (multiplier: number) => {
    const option = batchSizeOptions.find(opt => opt.value === multiplier);
    return option ? option.label : `${multiplier}x Saco Base`;
  };

  const calculateWastagePercentage = (expected: number, actual: number): string => {
    if (expected <= 0) return "N/A";
    if (actual >= expected) return "0.00%";
    const wastage = ((expected - actual) / expected) * 100;
    return `${wastage.toFixed(2)}%`;
  };

  const handleFilterApply = () => {
    applyFilters();
  };

  const handleClearFilters = () => {
    setDateRangeFilter(undefined);
    setFilterProductName('');
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-screen">
        <Loader2 className="h-12 w-12 animate-spin text-primary" />
        <p className="ml-4 text-lg">Cargando registros de producción...</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <PageHeader
        title="Seguimiento de Producción"
        description={`Registra las tandas de producción para la Sede Actual: ${availableBranches.find(b=>b.id === getActiveBranchId())?.name || 'No Seleccionada'}. El stock de producto terminado (o preparación intermedia) se actualizará y la materia prima se descontará del inventario según la receta y el tamaño de la tanda. Las metas de producción también se actualizarán.`}
        icon={Layers}
      />

      <Card className="shadow-lg">
        <CardHeader>
          <CardTitle>Registrar Tanda de Producción</CardTitle>
          <CardDescription>Ingresa los detalles del lote. Los ingredientes se descontarán del inventario de materia prima.</CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 items-end">
            <div className="space-y-1">
              <Label htmlFor="new_product_name_select">Nombre del Producto/Receta</Label>
              <Select value={newProductName} onValueChange={setNewProductName} disabled={isSubmitting}>
                <SelectTrigger id="new_product_name_select">
                  <SelectValue placeholder="Selecciona producto/receta" />
                </SelectTrigger>
                <SelectContent>
                  {productOptionsFromRecipes.map(option => (
                    <SelectItem key={option.id} value={option.name}>{option.name}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-1">
              <Label htmlFor="new_batch_size_select">Tamaño de Tanda</Label>
              <Select value={newBatchSizeMultiplier.toString()} onValueChange={(val) => setNewBatchSizeMultiplier(parseFloat(val))} disabled={isSubmitting}>
                <SelectTrigger id="new_batch_size_select">
                  <SelectValue placeholder="Selecciona tamaño" />
                </SelectTrigger>
                <SelectContent>
                  {batchSizeOptions.map(option => (
                    <SelectItem key={option.value} value={option.value.toString()}>{option.label}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
             <div className="space-y-1">
              <Label htmlFor="new_expected_quantity_input">Cantidad Esperada (unidades)</Label>
              <Input id="new_expected_quantity_input" type="number" placeholder="ej., 60" value={newExpectedQuantity} readOnly className="bg-muted/50" disabled={isSubmitting} />
            </div>
            <div className="space-y-1">
              <Label htmlFor="new_actual_quantity_input">Cantidad Real Producida (unidades)</Label>
              <Input id="new_actual_quantity_input" type="number" placeholder="ej., 55" value={newActualQuantity} onChange={(e) => setNewActualQuantity(e.target.value)} disabled={isSubmitting} />
            </div>
             <div className="space-y-1">
              <Label htmlFor="new_unit_price_input">Precio Unitario Producto (USD)</Label>
              <Input
                id="new_unit_price_input"
                type="number"
                placeholder="ej., 1.25 (Opcional para intermedios)"
                value={newUnitPrice}
                onChange={(e) => setNewUnitPrice(e.target.value)}
                disabled={isSubmitting}
                readOnly
                className="bg-muted/50"
              />
              {newUnitPrice && exchangeRate > 0 && 
                <p className="text-xs text-muted-foreground pt-1">
                  <FormattedNumber value={parseFloat(newUnitPrice) * exchangeRate} prefix="Bs. " />
                </p>
              }
            </div>
            <div className="space-y-1">
              <Label htmlFor="new_staff_input">Personal Encargado</Label>
              <Input id="new_staff_input" type="text" placeholder="ej., Ana Pérez" value={newStaff} onChange={(e) => setNewStaff(e.target.value)} disabled={isSubmitting} />
            </div>
            <div className="space-y-1">
              <Label htmlFor="new_production_date_picker">Fecha de Producción</Label>
              <Popover open={isNewDatePickerOpen} onOpenChange={setIsNewDatePickerOpen}>
                <PopoverTrigger asChild>
                  <Button
                    id="new_production_date_picker"
                    variant={"outline"}
                    className={cn("w-full justify-start text-left font-normal", !newDate && "text-muted-foreground")}
                    disabled={isSubmitting}
                  >
                    <CalendarIcon className="mr-2 h-4 w-4" />
                    {newDate ? format(newDate, "PPP", { locale: es }) : <span>Elige una fecha</span>}
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0">
                  <Calendar mode="single" selected={newDate} onSelect={(date) => { setNewDate(date); setIsNewDatePickerOpen(false); }} initialFocus locale={es} disabled={isSubmitting}/>
                </PopoverContent>
              </Popover>
            </div>
            <div className="space-y-1">
              <Label htmlFor="new_batch_number_input">Número de Lote (Opcional)</Label>
              <Input id="new_batch_number_input" type="text" placeholder="ej., LOTE240530A" value={newBatchNumber} onChange={(e) => setNewBatchNumber(e.target.value)} disabled={isSubmitting} />
            </div>
            <div className="space-y-1">
              <Label htmlFor="new_bag_select">Tipo de Bolsa (Opcional)</Label>
              <Select value={selectedBagName || '__NONE__'} onValueChange={(val) => setSelectedBagName(val === '__NONE__' ? '' : val)} disabled={isSubmitting}>
                <SelectTrigger id="new_bag_select">
                  <SelectValue placeholder="Selecciona tipo de bolsa" />
                </SelectTrigger>
                <SelectContent>
                    <SelectItem value="__NONE__">Ninguna</SelectItem>
                    {availableBags.map(bag => <SelectItem key={bag} value={bag}>{bag}</SelectItem>)}
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-1">
              <Label htmlFor="new_label_select">Tipo de Etiqueta (Opcional)</Label>
              <Select value={selectedLabelName || '__NONE__'} onValueChange={(val) => setSelectedLabelName(val === '__NONE__' ? '' : val)} disabled={isSubmitting}>
                <SelectTrigger id="new_label_select">
                  <SelectValue placeholder="Selecciona tipo de etiqueta" />
                </SelectTrigger>
                <SelectContent>
                    <SelectItem value="__NONE__">Ninguna</SelectItem>
                    {availableLabels.map(label => <SelectItem key={label} value={label}>{label}</SelectItem>)}
                </SelectContent>
              </Select>
            </div>
          </div>
          <div className="flex justify-center mt-6">
            <Button onClick={handleAddLogEntry} disabled={isSubmitting || productOptionsFromRecipes.length === 0} className="w-full sm:w-auto md:w-1/2 lg:w-1/3">
                {isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <PlusCircle className="mr-2 h-4 w-4" />}
                {isSubmitting ? 'Registrando...' : 'Registrar Producción'}
            </Button>
          </div>
        </CardContent>
      </Card>


      <Card className="shadow-lg mt-6">
        <CardHeader>
          <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
            <div>
              <CardTitle>Registro de Producción Diario</CardTitle>
              <CardDescription>Historial de todas las tandas de producción.</CardDescription>
            </div>
            <div className="flex flex-col sm:flex-row items-center gap-2 w-full sm:w-auto">
                <div className="relative flex-grow sm:flex-grow-0">
                    <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
                    <Input
                        type="search"
                        placeholder="Buscar por producto..."
                        className="pl-8 w-full sm:w-[200px]"
                        value={filterProductName}
                        onChange={(e) => setFilterProductName(e.target.value)}
                        disabled={isSubmitting || isLoading}
                    />
                </div>
                <Popover>
                  <PopoverTrigger asChild>
                    <Button
                      id="date-filter-production"
                      variant={"outline"}
                      className={cn(
                        "w-full sm:w-[260px] justify-start text-left font-normal",
                        !dateRangeFilter && "text-muted-foreground"
                      )}
                       disabled={isSubmitting || isLoading}
                    >
                      <CalendarIcon className="mr-2 h-4 w-4" />
                      {dateRangeFilter?.from ? (
                        dateRangeFilter.to ? (
                          <>
                            {format(dateRangeFilter.from, "LLL dd, y", { locale: es })} -{" "}
                            {format(dateRangeFilter.to, "LLL dd, y", { locale: es })}
                          </>
                        ) : (
                          format(dateRangeFilter.from, "LLL dd, y", { locale: es })
                        )
                      ) : (
                        <span>Elige un rango de fechas</span>
                      )}
                    </Button>
                  </PopoverTrigger>
                  <PopoverContent className="w-auto p-0" align="end">
                    <Calendar
                      initialFocus
                      mode="range"
                      defaultMonth={dateRangeFilter?.from}
                      selected={dateRangeFilter}
                      onSelect={setDateRangeFilter}
                      numberOfMonths={2}
                      locale={es}
                      disabled={isSubmitting || isLoading}
                    />
                  </PopoverContent>
                </Popover>
                <Button onClick={handleFilterApply} className="w-full sm:w-auto" disabled={isSubmitting || isLoading}>
                  <Filter className="mr-2 h-4 w-4" /> Aplicar Filtros
                </Button>
                <Button onClick={handleClearFilters} variant="outline" className="w-full sm:w-auto" disabled={isSubmitting || isLoading}>Limpiar</Button>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Fecha Prod.</TableHead>
                <TableHead>Nro. Lote</TableHead>
                <TableHead>Producto/Receta</TableHead>
                <TableHead>Tamaño Tanda</TableHead>
                <TableHead className="text-right">Cant. Esperada</TableHead>
                <TableHead className="text-right">Cant. Real</TableHead>
                <TableHead className="text-right">
                  Merma (% y Costo Total USD)
                  <TooltipProvider>
                    <Tooltip>
                      <TooltipTrigger asChild><Button variant="ghost" size="icon" className="ml-1 h-4 w-4 p-0 align-middle -translate-y-0.5"><Info className="h-3 w-3 text-muted-foreground" /></Button></TooltipTrigger>
                      <TooltipContent className="max-w-xs"><p>Costo merma = Unidades perdidas * (Costo ingredientes + Costo operativo). NO incluye empaque.</p></TooltipContent>
                    </Tooltip>
                  </TooltipProvider>
                </TableHead>
                <TableHead className="text-right">Costo Total Tanda (USD)</TableHead>
                <TableHead className="text-right">Ingreso Venta Potencial (USD)</TableHead>
                <TableHead>Personal</TableHead>
                <TableHead>Empaque Usado</TableHead>
                <TableHead className="text-right">Acciones</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {filteredProductionLog.map((log) => {
                const ingresoPotencialUSD = log.actualQuantity * log.unitPrice;
                const unidadesMermadas = log.expectedQuantity - log.actualQuantity;
                let costoMermaUSD = 0;
                let costoTotalTandaUSD = 0;
                const activeBranch = getActiveBranchId();
                const recipesForBranch = activeBranch ? loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, activeBranch) : [];
                const recipeDetails = recipesForBranch.find(r => r.name === log.product);
                
                if (recipeDetails && !recipeDetails.isIntermediate) {
                    const costoIngredientesPorTanda = calculateDynamicRecipeCost(recipeDetails.id, 'highest', recipesForBranch); 
                    const costoIngredientesPorUnidad = (recipeDetails.expectedYield && recipeDetails.expectedYield > 0) ? costoIngredientesPorTanda / recipeDetails.expectedYield : 0;

                    let costoOperativoPorUnidad = 0;
                    if (recipeDetails.expectedYield && recipeDetails.expectedYield > 0 && costPerSackThisWeek !== null && costPerSackThisWeek >= 0) {
                        costoOperativoPorUnidad = costPerSackThisWeek / recipeDetails.expectedYield;
                    }
                    const costoTotalPorUnidadSinEmpaque = costoIngredientesPorUnidad + costoOperativoPorUnidad;

                    if (unidadesMermadas > 0) {
                        costoMermaUSD = unidadesMermadas * costoTotalPorUnidadSinEmpaque;
                    }
                    const costoEmpaqueTanda = calculatePackagingCost(log.actualQuantity).maxCost; // Costo máximo para ser conservador
                    costoTotalTandaUSD = (log.actualQuantity * costoTotalPorUnidadSinEmpaque) + costoEmpaqueTanda;

                }
                return (
                <TableRow key={log.id}>
                  <TableCell>
                    {log.date && isValid(parseISO(log.date)) ? format(parseISO(log.date), "dd/MM/yy", { locale: es }) : '-'}
                    {log.timestamp && isValid(parseISO(log.timestamp)) && (
                        <span className="block text-xs text-muted-foreground">
                           (Reg: {format(parseISO(log.timestamp), "dd/MM HH:mm", { locale: es })})
                        </span>
                    )}
                  </TableCell>
                  <TableCell>{log.batchNumber || '-'}</TableCell>
                  <TableCell className="font-medium">{log.product}</TableCell>
                  <TableCell>{formatBatchSize(log.batchSizeMultiplier)}</TableCell>
                  <TableCell className="text-right">{log.expectedQuantity}</TableCell>
                  <TableCell className="text-right">{log.actualQuantity}</TableCell>
                  <TableCell className="text-right">
                    {calculateWastagePercentage(log.expectedQuantity, log.actualQuantity)}
                    {unidadesMermadas > 0 && ` (`}<FormattedNumber value={unidadesMermadas > 0 ? costoMermaUSD : undefined} prefix="$" />{unidadesMermadas > 0 && `)`}
                  </TableCell>
                  <TableCell className="text-right"><FormattedNumber value={costoTotalTandaUSD > 0 ? costoTotalTandaUSD : undefined} prefix="$" /></TableCell>
                  <TableCell className="text-right"><FormattedNumber value={ingresoPotencialUSD} prefix="$" /></TableCell>
                  <TableCell>{log.staff}</TableCell>
                  <TableCell>
                    {log.bagUsed && <div className="text-xs">B: {log.bagUsed}</div>}
                    {log.labelUsed && <div className="text-xs">E: {log.labelUsed}</div>}
                    {!log.bagUsed && !log.labelUsed && "-"}
                  </TableCell>
                  <TableCell className="text-right">
                    <DropdownMenu>
                      <DropdownMenuTrigger asChild>
                        <Button variant="ghost" size="icon" disabled={isSubmitting}>
                          <MoreHorizontal className="h-4 w-4" />
                        </Button>
                      </DropdownMenuTrigger>
                      <DropdownMenuContent align="end">
                        <DropdownMenuItem onClick={() => handleOpenEditDialog(log)} disabled={isSubmitting}>
                          <Edit className="mr-2 h-4 w-4" />
                          Editar
                        </DropdownMenuItem>
                        <DropdownMenuItem
                          onClick={() => handleOpenDeleteDialog(log.id)}
                          className="text-destructive focus:text-destructive-foreground focus:bg-destructive"
                          disabled={isSubmitting}
                        >
                          <Trash2 className="mr-2 h-4 w-4" />
                          Eliminar
                        </DropdownMenuItem>
                      </DropdownMenuContent>
                    </DropdownMenu>
                  </TableCell>
                </TableRow>
              );})}
            </TableBody>
          </Table>
           {filteredProductionLog.length === 0 && !isLoading && (
            <p className="text-center text-muted-foreground py-8">
              {dateRangeFilter?.from || filterProductName ? "No hay registros de producción para los filtros seleccionados." : "No hay registros de producción."}
            </p>
          )}
        </CardContent>
      </Card>

      <Dialog open={isEditLogDialogOpen}
              onOpenChange={(isOpen) => {
                if (isSubmitting) return;
                setIsEditLogDialogOpen(isOpen);
                if(!isOpen) {setEditingLogEntry(null); setOriginalLogEntryForEdit(null);}}
              }>
        <DialogContent className="sm:max-w-lg">
          <DialogHeader>
            <DialogTitle>Editar Registro de Producción</DialogTitle>
            <DialogDescription>
              Actualiza los detalles del registro. Los cambios afectarán el inventario de producto terminado y materia prima.
            </DialogDescription>
          </DialogHeader>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 py-4">
            <div className="space-y-1 md:col-span-2">
              <Label htmlFor="edit_product_name_select">Nombre del Producto/Receta</Label>
               <Select value={editProduct} onValueChange={setEditProduct} disabled={isSubmitting}>
                <SelectTrigger id="edit_product_name_select">
                  <SelectValue placeholder="Selecciona producto/receta" />
                </SelectTrigger>
                <SelectContent>
                  {productOptionsFromRecipes.map(option => (
                    <SelectItem key={option.id} value={option.name}>{option.name}</SelectItem>
                  ))}
                  {!productOptionsFromRecipes.find(p=> p.name === editProduct) && editingLogEntry && (
                    <SelectItem value={editingLogEntry.product} disabled>
                      {editingLogEntry.product} (Original)
                    </SelectItem>
                  )}
                </SelectContent>
              </Select>
            </div>
             <div className="space-y-1">
              <Label htmlFor="edit_batch_size_select">Tamaño de Tanda</Label>
              <Select value={editBatchSizeMultiplier.toString()} onValueChange={(val) => setEditBatchSizeMultiplier(parseFloat(val))} disabled={isSubmitting}>
                <SelectTrigger id="edit_batch_size_select">
                  <SelectValue placeholder="Selecciona tamaño" />
                </SelectTrigger>
                <SelectContent>
                  {batchSizeOptions.map(option => (
                    <SelectItem key={option.value} value={option.value.toString()}>{option.label}</SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-1">
              <Label htmlFor="edit_expected_quantity_input">Cantidad Esperada (unidades)</Label>
              <Input id="edit_expected_quantity_input" type="number" value={editExpectedQuantity} readOnly className="bg-muted/50" disabled={isSubmitting} />
            </div>
            <div className="space-y-1">
              <Label htmlFor="edit_actual_quantity_input">Cantidad Real Producida (unidades)</Label>
              <Input id="edit_actual_quantity_input" type="number" value={editActualQuantity} onChange={(e) => setEditActualQuantity(e.target.value)} disabled={isSubmitting} />
            </div>
            <div className="space-y-1">
              <Label htmlFor="edit_unit_price_input">Precio Unitario Producto (USD)</Label>
              <Input
                id="edit_unit_price_input"
                type="number"
                value={editUnitPrice}
                onChange={(e) => setEditUnitPrice(e.target.value)}
                disabled={isSubmitting}
                placeholder="(Opcional para intermedios)"
                readOnly
                className="bg-muted/50"
              />
              {editUnitPrice && exchangeRate > 0 && 
                <p className="text-xs text-muted-foreground pt-1">
                    <FormattedNumber value={parseFloat(editUnitPrice) * exchangeRate} prefix="Bs. " />
                </p>
              }
            </div>
            <div className="space-y-1">
              <Label htmlFor="edit_staff_input">Personal Encargado</Label>
              <Input id="edit_staff_input" type="text" value={editStaff} onChange={(e) => setEditStaff(e.target.value)} disabled={isSubmitting} />
            </div>
             <div className="space-y-1">
              <Label htmlFor="edit_batch_number_input">Número de Lote (Opcional)</Label>
              <Input id="edit_batch_number_input" type="text" value={editBatchNumber} onChange={(e) => setEditBatchNumber(e.target.value)} disabled={isSubmitting} />
            </div>
            <div className="space-y-1">
              <Label htmlFor="edit_date_picker">Fecha de Producción</Label>
               <Popover open={isEditDatePickerOpen} onOpenChange={setIsEditDatePickerOpen}>
                <PopoverTrigger asChild>
                  <Button
                    id="edit_date_picker"
                    variant={"outline"}
                    className={cn(
                      "w-full justify-start text-left font-normal",
                      !editDate && "text-muted-foreground"
                    )}
                    disabled={isSubmitting}
                  >
                    <CalendarIcon className="mr-2 h-4 w-4" />
                    {editDate ? format(editDate, "PPP", { locale: es }) : <span>Elige una fecha</span>}
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0">
                  <Calendar
                    mode="single"
                    selected={editDate}
                    onSelect={(date) => { setEditDate(date); setIsEditDatePickerOpen(false); }}
                    initialFocus
                    locale={es}
                    disabled={isSubmitting}
                  />
                </PopoverContent>
              </Popover>
            </div>
            <div className="space-y-1">
              <Label htmlFor="edit_bag_select">Tipo de Bolsa (Opcional)</Label>
              <Select value={editSelectedBagName || '__NONE__'} onValueChange={(val) => setEditSelectedBagName(val === '__NONE__' ? '' : val)} disabled={isSubmitting}>
                <SelectTrigger id="edit_bag_select"><SelectValue placeholder="Selecciona bolsa" /></SelectTrigger>
                <SelectContent><SelectItem value="__NONE__">Ninguna</SelectItem>{availableBags.map(bag => <SelectItem key={bag} value={bag}>{bag}</SelectItem>)}</SelectContent>
              </Select>
            </div>
            <div className="space-y-1">
              <Label htmlFor="edit_label_select">Tipo de Etiqueta (Opcional)</Label>
              <Select value={editSelectedLabelName || '__NONE__'} onValueChange={(val) => setEditSelectedLabelName(val === '__NONE__' ? '' : val)} disabled={isSubmitting}>
                <SelectTrigger id="edit_label_select"><SelectValue placeholder="Selecciona etiqueta" /></SelectTrigger>
                <SelectContent><SelectItem value="__NONE__">Ninguna</SelectItem>{availableLabels.map(label => <SelectItem key={label} value={label}>{label}</SelectItem>)}</SelectContent>
              </Select>
            </div>
          </div>
          <DialogFooter>
            <DialogClose asChild><Button variant="outline" onClick={() => {if (!isSubmitting) {setIsEditLogDialogOpen(false); setEditingLogEntry(null); setOriginalLogEntryForEdit(null);}}} disabled={isSubmitting}>Cancelar</Button></DialogClose>
            <Button type="button" onClick={handleUpdateLogEntry} disabled={isSubmitting || productOptionsFromRecipes.length === 0}>
              {isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Edit className="mr-2 h-4 w-4" />}
              {isSubmitting ? 'Guardando...' : 'Guardar Cambios'}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <Dialog open={isDeleteConfirmDialogOpen} onOpenChange={(isOpen) => { if (!isSubmitting) setIsDeleteConfirmDialogOpen(isOpen) }}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Confirmar Eliminación</DialogTitle>
            <DialogDescription>
              ¿Estás seguro de que quieres eliminar este registro? Esta acción ajustará el stock de producto terminado y materia prima, así como las metas de producción.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter className="sm:justify-end">
            <DialogClose asChild><Button variant="outline" onClick={() => {if (!isSubmitting) {setIsDeleteConfirmDialogOpen(false); setLogToDeleteId(null)}}} disabled={isSubmitting}>Cancelar</Button></DialogClose>
            <Button variant="destructive" onClick={handleConfirmDelete} disabled={isSubmitting}>
              {isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Trash2 className="mr-2 h-4 w-4" />}
              {isSubmitting ? 'Eliminando...' : 'Eliminar Registro'}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <AlertDialog open={showDeficitAlert} onOpenChange={(open) => { if (!open) { setShowDeficitAlert(false); setIsSubmitting(false); setDeficitType(null); setBestTransferSourceInfo(null); } }}>
        <AlertDialogContent className="sm:max-w-3xl">
          <AlertDialogHeader>
            <AlertDialogTitle>
              {deficitType === 'intermediate_missing_components_available' && "Error: Preparación Intermedia Faltante"}
              {deficitType === 'intermediate_missing_components_missing' && "Error: Faltan Componentes para Preparación Intermedia"}
              {deficitType === 'intermediate_stock_shortage' && "Error: Stock Insuficiente de Preparación Intermedia"}
              {deficitType === 'raw_material_shortage' && "Error: Materia Prima Insuficiente/Faltante"}
              {!deficitType && "Error de Materiales"}
            </AlertDialogTitle>
            <AlertDialogDescription>
              No se puede registrar/actualizar la producción. Verifica lo siguiente:
            </AlertDialogDescription>
            <ul className="list-disc list-inside text-xs mt-2 max-h-40 overflow-y-auto">
              {deficitMaterials.map((def, i) => (
                <li key={i}>
                  '{def.name}': Necesita <FormattedNumber value={def.needed} decimalPlaces={3} /> {def.unit}.
                  {def.available !== undefined ? (
                    <> Disponible: <FormattedNumber value={def.available} decimalPlaces={3} /> {def.inventoryUnit}.</>
                  ) : (
                    ` No encontrado o unidad incompatible en inventario.`
                  )}
                </li>
              ))}
            </ul>
             {bestTransferSourceInfo && bestTransferSourceInfo.transferableItems.length > 0 && (
                <div className="my-2 p-3 border rounded-md bg-green-500/10 border-green-500/20">
                    <AlertTitle className="text-green-700 dark:text-green-300">¡Transferencia Parcial Posible!</AlertTitle>
                    <AlertDescription className="text-green-600 dark:text-green-400">
                        La sede "{bestTransferSourceInfo.branch.name}" tiene algunos de los materiales que necesitas.
                        <ul className="list-disc list-inside mt-2 text-xs">
                            {bestTransferSourceInfo.transferableItems.map((item, i) => (
                                <li key={i}>{item.name}: Se pueden transferir hasta <FormattedNumber value={item.available} decimalPlaces={3}/> {item.unit} (necesitas <FormattedNumber value={item.needed} decimalPlaces={3}/> {item.unit}).</li>
                            ))}
                        </ul>
                    </AlertDescription>
                </div>
            )}
             {(deficitType === 'raw_material_shortage' || deficitType === 'intermediate_missing_components_missing') && (
              <p className="text-sm text-muted-foreground mt-3">
                {deficitType === 'intermediate_missing_components_missing'
                    ? `Además de la preparación intermedia faltante, no tienes suficientes componentes para producirla. `
                    : ''
                }
                Puedes crear una Orden de Compra o una Transferencia Parcial si es posible.
              </p>
            )}
             {(deficitType === 'intermediate_stock_shortage' || deficitType === 'intermediate_missing_components_available' ) && (
              <p className="text-sm text-muted-foreground mt-3">
                La preparación intermedia requerida falta en stock. Por favor, regístrala primero en este módulo.
              </p>
            )}
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel onClick={() => {
              setShowDeficitAlert(false);
              setDeficitMaterials([]);
              setCurrentProductionDeficitData(null);
              setDeficitType(null);
              setBestTransferSourceInfo(null);
              setIsSubmitting(false);
            }}>
              Cancelar
            </AlertDialogCancel>
            {bestTransferSourceInfo && bestTransferSourceInfo.transferableItems.length > 0 && (
                <AlertDialogAction onClick={() => handleCreateTransferFromDeficit(bestTransferSourceInfo.branch.id, bestTransferSourceInfo.transferableItems)}>
                    Crear Transferencia desde {bestTransferSourceInfo.branch.name}
                </AlertDialogAction>
            )}
            {(deficitType === 'raw_material_shortage' || deficitType === 'intermediate_missing_components_missing') && (
              <AlertDialogAction onClick={handleCreatePOFromDeficit}>
                Crear OC Pendiente {bestTransferSourceInfo ? 'para el Resto' : ''}
              </AlertDialogAction>
            )}
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

    </div>
  );
}

// --- profile ---


"use client";

import React, { useState, useEffect } from 'react';
import { PageHeader } from '@/components/page-header';
import { Card, CardContent, CardDescription, CardHeader, CardTitle, CardFooter } from '@/components/ui/card';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { UserCircle, Edit3 } from 'lucide-react';
import { useToast } from "@/hooks/use-toast";
import { 
  userProfileData, 
  saveUserProfileData,
  type UserProfile
} from '@/lib/data-storage';

export default function ProfilePage() {
  const { toast } = useToast();

  const [fullName, setFullName] = useState("");
  const [email, setEmail] = useState("");
  const [phone, setPhone] = useState("");
  // Los campos de contraseña se eliminan ya que las credenciales son fijas.
  
  const [isDataLoaded, setIsDataLoaded] = useState(false);

  useEffect(() => {
    if (userProfileData) {
      setFullName(userProfileData.fullName || "");
      setEmail(userProfileData.email || "");
      setPhone(userProfileData.phone || "");
    }
    setIsDataLoaded(true);
  }, []);


  const handleUpdateProfile = () => {
    if (!fullName || !email) {
        toast({
            title: "Error",
            description: "Nombre completo y correo electrónico son obligatorios.",
            variant: "destructive",
        });
        return;
    }
    
    const updatedProfile: Partial<UserProfile> = { // Partial porque no cambiamos email
      fullName,
      // email: email, // Email del admin no debería ser editable
      phone,
    };

    // Conservar el email y moduleAccess existentes, actualizar el resto
    const currentProfile = userProfileData;
    const profileToSave: UserProfile = {
        ...currentProfile,
        fullName: updatedProfile.fullName || currentProfile.fullName,
        phone: updatedProfile.phone || currentProfile.phone,
    };

    saveUserProfileData(profileToSave); 
    
    toast({
      title: "Perfil Actualizado",
      description: "Tu información de perfil ha sido actualizada.",
    });
  };

  if (!isDataLoaded) {
    return (
      <div className="flex items-center justify-center min-h-[calc(100vh-10rem)]">
        <p className="text-lg">Cargando perfil...</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <PageHeader
        title="Perfil de Usuario"
        description="Gestiona la información de tu cuenta de administrador."
        icon={UserCircle}
      />

      <Card className="shadow-lg max-w-3xl mx-auto">
        <CardHeader className="text-center">
            <Avatar className="mx-auto h-24 w-24 mb-4 ring-2 ring-primary ring-offset-2 ring-offset-background">
                <AvatarImage src="https://placehold.co/100x100.png" alt="Avatar de Administrador" data-ai-hint="person portrait" />
                <AvatarFallback>{(fullName || "AD").split(' ').map(n => n[0]).join('').toUpperCase()}</AvatarFallback>
            </Avatar>
          <CardTitle className="text-2xl">{fullName || "Administrador"}</CardTitle>
          <CardDescription>{email || "admin@panaderiapro.com"}</CardDescription>
        </CardHeader>
        <CardContent className="space-y-6 p-6">
          <div>
            <h3 className="text-lg font-semibold mb-3 text-foreground">Información Personal</h3>
            <div className="space-y-4">
              <div>
                <Label htmlFor="fullName">Nombre Completo</Label>
                <Input id="fullName" value={fullName || ""} onChange={(e) => setFullName(e.target.value)} />
              </div>
              <div>
                <Label htmlFor="email">Correo Electrónico (No editable)</Label>
                <Input id="email" type="email" value={email || ""} disabled />
              </div>
              <div>
                <Label htmlFor="phone">Número de Teléfono</Label>
                <Input id="phone" type="tel" value={phone || ""} onChange={(e) => setPhone(e.target.value)} />
              </div>
            </div>
          </div>

          {/* Sección de cambio de contraseña eliminada */}
          {/* Sección de permisos de módulo eliminada */}

        </CardContent>
        <CardFooter>
           <Button className="w-full" onClick={handleUpdateProfile}>
            <Edit3 className="mr-2 h-4 w-4" /> Actualizar Perfil
          </Button>
        </CardFooter>
      </Card>
    </div>
  );
}

// --- raw-material-inventory ---


"use client";

import React, { useState, useEffect, useCallback } from 'react';
import { PageHeader } from '@/components/page-header';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogClose } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Archive, Loader2, Trash2, Info, PlusCircle } from 'lucide-react';
import { useToast } from "@/hooks/use-toast";
import {
    loadRawMaterialInventoryData,
    saveRawMaterialInventoryData,
    type RawMaterialInventoryItem,
    KEYS,
    getLowestPriceInfo,
    getHighestPriceInfo,
    loadExchangeRate,
    recipesData as initialRecipesData, 
    type Recipe,                       
    calculateDynamicRecipeCost,
    getActiveBranchId,
    availableBranches,
    commonUnitOptions,
    getCurrentRawMaterialOptions,
    convertMaterialToBaseUnit,
    normalizeUnit,
    VALID_BASE_UNITS
} from '@/lib/data-storage';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { FormattedNumber } from '@/components/ui/formatted-number';

export default function RawMaterialInventoryPage() {
  const { toast } = useToast();
  const [rawMaterialsStock, setRawMaterialsStock] = useState<RawMaterialInventoryItem[]>([]);
  const [recipes, setRecipes] = useState<Recipe[]>([]); 
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [exchangeRate, setExchangeRate] = useState<number>(0);

  const [isDeleteConfirmOpen, setIsDeleteConfirmOpen] = useState(false);
  const [itemToDelete, setItemToDelete] = useState<RawMaterialInventoryItem | null>(null);

  const [activeBranchName, setActiveBranchName] = useState<string>('');
  const [availableRawMaterials, setAvailableRawMaterials] = useState<string[]>([]);
  
  const [isAdjustDialogOpen, setIsAdjustDialogOpen] = useState(false);
  const [adjustmentType, setAdjustmentType] = useState<'add' | 'subtract'>('add');
  const [materialToAdjust, setMaterialToAdjust] = useState('');
  const [adjustmentQuantity, setAdjustmentQuantity] = useState('');
  const [adjustmentUnit, setAdjustmentUnit] = useState('');
  const [adjustmentReason, setAdjustmentReason] = useState('');

  const loadAndDisplayInventory = useCallback(() => {
    setIsLoading(true);
    const activeBranch = getActiveBranchId();
    if (!activeBranch) {
      toast({ title: "Error de Sede", description: "No se ha seleccionado una sede activa para ver el inventario.", variant: "destructive" });
      setIsLoading(false);
      setRawMaterialsStock([]);
      setRecipes([]);
      setActiveBranchName('Ninguna');
      return;
    }

    const branchInfo = availableBranches.find(b => b.id === activeBranch);
    setActiveBranchName(branchInfo ? branchInfo.name : 'Desconocida');

    const currentInventory = loadRawMaterialInventoryData(activeBranch);
    const sortedInventory = [...currentInventory].sort((a, b) =>
      a.name.localeCompare(b.name)
    );
    setRawMaterialsStock(sortedInventory);
    setRecipes([...initialRecipesData]); 
    setExchangeRate(loadExchangeRate());
    
    const rawMaterialNames = getCurrentRawMaterialOptions();
    setAvailableRawMaterials(rawMaterialNames);
    if(rawMaterialNames.length > 0) {
      setMaterialToAdjust(rawMaterialNames[0]);
      setAdjustmentUnit(commonUnitOptions[0] || '');
    }

    setIsLoading(false);
  }, [toast]);

  useEffect(() => {
    loadAndDisplayInventory();

    const handleDataUpdate = (event: Event) => {
      const customEvent = event as CustomEvent;
      if (customEvent.detail?.key === KEYS.RAW_MATERIAL_INVENTORY || 
          customEvent.detail?.key === KEYS.EXCHANGE_RATE ||
          customEvent.detail?.key === KEYS.RECIPES ||
          customEvent.detail?.key === KEYS.ACTIVE_BRANCH_ID ||
          customEvent.detail?.key === KEYS.RAW_MATERIAL_OPTIONS) { 
        loadAndDisplayInventory();
      }
    };

    window.addEventListener('data-updated', handleDataUpdate);
    return () => {
      window.removeEventListener('data-updated', handleDataUpdate);
    };
  }, [loadAndDisplayInventory]);

  const resetAdjustForm = () => {
    setAdjustmentType('add');
    setMaterialToAdjust(availableRawMaterials[0] || '');
    setAdjustmentQuantity('');
    setAdjustmentUnit(commonUnitOptions[0] || '');
    setAdjustmentReason('');
  };

  const handleOpenDeleteDialog = (material: RawMaterialInventoryItem) => {
    setItemToDelete(material);
    setIsDeleteConfirmOpen(true);
  };

  const handleConfirmDelete = () => {
    if (!itemToDelete) return;
    
    const activeBranch = getActiveBranchId();
    if (!activeBranch) {
      toast({ title: "Error de Sede", description: "No se puede eliminar el ítem sin una sede activa.", variant: "destructive" });
      setIsSubmitting(false);
      setIsDeleteConfirmOpen(false);
      return;
    }
    setIsSubmitting(true);

    const currentInventory = loadRawMaterialInventoryData(activeBranch); 
    const updatedInventory = currentInventory.filter(
      item => !(item.name.toLowerCase() === itemToDelete.name.toLowerCase() && item.unit.toLowerCase() === itemToDelete.unit.toLowerCase())
    );

    saveRawMaterialInventoryData(activeBranch, updatedInventory); 

    toast({
      title: "Éxito",
      description: `"${itemToDelete.name}" eliminado del inventario de materia prima de la sede actual.`,
    });

    setIsDeleteConfirmOpen(false);
    setItemToDelete(null);
    setIsSubmitting(false);
  };
  
  const handleSaveAdjustment = () => {
    const activeBranch = getActiveBranchId();
    if (!activeBranch) {
      toast({ title: "Error", description: "No hay sede activa.", variant: "destructive" });
      return;
    }
    if (!materialToAdjust || !adjustmentQuantity || !adjustmentUnit) {
      toast({ title: "Error", description: "Material, cantidad y unidad son obligatorios.", variant: "destructive" });
      return;
    }
    const quantityNum = parseFloat(adjustmentQuantity);
    if (isNaN(quantityNum) || quantityNum <= 0) {
      toast({ title: "Error", description: "La cantidad debe ser un número positivo.", variant: "destructive" });
      return;
    }

    setIsSubmitting(true);

    let inventory = loadRawMaterialInventoryData(activeBranch);
    const { quantity: baseQuantity, unit: baseUnit } = convertMaterialToBaseUnit(
      quantityNum,
      adjustmentUnit,
      materialToAdjust
    );

    if (!VALID_BASE_UNITS.includes(baseUnit)) {
      toast({ title: "Error de Unidad", description: `No se pudo convertir '${adjustmentUnit}' a una unidad base válida para '${materialToAdjust}'.`, variant: "destructive" });
      setIsSubmitting(false);
      return;
    }

    const itemIndex = inventory.findIndex(
      item => item.name.toLowerCase() === materialToAdjust.toLowerCase() && normalizeUnit(item.unit) === normalizeUnit(baseUnit)
    );

    if (adjustmentType === 'add') {
      if (itemIndex !== -1) {
        inventory[itemIndex].quantity += baseQuantity;
      } else {
        const existingWithDifferentUnit = inventory.findIndex(item => item.name.toLowerCase() === materialToAdjust.toLowerCase());
        if(existingWithDifferentUnit !== -1) {
             toast({ title: "Error de Unidad", description: `El material '${materialToAdjust}' ya existe en inventario con una unidad base diferente. Realiza el ajuste en la unidad existente.`, variant: "destructive", duration: 7000 });
             setIsSubmitting(false);
             return;
        }
        inventory.push({ name: materialToAdjust, quantity: baseQuantity, unit: baseUnit });
      }
    } else { // subtract
      if (itemIndex === -1) {
        toast({ title: "Error", description: `No se encontró '${materialToAdjust}' con la unidad base '${baseUnit}' en el inventario para restar.`, variant: "destructive" });
        setIsSubmitting(false);
        return;
      }
      if (inventory[itemIndex].quantity < baseQuantity) {
        toast({ title: "Error de Stock", description: `No se puede restar ${baseQuantity.toFixed(3)} ${baseUnit}. Stock actual: ${inventory[itemIndex].quantity.toFixed(3)} ${baseUnit}.`, variant: "destructive" });
        setIsSubmitting(false);
        return;
      }
      inventory[itemIndex].quantity -= baseQuantity;
    }

    saveRawMaterialInventoryData(activeBranch, inventory);
    toast({ title: "Éxito", description: `Inventario para '${materialToAdjust}' ajustado correctamente.` });

    setIsSubmitting(false);
    setIsAdjustDialogOpen(false);
  };

  return (
    <div className="space-y-6">
      <PageHeader
        title={`Inventario de Materia Prima (Sede: ${activeBranchName})`}
        description="Resumen del stock de materia prima y preparaciones intermedias. Ahora puedes hacer ajustes manuales para añadir o restar stock sin una orden de compra."
        icon={Archive}
        actions={
          <Button onClick={() => { resetAdjustForm(); setIsAdjustDialogOpen(true); }} disabled={isSubmitting}>
            <PlusCircle className="mr-2 h-4 w-4" />
            Ajustar Stock
          </Button>
        }
      />

      <Card className="shadow-lg">
        <CardHeader>
          <CardTitle>Stock Actual de Materia Prima y Preparaciones</CardTitle>
          <CardDescription>
            Cantidades en unidades estándar (kg, g, L, ml, unidad) y su valorización estimada.
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button variant="ghost" size="icon" className="ml-1 h-5 w-5 p-0 align-middle -translate-y-0.5">
                    <Info className="h-4 w-4 text-muted-foreground" />
                  </Button>
                </TooltipTrigger>
                <TooltipContent className="max-w-xs">
                  <p>El costo de Materias Primas se basa en los precios de proveedores. El costo de Preparaciones Intermedias (ej. Melado) se basa en el costo de sus ingredientes según la receta.</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          </CardDescription>
        </CardHeader>
        <CardContent>
          {isLoading && rawMaterialsStock.length === 0 ? (
             <div className="flex items-center justify-center min-h-[200px]">
                <Loader2 className="h-8 w-8 animate-spin text-primary" />
                <p className="ml-3 text-muted-foreground">Cargando inventario de materia prima...</p>
            </div>
          ) : (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Ingrediente/Preparación</TableHead>
                  <TableHead className="text-right">Cantidad</TableHead>
                  <TableHead>Unidad (Base)</TableHead>
                  <TableHead className="text-right">Costo Total Stock (USD)</TableHead>
                  <TableHead className="text-right">Costo Total Stock (VES)</TableHead>
                  <TableHead className="text-right">Acciones</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {rawMaterialsStock.length > 0 ? (
                  rawMaterialsStock.map((material) => {
                    let totalCostMinUSD: number | null = null;
                    let totalCostMaxUSD: number | null = null;

                    const correspondingRecipe = recipes.find(
                      (r) => r.name.toLowerCase() === material.name.toLowerCase() && r.isIntermediate
                    );

                    if (correspondingRecipe && correspondingRecipe.expectedYield && correspondingRecipe.expectedYield > 0) {
                      const costOfTandaMin = calculateDynamicRecipeCost(correspondingRecipe.id, 'lowest');
                      const costOfTandaMax = calculateDynamicRecipeCost(correspondingRecipe.id, 'highest');
                      const costPerUnitMin = costOfTandaMin / correspondingRecipe.expectedYield;
                      const costPerUnitMax = costOfTandaMax / correspondingRecipe.expectedYield;
                      totalCostMinUSD = material.quantity * costPerUnitMin;
                      totalCostMaxUSD = material.quantity * costPerUnitMax;
                    } else {
                      const lowestPriceInfo = getLowestPriceInfo(material.name);
                      const highestPriceInfo = getHighestPriceInfo(material.name);
                      if (lowestPriceInfo && normalizeUnit(lowestPriceInfo.baseUnit) === normalizeUnit(material.unit)) {
                          totalCostMinUSD = material.quantity * lowestPriceInfo.pricePerBaseUnit;
                      }
                      if (highestPriceInfo && normalizeUnit(highestPriceInfo.baseUnit) === normalizeUnit(material.unit)) {
                          totalCostMaxUSD = material.quantity * highestPriceInfo.pricePerBaseUnit;
                      }
                    }

                    return (
                      <TableRow key={`${material.name}-${material.unit}`}>
                        <TableCell className="font-medium">{material.name} {correspondingRecipe ? <span className="text-xs text-muted-foreground">(Preparación)</span> : ''}</TableCell>
                        <TableCell className="text-right">
                          <FormattedNumber value={material.quantity} decimalPlaces={4} />
                        </TableCell>
                        <TableCell>{material.unit}</TableCell>
                        <TableCell className="text-right">
                            {totalCostMinUSD !== null && totalCostMaxUSD !== null ? (
                            Math.abs(totalCostMinUSD - totalCostMaxUSD) < 0.01 ? (
                                <FormattedNumber value={totalCostMinUSD} prefix="$" />
                            ) : (
                                <span className="text-xs">
                                <FormattedNumber value={totalCostMinUSD} prefix="$" />
                                {' - '}
                                <FormattedNumber value={totalCostMaxUSD} prefix="$" />
                                </span>
                            )
                            ) : totalCostMinUSD !== null ? (
                            <>
                                <FormattedNumber value={totalCostMinUSD} prefix="$" />
                                <span className="text-xs text-muted-foreground"> (Mín)</span>
                            </>
                            ) : totalCostMaxUSD !== null ? (
                            <>
                                <FormattedNumber value={totalCostMaxUSD} prefix="$" />
                                <span className="text-xs text-muted-foreground"> (Máx)</span>
                            </>
                            ) : (
                            'N/A'
                            )}
                        </TableCell>
                        <TableCell className="text-right">
                            {totalCostMinUSD !== null && totalCostMaxUSD !== null ? (
                            Math.abs(totalCostMinUSD - totalCostMaxUSD) < 0.01 ? (
                                <FormattedNumber value={exchangeRate > 0 ? totalCostMinUSD * exchangeRate : undefined} prefix="Bs. " />
                            ) : (
                                <span className="text-xs">
                                    <FormattedNumber value={exchangeRate > 0 ? totalCostMinUSD * exchangeRate : undefined} prefix="Bs. " />
                                    {' - '}
                                    <FormattedNumber value={exchangeRate > 0 ? totalCostMaxUSD * exchangeRate : undefined} prefix="Bs. " />
                                </span>
                            )
                            ) : totalCostMinUSD !== null ? (
                            <>
                                <FormattedNumber value={exchangeRate > 0 ? totalCostMinUSD * exchangeRate : undefined} prefix="Bs. " />
                                <span className="text-xs text-muted-foreground"> (Mín)</span>
                            </>
                            ) : totalCostMaxUSD !== null ? (
                            <>
                                <FormattedNumber value={exchangeRate > 0 ? totalCostMaxUSD * exchangeRate : undefined} prefix="Bs. " />
                                <span className="text-xs text-muted-foreground"> (Máx)</span>
                            </>
                            ) : (
                            'N/A'
                            )}
                        </TableCell>
                        <TableCell className="text-right">
                          <Button variant="ghost" size="icon" onClick={() => handleOpenDeleteDialog(material)} disabled={isSubmitting} className="text-destructive hover:text-destructive-foreground hover:bg-destructive/10" title={`Eliminar ${material.name}`}>
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </TableCell>
                      </TableRow>
                    );
                  })
                ) : (
                  <TableRow><TableCell colSpan={6} className="text-center text-muted-foreground py-8">No hay materia prima registrada en el inventario de esta sede.</TableCell></TableRow>
                )}
              </TableBody>
            </Table>
          )}
        </CardContent>
      </Card>

      <Dialog open={isAdjustDialogOpen} onOpenChange={(isOpen) => { if (!isSubmitting) setIsAdjustDialogOpen(isOpen); }}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Ajuste Manual de Inventario</DialogTitle>
            <DialogDescription>Añade o resta cantidad a un ítem del inventario de materia prima para la sede: {activeBranchName}.</DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="space-y-1">
              <Label htmlFor="adjustment_type">Tipo de Ajuste</Label>
              <Select value={adjustmentType} onValueChange={(v) => setAdjustmentType(v as 'add' | 'subtract')} disabled={isSubmitting}>
                <SelectTrigger id="adjustment_type"><SelectValue/></SelectTrigger>
                <SelectContent>
                  <SelectItem value="add">Añadir al Stock</SelectItem>
                  <SelectItem value="subtract">Restar del Stock</SelectItem>
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-1">
              <Label htmlFor="material_to_adjust">Materia Prima</Label>
              <Select value={materialToAdjust} onValueChange={setMaterialToAdjust} disabled={isSubmitting || availableRawMaterials.length === 0}>
                <SelectTrigger id="material_to_adjust"><SelectValue placeholder="Selecciona material..."/></SelectTrigger>
                <SelectContent>
                  {availableRawMaterials.map(mat => <SelectItem key={mat} value={mat}>{mat}</SelectItem>)}
                </SelectContent>
              </Select>
            </div>
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-1">
                <Label htmlFor="adjustment_quantity">Cantidad</Label>
                <Input id="adjustment_quantity" type="number" value={adjustmentQuantity} onChange={(e) => setAdjustmentQuantity(e.target.value)} placeholder="ej., 5.5" disabled={isSubmitting}/>
              </div>
              <div className="space-y-1">
                <Label htmlFor="adjustment_unit">Unidad</Label>
                <Select value={adjustmentUnit} onValueChange={setAdjustmentUnit} disabled={isSubmitting}>
                  <SelectTrigger id="adjustment_unit"><SelectValue placeholder="Unidad"/></SelectTrigger>
                  <SelectContent>{commonUnitOptions.map(opt => <SelectItem key={opt} value={opt}>{opt}</SelectItem>)}</SelectContent>
                </Select>
              </div>
            </div>
             <div className="space-y-1">
                <Label htmlFor="adjustment_reason">Razón/Nota (Opcional)</Label>
                <Input id="adjustment_reason" value={adjustmentReason} onChange={(e) => setAdjustmentReason(e.target.value)} placeholder="ej., Compra local urgente" disabled={isSubmitting}/>
              </div>
          </div>
          <DialogFooter>
            <DialogClose asChild><Button variant="outline" disabled={isSubmitting}>Cancelar</Button></DialogClose>
            <Button type="button" onClick={handleSaveAdjustment} disabled={isSubmitting}>
              {isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin"/> : <PlusCircle className="mr-2 h-4 w-4" />}
              {isSubmitting ? "Guardando..." : "Guardar Ajuste"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      
      <Dialog open={isDeleteConfirmOpen} onOpenChange={(isOpen) => { if(!isSubmitting) setIsDeleteConfirmOpen(isOpen); }}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Confirmar Eliminación</DialogTitle>
            <DialogDescription>¿Estás seguro de que quieres eliminar "{itemToDelete?.name}" ({itemToDelete?.unit}) del inventario de materia prima de la sede actual? Esta acción no se puede deshacer.</DialogDescription>
          </DialogHeader>
          <DialogFooter className="sm:justify-end">
            <DialogClose asChild><Button variant="outline" onClick={() => {if(!isSubmitting){setIsDeleteConfirmOpen(false); setItemToDelete(null)}}} disabled={isSubmitting}>Cancelar</Button></DialogClose>
            <Button variant="destructive" onClick={handleConfirmDelete} disabled={isSubmitting}>
                {isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Trash2 className="mr-2 h-4 w-4" />}
                {isSubmitting ? "Eliminando..." : "Eliminar Ítem"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

    </div>
  );
}

// --- recipes ---



"use client";

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { PageHeader } from '@/components/page-header';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Checkbox } from "@/components/ui/checkbox";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogClose } from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Utensils, PlusCircle, MoreHorizontal, Edit, Trash2, Loader2, Info, TrendingUp, AlertTriangle, Trash } from 'lucide-react'; // Added Trash
import { useToast } from "@/hooks/use-toast";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';
import {
  type Product, // Importar Product
  recipesData as initialRecipesData,
  saveRecipesData,
  type Recipe,
  type RecipeIngredientItem, // Import new type
  loadExchangeRate,
  calculateDynamicRecipeCost,
  employeesData as initialEmployeesData,
  loadExpenseFixedCategories,
  type ExpenseFixedCategory,
  KEYS,
  productionLogData as initialProductionLogData,
  commonUnitOptions, // Import commonUnitOptions
  getCurrentRawMaterialOptions, // Import for ingredient name suggestions
  calculatePackagingCost,
  getActiveBranchId,
  availableBranches,
  loadProductsForBranch,
  saveProductsDataForBranch,
  loadFromLocalStorageForBranch
} from '@/lib/data-storage';
import { format, parseISO, startOfWeek, endOfWeek, isWithinInterval, isValid, compareDesc } from 'date-fns';
import { es } from 'date-fns/locale';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion";
import { FormattedNumber } from '@/components/ui/formatted-number';

const WEEKS_IN_MONTH = 365.25 / 12 / 7; // Aprox 4.348

export default function RecipesPage() {
  const { toast } = useToast();
  const [currentRecipes, setCurrentRecipes] = useState<Recipe[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [exchangeRate, setExchangeRate] = useState<number>(0);
  const [availableRawMaterials, setAvailableRawMaterials] = useState<string[]>([]);


  const [isAddRecipeDialogOpen, setIsAddRecipeDialogOpen] = useState(false);
  const [newRecipeName, setNewRecipeName] = useState('');
  const [newIngredients, setNewIngredients] = useState<RecipeIngredientItem[]>([{ id: `new-ing-${Date.now()}`, name: '', quantity: 0, unit: commonUnitOptions[0] || 'kg', notes: '' }]);
  const [newInstructions, setNewInstructions] = useState('');
  const [newCostPerUnit, setNewCostPerUnit] = useState('');
  const [newExpectedYield, setNewExpectedYield] = useState('');
  const [newIsIntermediate, setNewIsIntermediate] = useState(false);
  const [newOutputUnit, setNewOutputUnit] = useState<'kg' | 'L'>('kg');
  const [newRecipeCategory, setNewRecipeCategory] = useState('');
  const [newRecipeAiHint, setNewRecipeAiHint] = useState('');

  const [isEditRecipeDialogOpen, setIsEditRecipeDialogOpen] = useState(false);
  const [editingRecipe, setEditingRecipe] = useState<Recipe | null>(null);
  const [editRecipeName, setEditRecipeName] = useState('');
  const [editIngredients, setEditIngredients] = useState<RecipeIngredientItem[]>([]);
  const [editInstructions, setEditInstructions] = useState('');
  const [editCostPerUnit, setEditCostPerUnit] = useState('');
  const [editExpectedYield, setEditExpectedYield] = useState('');
  const [editIsIntermediate, setEditIsIntermediate] = useState(false);
  const [editOutputUnit, setEditOutputUnit] = useState<'kg' | 'L'>('kg');
  const [editRecipeCategory, setEditRecipeCategory] = useState('');
  const [editRecipeAiHint, setEditRecipeAiHint] = useState('');
  
  const [dynamicCostMinForEdit, setDynamicCostMinForEdit] = useState<number | null>(null);
  const [dynamicCostMaxForEdit, setDynamicCostMaxForEdit] = useState<number | null>(null);

  const [isDeleteConfirmDialogOpen, setIsDeleteConfirmDialogOpen] = useState(false);
  const [recipeToDeleteId, setRecipeToDeleteId] = useState<string | null>(null);

  const [weeklyOperatingCost, setWeeklyOperatingCost] = useState<number | null>(null);
  const [fixedWeeklyCost, setFixedWeeklyCost] = useState<number | null>(null);
  const [payrollWeeklyCost, setPayrollWeeklyCost] = useState<number | null>(null);
  
  const [sacksProducedThisWeek, setSacksProducedThisWeek] = useState<number>(0);
  const [costPerSackThisWeek, setCostPerSackThisWeek] = useState<number | null>(null);

  const [dataVersion, setDataVersion] = useState(0);


  const loadAndCalculateData = useCallback(() => {
    setIsLoading(true);
    const activeBranch = getActiveBranchId();
    if (!activeBranch) {
        // This case should be handled by the layout redirecting to /select-branch
        setIsLoading(false);
        return;
    }
    const loadedRecipes = [...loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, activeBranch)];
    setCurrentRecipes(loadedRecipes.sort((a,b) => a.name.localeCompare(b.name)));
    setAvailableRawMaterials(getCurrentRawMaterialOptions());
    const rate = loadExchangeRate();
    setExchangeRate(rate);

    // Calculate Operating Costs
    const fixedCategories = loadExpenseFixedCategories(activeBranch);
    const employees = [...loadFromLocalStorageForBranch<Employee[]>(KEYS.EMPLOYEES, activeBranch)];

    const currentFixedWeekly = fixedCategories
      .filter(cat => cat.name.toLowerCase() !== 'nómina' && cat.monthlyAmount && cat.monthlyAmount > 0)
      .reduce((sum, cat) => sum + (cat.monthlyAmount! / WEEKS_IN_MONTH), 0);
    setFixedWeeklyCost(currentFixedWeekly);

    const currentPayrollWeekly = employees.reduce((sum, emp) => sum + (emp.salary || 0), 0);
    setPayrollWeeklyCost(currentPayrollWeekly);
    
    const totalWeeklyOpCost = currentFixedWeekly + currentPayrollWeekly;
    setWeeklyOperatingCost(totalWeeklyOpCost);

    // Calculate Sacks Produced This Week (Only Final Products)
    const today = new Date();
    const startOfCurrentWeek = startOfWeek(today, { weekStartsOn: 1 });
    const endOfCurrentWeek = endOfWeek(today, { weekStartsOn: 1 });

    const productionThisWeek = loadFromLocalStorageForBranch<ProductionLogEntry[]>(KEYS.PRODUCTION_LOG, activeBranch).filter(log => {
        if (!log.date || !isValid(parseISO(log.date))) return false;
        const logDate = parseISO(log.date);
        return isWithinInterval(logDate, { start: startOfCurrentWeek, end: endOfCurrentWeek });
    });

    const totalSacksFinalProducts = productionThisWeek.reduce((sum, log) => {
        const recipeDetails = loadedRecipes.find(r => r.name === log.product);
        if (recipeDetails && !recipeDetails.isIntermediate) {
            return sum + (log.batchSizeMultiplier || 0);
        }
        return sum;
    }, 0);
    setSacksProducedThisWeek(totalSacksFinalProducts);

    // Calculate Cost Per Sack
    if (totalWeeklyOpCost >= 0) { // Ensure totalWeeklyOpCost is a valid number (incl. 0)
        if (totalSacksFinalProducts > 0) {
            setCostPerSackThisWeek(totalWeeklyOpCost / totalSacksFinalProducts);
        } else {
            setCostPerSackThisWeek(0); // If no production, operative cost per sack is 0 for distribution
        }
    } else {
        setCostPerSackThisWeek(null); // If totalWeeklyOpCost is null or negative, cannot determine
    }

    setIsLoading(false);
  }, []);


  useEffect(() => {
    loadAndCalculateData();

    const handleDataUpdate = (event: Event) => {
      const customEvent = event as CustomEvent;
      if (customEvent.detail?.key === KEYS.RECIPES || 
          customEvent.detail?.key === KEYS.EXPENSE_FIXED_CATEGORIES ||
          customEvent.detail?.key === KEYS.EMPLOYEES ||
          customEvent.detail?.key === KEYS.PRODUCTION_LOG ||
          customEvent.detail?.key === KEYS.RAW_MATERIAL_OPTIONS ||
          customEvent.detail?.key === KEYS.EXCHANGE_RATE ||
          customEvent.detail?.key === KEYS.ACTIVE_BRANCH_ID
          ) {
        setDataVersion(prev => prev + 1);
      }
    };
    window.addEventListener('data-updated', handleDataUpdate);
    return () => {
      window.removeEventListener('data-updated', handleDataUpdate);
    };
  }, [loadAndCalculateData]);

  useEffect(() => {
    if (dataVersion > 0) {
      loadAndCalculateData();
    }
  }, [dataVersion, loadAndCalculateData]);


  const resetAddForm = () => {
    setNewRecipeName(''); 
    setNewIngredients([{ id: `new-ing-${Date.now()}`, name: availableRawMaterials[0] || '', quantity: 0, unit: commonUnitOptions[0] || 'kg', notes: '' }]);
    setNewInstructions('');
    setNewCostPerUnit(''); setNewExpectedYield(''); setNewIsIntermediate(false);
    setNewOutputUnit('kg'); setNewRecipeCategory(''); setNewRecipeAiHint('');
  };

  const handleAddRecipe = () => {
    const isNonDispatchable = newRecipeName.toLowerCase().startsWith('no despachable');
    const validIngredients = newIngredients.filter(ing => ing.name.trim() && ing.quantity > 0 && ing.unit.trim());
    
    if (!newRecipeName || (validIngredients.length === 0 && !isNonDispatchable)) {
      toast({ title: "Error", description: "Nombre y al menos un ingrediente válido son obligatorios para recetas estándar.", variant: "destructive" });
      return;
    }
    
    let costNum = 0;
    if (!newIsIntermediate && !isNonDispatchable) {
        if (!newCostPerUnit) {
          toast({ title: "Error", description: "El Precio de Venta Unitario es obligatorio para productos finales.", variant: "destructive" }); return;
        }
        costNum = parseFloat(newCostPerUnit);
        if (isNaN(costNum) || costNum < 0) {
          toast({ title: "Error", description: "El Precio de Venta Unitario debe ser un número no negativo para productos finales.", variant: "destructive" }); return;
        }
    } else if (isNonDispatchable) {
        costNum = parseFloat(newCostPerUnit) || 0;
    }

    const expectedYieldNum = parseFloat(newExpectedYield);
    if (newExpectedYield.trim() === '' || isNaN(expectedYieldNum) || (expectedYieldNum < 0) || (expectedYieldNum <= 0 && !isNonDispatchable)) {
        toast({ title: "Error", description: "La 'Cantidad Producida Estimada' es obligatoria, debe ser un número no negativo, y positivo para recetas estándar.", variant: "destructive" }); return;
    }
    
    setIsSubmitting(true);
    const activeBranch = getActiveBranchId();
    if (!activeBranch) {
        toast({ title: "Error", description: "No hay una sede activa seleccionada.", variant: "destructive" });
        setIsSubmitting(false);
        return;
    }
    const branchName = availableBranches.find(b => b.id === activeBranch)?.name || 'Sede Desconocida';

    const finalCategory = isNonDispatchable ? 'No Despachable' : (newIsIntermediate ? 'Preparación Intermedia' : (newRecipeCategory.trim() || 'Producto Final'));
    
    // Create the original recipe
    const newRecipe: Recipe = {
      id: `REC${Date.now().toString().slice(-4)}${Math.floor(Math.random()*100)}`,
      name: newRecipeName, 
      ingredients: isNonDispatchable ? [] : validIngredients,
      instructions: newInstructions,
      costPerUnit: costNum, 
      expectedYield: expectedYieldNum,
      lastUpdated: new Date().toISOString().split('T')[0],
      isIntermediate: newIsIntermediate, 
      outputUnit: newIsIntermediate ? newOutputUnit : undefined,
      category: finalCategory, 
      aiHint: newRecipeAiHint || newRecipeName.toLowerCase().split(' ').slice(0,2).join(' ')
    };

    let recipesToSave = [newRecipe, ...currentRecipes];
    let toastDescription = "Receta añadida correctamente.";

    if (!newIsIntermediate && !isNonDispatchable) {
        const costIngMaxPerTanda = calculateDynamicRecipeCost(newRecipe.id, 'highest', recipesToSave);
        const costOpPerTanda = (costPerSackThisWeek !== null && costPerSackThisWeek >= 0) ? costPerSackThisWeek * 1.0 : 0;
        const packagingCost = calculatePackagingCost(newRecipe.expectedYield || 0);
        const totalCostMaxPerTanda = costIngMaxPerTanda + costOpPerTanda + packagingCost.maxCost;
        const productionCostPerUnit = (newRecipe.expectedYield && newRecipe.expectedYield > 0) ? totalCostMaxPerTanda / newRecipe.expectedYield : 0;

        const noDespachableName = `No despachable ${newRecipeName}`;
        const noDespachableRecipe: Recipe = {
            id: `REC${Date.now().toString().slice(-3)}${Math.floor(Math.random()*100)}`,
            name: noDespachableName,
            ingredients: [],
            instructions: `Receta para registrar devoluciones/pérdidas de "${newRecipeName}". El precio de venta aquí representa el costo de producción del original.`,
            costPerUnit: productionCostPerUnit,
            expectedYield: 0,
            lastUpdated: new Date().toISOString().split('T')[0],
            isIntermediate: false,
            category: 'No Despachable',
            aiHint: newRecipe.aiHint,
        };
        recipesToSave.push(noDespachableRecipe);

        let currentProducts = loadProductsForBranch(activeBranch);
        const productExists = currentProducts.some(p => p.name.toLowerCase() === noDespachableName.toLowerCase());
        if (!productExists) {
            const newProductEntry: Product = {
                id: noDespachableRecipe.id,
                name: noDespachableName,
                category: 'No Despachable',
                stock: 0,
                unitPrice: noDespachableRecipe.costPerUnit,
                lastUpdated: new Date().toISOString().split('T')[0],
                image: "https://placehold.co/40x40.png",
                aiHint: noDespachableRecipe.aiHint,
                sourceBranchId: activeBranch,
                sourceBranchName: branchName,
            };
            currentProducts.push(newProductEntry);
            saveProductsDataForBranch(activeBranch, currentProducts);
        }
        toastDescription += ` También se creó la contraparte "${noDespachableName}".`;
    }

    const updatedRecipes = recipesToSave.sort((a,b) => a.name.localeCompare(b.name));
    saveRecipesData(updatedRecipes); 
    toast({ title: "Éxito", description: toastDescription });
    setIsAddRecipeDialogOpen(false); 
    resetAddForm(); 
    setIsSubmitting(false);
  };


  const handleOpenEditDialog = (recipe: Recipe) => {
    setEditingRecipe(recipe);
    setEditRecipeName(recipe.name); 
    setEditIngredients(Array.isArray(recipe.ingredients) ? JSON.parse(JSON.stringify(recipe.ingredients)) : []);
    setEditInstructions(recipe.instructions || '');
    setEditCostPerUnit(recipe.costPerUnit.toString()); setEditExpectedYield(recipe.expectedYield?.toString() || '');
    const isInter = recipe.isIntermediate || false;
    setEditIsIntermediate(isInter); setEditOutputUnit(recipe.outputUnit || 'kg');
    setEditRecipeCategory(recipe.category || (isInter ? 'Preparación Intermedia' : 'Producto Final'));
    setEditRecipeAiHint(recipe.aiHint || '');

    const costIngMinPerTanda = calculateDynamicRecipeCost(recipe.id, 'lowest', currentRecipes);
    const costIngMaxPerTanda = calculateDynamicRecipeCost(recipe.id, 'highest', currentRecipes);
    
    let costTotalMin = costIngMinPerTanda;
    let costTotalMax = costIngMaxPerTanda;

    if (!isInter && !recipe.name.toLowerCase().startsWith('no despachable')) {
        if (costPerSackThisWeek !== null) {
            const costOpPerTanda = costPerSackThisWeek * (recipe.batchSizeMultiplier || 1); // Asumiendo batch size 1 si no está definido
            costTotalMin += costOpPerTanda;
            costTotalMax += costOpPerTanda;
        }
        const packagingCost = calculatePackagingCost(recipe.expectedYield || 0);
        costTotalMin += packagingCost.minCost;
        costTotalMax += packagingCost.maxCost;
    }

    setDynamicCostMinForEdit(costTotalMin);
    setDynamicCostMaxForEdit(costTotalMax);
    setIsEditRecipeDialogOpen(true);
  };

  const handleUpdateRecipe = () => {
    const isNonDispatchable = editRecipeName.toLowerCase().startsWith('no despachable');
    const validIngredients = editIngredients.filter(ing => ing.name.trim() && ing.quantity > 0 && ing.unit.trim());
    
    if (!editingRecipe || !editRecipeName || (validIngredients.length === 0 && !isNonDispatchable)) {
      toast({ title: "Error", description: "Nombre y al menos un ingrediente válido son obligatorios para recetas estándar.", variant: "destructive" }); return;
    }
    
    let costNum = 0;
    if (!editIsIntermediate && !isNonDispatchable) {
        if (!editCostPerUnit) {
          toast({ title: "Error", description: "El Precio de Venta Unitario es obligatorio para productos finales.", variant: "destructive" }); return;
        }
        costNum = parseFloat(editCostPerUnit);
        if (isNaN(costNum) || costNum < 0) {
          toast({ title: "Error", description: "El Precio de Venta Unitario debe ser un número no negativo para productos finales.", variant: "destructive" }); return;
        }
    } else if (isNonDispatchable) {
        costNum = parseFloat(editCostPerUnit) || 0;
    }

    const expectedYieldNum = parseFloat(editExpectedYield);
     if (editExpectedYield.trim() === '' || isNaN(expectedYieldNum) || (expectedYieldNum < 0) || (expectedYieldNum <= 0 && !isNonDispatchable)) {
        toast({ title: "Error", description: "La 'Cantidad Producida Estimada' es obligatoria, debe ser un número no negativo, y positivo para recetas estándar.", variant: "destructive" }); return;
    }
    
    setIsSubmitting(true);
    const finalCategory = isNonDispatchable ? 'No Despachable' : (editIsIntermediate ? 'Preparación Intermedia' : (editRecipeCategory.trim() || 'Producto Final'));
    const updatedRecipes = currentRecipes.map(r =>
      r.id === editingRecipe.id
      ? { ...r, name: editRecipeName, 
          ingredients: isNonDispatchable ? [] : validIngredients, 
          instructions: editInstructions,
          costPerUnit: costNum, expectedYield: expectedYieldNum, lastUpdated: new Date().toISOString().split('T')[0],
          isIntermediate: editIsIntermediate, outputUnit: editIsIntermediate ? editOutputUnit : undefined,
          category: finalCategory, aiHint: editRecipeAiHint || editRecipeName.toLowerCase().split(' ').slice(0,2).join(' '),
        } : r
    );
    
    // Al editar, NO se debe recalcular ni actualizar el 'no despachable' existente.
    // Su costo se fijó en el momento de la creación de la receta original.
    // Sin embargo, si el nombre de la receta original cambia, el 'no despachable' asociado debe actualizarse.
    const originalRecipe = currentRecipes.find(r => r.id === editingRecipe.id);
    if (originalRecipe && originalRecipe.name !== editRecipeName && !originalRecipe.isIntermediate && !originalRecipe.name.toLowerCase().startsWith('no despachable')) {
        const oldCounterpartName = `No despachable ${originalRecipe.name}`;
        const newCounterpartName = `No despachable ${editRecipeName}`;
        const counterpartRecipeIndex = updatedRecipes.findIndex(r => r.name === oldCounterpartName);
        if (counterpartRecipeIndex !== -1) {
            updatedRecipes[counterpartRecipeIndex].name = newCounterpartName;
            updatedRecipes[counterpartRecipeIndex].instructions = `Receta para registrar devoluciones/pérdidas de "${editRecipeName}". El precio de venta aquí representa el costo de producción del original.`;
            updatedRecipes[counterpartRecipeIndex].lastUpdated = new Date().toISOString().split('T')[0];

            const activeBranch = getActiveBranchId();
            if(activeBranch){
              let currentProducts = loadProductsForBranch(activeBranch);
              const productIndex = currentProducts.findIndex(p => p.name === oldCounterpartName);
              if (productIndex !== -1) {
                currentProducts[productIndex].name = newCounterpartName;
                saveProductsDataForBranch(activeBranch, currentProducts);
              }
            }
        }
    }


    const sortedRecipes = updatedRecipes.sort((a,b) => a.name.localeCompare(b.name));
    saveRecipesData(sortedRecipes); 
    toast({ title: "Éxito", description: "Receta actualizada correctamente." });
    setIsEditRecipeDialogOpen(false); setEditingRecipe(null);
    setDynamicCostMinForEdit(null); setDynamicCostMaxForEdit(null);
    setIsSubmitting(false);
  };

  const handleOpenDeleteDialog = (recipeId: string) => { setRecipeToDeleteId(recipeId); setIsDeleteConfirmDialogOpen(true); };
  
  const handleConfirmDelete = () => {
    if (!recipeToDeleteId) return;
    setIsSubmitting(true);
    
    let recipesToKeep = [...currentRecipes];
    const recipeToDelete = recipesToKeep.find(r => r.id === recipeToDeleteId);
    
    if (recipeToDelete) {
        // Filter out the main recipe
        recipesToKeep = recipesToKeep.filter(r => r.id !== recipeToDeleteId);
        
        // If it's a standard recipe, also look for and delete its counterpart
        if (!recipeToDelete.isIntermediate && !recipeToDelete.name.toLowerCase().startsWith('no despachable')) {
            const counterpartName = `No despachable ${recipeToDelete.name}`;
            recipesToKeep = recipesToKeep.filter(r => r.name.toLowerCase() !== counterpartName.toLowerCase());
        }
    }
    
    const updatedRecipes = recipesToKeep.sort((a,b) => a.name.localeCompare(b.name));
    saveRecipesData(updatedRecipes); 
    toast({ title: "Éxito", description: "Receta(s) eliminada(s) correctamente." });
    setIsDeleteConfirmDialogOpen(false); setRecipeToDeleteId(null); setIsSubmitting(false);
  };

  const handleIngredientChange = (
    index: number,
    field: keyof RecipeIngredientItem,
    value: string | number,
    formType: 'new' | 'edit'
  ) => {
    const list = formType === 'new' ? newIngredients : editIngredients;
    const setter = formType === 'new' ? setNewIngredients : setEditIngredients;
    
    const newList = list.map((item, i) => {
      if (i === index) {
        const updatedItem = { ...item, [field]: value };
        if (field === 'quantity' || field === 'unit') {
            // Potencialmente recalcular algo si fuera necesario, pero aquí solo actualizamos
        }
        return updatedItem;
      }
      return item;
    });
    setter(newList);
  };

  const addIngredientRow = (formType: 'new' | 'edit') => {
    const setter = formType === 'new' ? setNewIngredients : setEditIngredients;
    const newId = `${formType}-ing-${Date.now()}`;
    setter(prev => [...prev, { id: newId, name: availableRawMaterials[0] || '', quantity: 0, unit: commonUnitOptions[0] || 'kg', notes: '' }]);
  };

  const removeIngredientRow = (id: string, formType: 'new' | 'edit') => {
    const setter = formType === 'new' ? setNewIngredients : setEditIngredients;
    setter(prev => prev.filter(item => item.id !== id));
  };


  const renderDialogContent = () => {
    const isEditing = isEditRecipeDialogOpen;
    const recipeName = isEditing ? editRecipeName : newRecipeName;
    const setRecipeName = isEditing ? setEditRecipeName : setNewRecipeName;
    const ingredientsList = isEditing ? editIngredients : newIngredients;
    // setIngredientsList se maneja con handleIngredientChange, addIngredientRow, removeIngredientRow
    const instructions = isEditing ? editInstructions : newInstructions;
    const setInstructions = isEditing ? setEditInstructions : setNewInstructions;
    const costPerUnit = isEditing ? editCostPerUnit : newCostPerUnit;
    const setCostPerUnit = isEditing ? setEditCostPerUnit : setNewCostPerUnit;
    const expectedYield = isEditing ? editExpectedYield : newExpectedYield;
    const setExpectedYield = isEditing ? setEditExpectedYield : setNewExpectedYield;
    const isIntermediate = isEditing ? editIsIntermediate : newIsIntermediate;
    const setIsIntermediate = isEditing ? setEditIsIntermediate : setNewIsIntermediate;
    const outputUnit = isEditing ? editOutputUnit : newOutputUnit;
    const setOutputUnit = isEditing ? setEditOutputUnit : setNewOutputUnit;
    const category = isEditing ? editRecipeCategory : newRecipeCategory;
    const setCategory = isEditing ? setEditRecipeCategory : setNewRecipeCategory;
    const aiHint = isEditing ? editRecipeAiHint : newRecipeAiHint;
    const setAiHint = isEditing ? setEditRecipeAiHint : setNewRecipeAiHint;
    const isIntermediateModeDialog = isEditing ? editIsIntermediate : newIsIntermediate;
    const currentDynamicCostMin = isEditing ? dynamicCostMinForEdit : null;
    const currentDynamicCostMax = isEditing ? dynamicCostMaxForEdit : null;
    const formType = isEditing ? 'edit' : 'new';
    
    const isNonDispatchableModeDialog = recipeName.toLowerCase().startsWith('no despachable');

    return (
      <div className="grid gap-4 py-4">
        <div className="space-y-1"><Label htmlFor="recipe_name">Nombre de la Receta (Producto)</Label><Input id="recipe_name" value={recipeName} onChange={(e) => setRecipeName(e.target.value)} placeholder="ej., Catalina o No despachable Pan Quemado" disabled={isSubmitting}/></div>
        
        {!isNonDispatchableModeDialog && (
          <>
            <div className="space-y-2 border p-3 rounded-md">
                <Label className="font-medium">Ingredientes</Label>
                <p className="text-xs text-muted-foreground pb-1">Define los ingredientes para una producción base de <strong>1 saco</strong> (del ingrediente principal, ej. harina).</p>
                <div className="space-y-2 max-h-60 overflow-y-auto pr-2">
                    {ingredientsList.map((ing, index) => (
                        <div key={ing.id} className="grid grid-cols-12 gap-2 items-start border-b pb-2 mb-2 last:border-b-0 last:pb-0 last:mb-0">
                            <div className="col-span-12 sm:col-span-4 space-y-0.5">
                                {index === 0 && <Label htmlFor={`ing_name_${index}`} className="text-xs">Nombre</Label>}
                                <Select value={ing.name} onValueChange={(val) => handleIngredientChange(index, 'name', val, formType)} disabled={isSubmitting}>
                                    <SelectTrigger id={`ing_name_${index}`} className="h-8 text-xs"><SelectValue placeholder="Material" /></SelectTrigger>
                                    <SelectContent>{availableRawMaterials.map(opt => <SelectItem key={opt} value={opt}>{opt}</SelectItem>)}</SelectContent>
                                </Select>
                            </div>
                            <div className="col-span-4 sm:col-span-2 space-y-0.5">
                                {index === 0 && <Label htmlFor={`ing_qty_${index}`} className="text-xs">Cant.</Label>}
                                <Input id={`ing_qty_${index}`} type="number" value={ing.quantity} onChange={e => handleIngredientChange(index, 'quantity', parseFloat(e.target.value) || 0, formType)} className="h-8 text-xs" disabled={isSubmitting}/>
                            </div>
                            <div className="col-span-4 sm:col-span-2 space-y-0.5">
                                {index === 0 && <Label htmlFor={`ing_unit_${index}`} className="text-xs">Unidad</Label>}
                                <Select value={ing.unit} onValueChange={(val) => handleIngredientChange(index, 'unit', val, formType)} disabled={isSubmitting}>
                                    <SelectTrigger id={`ing_unit_${index}`} className="h-8 text-xs"><SelectValue placeholder="Unidad" /></SelectTrigger>
                                    <SelectContent>{commonUnitOptions.map(opt => <SelectItem key={opt} value={opt}>{opt}</SelectItem>)}</SelectContent>
                                </Select>
                            </div>
                            <div className="col-span-12 sm:col-span-3 space-y-0.5">
                                {index === 0 && <Label htmlFor={`ing_notes_${index}`} className="text-xs">Notas (Ingrediente)</Label>}
                                <Input id={`ing_notes_${index}`} value={ing.notes || ''} onChange={e => handleIngredientChange(index, 'notes', e.target.value, formType)} placeholder="Nota opcional" className="h-8 text-xs" disabled={isSubmitting}/>
                            </div>
                            <div className="col-span-4 sm:col-span-1 flex items-end justify-end">
                                <Button type="button" variant="ghost" size="icon" onClick={() => removeIngredientRow(ing.id, formType)} className="h-8 w-8 text-destructive hover:bg-destructive/10" disabled={isSubmitting}><Trash className="h-3.5 w-3.5"/></Button>
                            </div>
                        </div>
                    ))}
                </div>
                <Button type="button" variant="outline" size="sm" onClick={() => addIngredientRow(formType)} className="mt-2" disabled={isSubmitting}>
                    <PlusCircle className="mr-2 h-4 w-4" /> Añadir Ingrediente
                </Button>
            </div>

            <div className="space-y-1"><Label htmlFor="instructions">Instrucciones (Opcional)</Label><Textarea id="instructions" value={instructions} onChange={(e) => setInstructions(e.target.value)} placeholder="Instrucciones paso a paso..." rows={5} disabled={isSubmitting}/></div>
            <div className="flex items-center space-x-2 mt-2"><Checkbox id="is_intermediate" checked={isIntermediate} onCheckedChange={(checked) => { const isChecked = !!checked; setIsIntermediate(isChecked); if (isChecked) { setCategory('Preparación Intermedia'); setCostPerUnit('0'); } else { if (category === 'Preparación Intermedia') setCategory(isEditing && editingRecipe?.category !== 'Preparación Intermedia' ? editingRecipe?.category || '' : ''); }}} disabled={isSubmitting}/><Label htmlFor="is_intermediate" className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70">Es una preparación intermedia (ej. Melado)</Label></div>
          </>
        )}
        
        <div className="space-y-1 mt-2"><Label htmlFor="expected_yield">{isIntermediateModeDialog ? "Cantidad Estimada por Tanda Base (ej. 1 L, 1 kg)" : (isNonDispatchableModeDialog ? "Cantidad Producida (Ingresar 0)" : "Unidades Producidas por Tanda Base")}</Label><Input id="expected_yield" type="number" value={expectedYield} onChange={(e) => setExpectedYield(e.target.value)} placeholder={isNonDispatchableModeDialog ? "0" : (isIntermediateModeDialog ? "ej., 1" : "ej., 60")} disabled={isSubmitting}/><p className="text-xs text-muted-foreground pt-1">{isNonDispatchableModeDialog ? "Ingresa 0 para este tipo de ítem." : (isIntermediateModeDialog ? `Indica cuántas unidades de '${outputUnit.toUpperCase()}' produce la receta base.` : "Cuántas unidades del producto final se obtienen de la receta base.")}</p></div>
        
        {isIntermediateModeDialog && !isNonDispatchableModeDialog && (<div className="space-y-1 mt-2"><Label htmlFor="output_unit">Unidad de Salida del Intermedio</Label><Select value={outputUnit} onValueChange={(value) => setOutputUnit(value as 'kg' | 'L')} disabled={isSubmitting}><SelectTrigger id="output_unit"><SelectValue placeholder="Selecciona unidad" /></SelectTrigger><SelectContent><SelectItem value="kg">Kilogramos (kg)</SelectItem><SelectItem value="L">Litros (L)</SelectItem></SelectContent></Select></div>)}
        
        {!isIntermediateModeDialog && (<div className="space-y-1 mt-2"><Label htmlFor="cost_per_unit">Precio de Venta / Unidad (USD)</Label><Input id="cost_per_unit" type="number" value={costPerUnit} onChange={(e) => setCostPerUnit(e.target.value)} placeholder={isNonDispatchableModeDialog ? "ej., 0.50 (costo a reponer)" : "ej., 1.25"} disabled={isSubmitting}/>{costPerUnit && exchangeRate > 0 && <p className="text-xs text-muted-foreground pt-1"><FormattedNumber value={(parseFloat(costPerUnit) || 0) * exchangeRate} prefix="Bs. " /></p>}</div>)}
        
        {isEditing && (currentDynamicCostMin !== null || currentDynamicCostMax !== null) && !isNonDispatchableModeDialog && (
          <div className="mt-2 p-3 border rounded-md bg-muted/50 space-y-1">
            <Label className="font-medium text-sm">Costos Estimados Totales por Tanda (Ingr. + Oper. + Empaque):</Label>
            {Math.abs((currentDynamicCostMin || 0) - (currentDynamicCostMax || 0)) < 0.01 ? (
                <p className="text-sm">Costo: <span className="font-semibold text-primary"><FormattedNumber value={currentDynamicCostMin} prefix="$" /></span><span className="text-xs text-muted-foreground"> (<FormattedNumber value={(currentDynamicCostMin || 0) * exchangeRate} prefix="Bs. " />)</span></p>
            ) : (
                <>
                    <p className="text-sm">Mínimo: <span className="font-semibold text-primary"><FormattedNumber value={currentDynamicCostMin} prefix="$" /></span><span className="text-xs text-muted-foreground"> (<FormattedNumber value={(currentDynamicCostMin || 0) * exchangeRate} prefix="Bs. " />)</span></p>
                    <p className="text-sm">Máximo: <span className="font-semibold text-primary"><FormattedNumber value={currentDynamicCostMax} prefix="$" /></span><span className="text-xs text-muted-foreground"> (<FormattedNumber value={(currentDynamicCostMax || 0) * exchangeRate} prefix="Bs. " />)</span></p>
                </>
            )}
            <p className="text-xs text-muted-foreground mt-1">Para producir {expectedYield || 'N/A'} {isIntermediateModeDialog ? outputUnit.toUpperCase() : 'unidades'}.</p>
          </div>)}

         <div className="space-y-1 mt-2"><Label htmlFor="recipe_category">Categoría de la Receta/Producto (Opcional)</Label><Input id="recipe_category" value={isNonDispatchableModeDialog ? 'No Despachable' : (isIntermediateModeDialog ? 'Preparación Intermedia' : category)} onChange={(e) => setCategory(e.target.value)} placeholder={isIntermediateModeDialog ? "Preparación Intermedia" : "ej., Pan Dulce, Torta Fría"} disabled={isSubmitting || isIntermediateModeDialog || isNonDispatchableModeDialog} className={isIntermediateModeDialog || isNonDispatchableModeDialog ? "bg-muted/50" : ""}/>{(isIntermediateModeDialog || isNonDispatchableModeDialog) && <p className="text-xs text-muted-foreground pt-1">La categoría se establece automáticamente.</p>}</div>
         <div className="space-y-1 mt-2"><Label htmlFor="recipe_ai_hint">Palabras Clave para Imagen (Opcional)</Label><Input id="recipe_ai_hint" value={aiHint} onChange={(e) => setAiHint(e.target.value)} placeholder="ej., torta chocolate (max 2 palabras)" disabled={isSubmitting}/></div>
      </div>
    );
  };

  if (isLoading) {
    return (<div className="flex items-center justify-center min-h-[calc(100vh-10rem)]"><Loader2 className="h-12 w-12 animate-spin text-primary" /><p className="ml-4 text-lg">Cargando recetas...</p></div>);
  }

  return (
    <div className="space-y-6">
      <PageHeader title="Gestión de Recetas" description="Gestiona las recetas, define ingredientes, precios de venta y costos. El costo de ingredientes se calcula dinámicamente. La 'tanda' se refiere a la producción basada en 1 saco del ingrediente principal." icon={Utensils} actions={<Button onClick={() => { resetAddForm(); setIsAddRecipeDialogOpen(true); }} disabled={isSubmitting}><PlusCircle className="mr-2 h-4 w-4" />Añadir Nueva Receta</Button>}/>
      
      <Card className="shadow-lg">
        <CardHeader>
          <CardTitle>Gasto Operativo Semanal Estimado</CardTitle>
          <CardDescription>Suma de gastos fijos semanales (sin nómina, promediados del mensual) y nómina semanal total.</CardDescription>
        </CardHeader>
        <CardContent>
          {isLoading ? (
            <div className="flex items-center justify-center h-20"><Loader2 className="h-6 w-6 animate-spin text-primary" /><p className="ml-2">Calculando costos...</p></div>
          ) : weeklyOperatingCost !== null ? (
            <div>
              <div className="text-2xl font-bold text-primary">
                <FormattedNumber value={weeklyOperatingCost} prefix="$" />
                <span className="text-sm text-muted-foreground ml-2">
                    (<FormattedNumber value={(weeklyOperatingCost || 0) * exchangeRate} prefix="Bs. " />)
                </span>
              </div>
              <Accordion type="single" collapsible className="w-full mt-2 text-sm">
                <AccordionItem value="cost-breakdown-op-total">
                  <AccordionTrigger className="text-xs py-2">Ver Desglose del Cálculo</AccordionTrigger>
                  <AccordionContent className="text-xs space-y-1">
                    <p>Gastos Fijos Semanales Estimados (sin nómina): <FormattedNumber value={fixedWeeklyCost} prefix="$" /> (<FormattedNumber value={(fixedWeeklyCost || 0) * exchangeRate} prefix="Bs. " />)</p>
                    <p>Nómina Semanal Estimada: <FormattedNumber value={payrollWeeklyCost} prefix="$" /> (<FormattedNumber value={(payrollWeeklyCost || 0) * exchangeRate} prefix="Bs. " />)</p>
                    <p className="text-muted-foreground text-[0.65rem] pt-1">Nota: Los gastos fijos semanales se promedian de los montos mensuales (divididos por ~{WEEKS_IN_MONTH.toFixed(2)} semanas/mes).</p>
                  </AccordionContent>
                </AccordionItem>
              </Accordion>
            </div>
          ) : (
            <p className="text-muted-foreground">No se pudieron calcular los costos operativos. Revisa los datos de gastos fijos y empleados.</p>
          )}
        </CardContent>
      </Card>
      
      <Card className="shadow-lg">
        <CardHeader>
            <CardTitle>Costo Operativo por Saco Base (Semana Actual)</CardTitle>
            <CardDescription>Gasto operativo semanal total dividido por la cantidad de sacos base de productos finales producidos en la semana actual.</CardDescription>
        </CardHeader>
        <CardContent>
            {isLoading ? (
                 <div className="flex items-center justify-center h-20"><Loader2 className="h-6 w-6 animate-spin text-primary" /><p className="ml-2">Calculando...</p></div>
            ) : costPerSackThisWeek !== null && weeklyOperatingCost !== null && weeklyOperatingCost >= 0 ? (
                <div>
                    <div className="text-2xl font-bold text-primary">
                        <FormattedNumber value={costPerSackThisWeek} prefix="$" />
                        <span className="text-sm text-muted-foreground ml-2">
                           (<FormattedNumber value={(costPerSackThisWeek || 0) * exchangeRate} prefix="Bs. " />)
                        </span>
                    </div>
                    <Accordion type="single" collapsible className="w-full mt-2 text-sm">
                        <AccordionItem value="cost-per-sack-breakdown">
                        <AccordionTrigger className="text-xs py-2">Ver Desglose del Cálculo</AccordionTrigger>
                        <AccordionContent className="text-xs space-y-1">
                            <p>Gasto Operativo Semanal Total: <FormattedNumber value={weeklyOperatingCost} prefix="$" /> (<FormattedNumber value={(weeklyOperatingCost || 0) * exchangeRate} prefix="Bs. " />)</p>
                            <p>Sacos Base (Productos Finales) Producidos esta Semana: {sacksProducedThisWeek.toFixed(2)}</p>
                        </AccordionContent>
                        </AccordionItem>
                    </Accordion>
                </div>
            ) : (
                <p className="text-muted-foreground">
                    {weeklyOperatingCost === 0 ? "El gasto operativo semanal es cero. " : ""}
                    {sacksProducedThisWeek === 0 && weeklyOperatingCost !== null && weeklyOperatingCost >= 0 ? "No se han registrado sacos de productos finales esta semana para calcular el costo por saco." : 
                     (weeklyOperatingCost === null ? "No se pudieron calcular los costos operativos." : "")}
                </p>
            )}
        </CardContent>
      </Card>

      <Card className="shadow-lg">
        <CardHeader><CardTitle>Lista de Recetas</CardTitle><CardDescription>Todas las recetas de tu panadería. "Costo Total / Tanda" incluye ingredientes, operativos y empaque para productos finales.</CardDescription></CardHeader>
        <CardContent>
          <Table>
            <TableHeader><TableRow>
                <TableHead>Nombre</TableHead>
                <TableHead>Categoría</TableHead>
                <TableHead className="text-right">Costo Total / Tanda (USD)
                    <TooltipProvider><Tooltip><TooltipTrigger asChild><Button variant="ghost" size="icon" className="ml-1 h-4 w-4 p-0"><Info className="h-3 w-3 text-muted-foreground" /></Button></TooltipTrigger>
                    <TooltipContent className="max-w-xs"><p>Rango de costo de ingredientes (Mín - Máx) + operativos + empaque para la cantidad esperada de unidades.</p></TooltipContent></Tooltip></TooltipProvider>
                </TableHead>
                <TableHead className="text-right">Costo Total / Tanda (VES)</TableHead>
                <TableHead className="text-right">Costo Estimado / Unidad (USD)</TableHead>
                <TableHead className="text-right">Precio Venta / Unidad (USD)</TableHead>
                <TableHead className="text-right">Ingreso Venta / Tanda (USD)</TableHead>
                <TableHead className="text-right">Ganancia Estimada / Tanda (USD)</TableHead>
                <TableHead className="text-right">Ganancia Estimada / Unidad (USD)</TableHead>
                <TableHead>Últ. Act.</TableHead><TableHead className="text-right">Acciones</TableHead></TableRow>
            </TableHeader>
            <TableBody>
              {currentRecipes.map((recipe) => {
                const isNonDispatchable = recipe.name.toLowerCase().startsWith('no despachable');
                let costoTotalMinPorTanda = 0;
                let costoTotalMaxPorTanda = 0;
                let costoEstimadoPorUnidad = 0;
                let ingresoPorTanda = 0;
                let gananciaPorTanda = 0;
                let gananciaEstimadaPorUnidad = 0;

                if (!isNonDispatchable) {
                    const costIngMinPerTanda = calculateDynamicRecipeCost(recipe.id, 'lowest', currentRecipes);
                    const costIngMaxPerTanda = calculateDynamicRecipeCost(recipe.id, 'highest', currentRecipes);
                    costoTotalMinPorTanda = costIngMinPerTanda;
                    costoTotalMaxPorTanda = costIngMaxPerTanda;

                    if (!recipe.isIntermediate && costPerSackThisWeek !== null && costPerSackThisWeek >= 0) {
                        const costOpPerTanda = costPerSackThisWeek * (recipe.batchSizeMultiplier || 1); // Asumiendo batch size 1 si no está definido
                        costoTotalMinPorTanda += costOpPerTanda;
                        costoTotalMaxPorTanda += costOpPerTanda;
                    }

                    if (!recipe.isIntermediate) {
                        const packagingCost = calculatePackagingCost(recipe.expectedYield || 0);
                        costoTotalMinPorTanda += packagingCost.minCost;
                        costoTotalMaxPorTanda += packagingCost.maxCost;
                    }
                    
                    const yieldVal = recipe.expectedYield || 1;
                    costoEstimadoPorUnidad = yieldVal > 0 ? costoTotalMaxPorTanda / yieldVal : 0;
                    ingresoPorTanda = recipe.isIntermediate ? 0 : (recipe.costPerUnit * (recipe.expectedYield || 0));
                    gananciaPorTanda = recipe.isIntermediate ? 0 : ingresoPorTanda - costoTotalMaxPorTanda;
                    gananciaEstimadaPorUnidad = recipe.isIntermediate || yieldVal === 0 ? 0 : gananciaPorTanda / yieldVal;
                }

                return (
                  <TableRow key={recipe.id}>
                    <TableCell className="font-medium">{recipe.name}</TableCell>
                    <TableCell>{recipe.category || (recipe.isIntermediate ? "Preparación Intermedia" : "Producto Final")}</TableCell>
                    <TableCell className="text-right text-xs">
                        {isNonDispatchable ? '-' : Math.abs(costoTotalMinPorTanda - costoTotalMaxPorTanda) < 0.01 ? (
                            <>Costo: <FormattedNumber value={costoTotalMinPorTanda} prefix="$" /></>
                        ) : (
                            <>Min: <FormattedNumber value={costoTotalMinPorTanda} prefix="$" /> - Max: <FormattedNumber value={costoTotalMaxPorTanda} prefix="$" /></>
                        )}
                    </TableCell>
                    <TableCell className="text-right text-xs">
                        {isNonDispatchable ? '-' : Math.abs(costoTotalMinPorTanda - costoTotalMaxPorTanda) < 0.01 ? (
                            <>Costo: <FormattedNumber value={exchangeRate > 0 ? costoTotalMinPorTanda * exchangeRate : undefined} prefix="Bs. " /></>
                        ) : (
                            <>Min: <FormattedNumber value={exchangeRate > 0 ? costoTotalMinPorTanda * exchangeRate : undefined} prefix="Bs. " /> - Max: <FormattedNumber value={exchangeRate > 0 ? costoTotalMaxPorTanda * exchangeRate : undefined} prefix="Bs. " /></>
                        )}
                    </TableCell>
                    <TableCell className="text-right">{isNonDispatchable ? '-' : <FormattedNumber value={costoEstimadoPorUnidad} prefix="$" decimalPlaces={3} />}</TableCell>
                    <TableCell className="text-right">{recipe.isIntermediate ? '-' : <FormattedNumber value={recipe.costPerUnit} prefix="$" />}</TableCell>
                    <TableCell className="text-right">{isNonDispatchable || recipe.isIntermediate ? '-' : <FormattedNumber value={ingresoPorTanda} prefix="$" />}</TableCell>
                    <TableCell className="text-right">{isNonDispatchable || recipe.isIntermediate ? '-' : <FormattedNumber value={gananciaPorTanda} prefix="$" decimalPlaces={3} />}</TableCell>
                    <TableCell className="text-right">{isNonDispatchable || recipe.isIntermediate ? '-' : <FormattedNumber value={gananciaEstimadaPorUnidad} prefix="$" decimalPlaces={3} />}</TableCell>
                    <TableCell>{recipe.lastUpdated ? format(parseISO(recipe.lastUpdated), "dd/MM/yy", {locale: es}) : '-'}</TableCell>
                    <TableCell className="text-right"><DropdownMenu><DropdownMenuTrigger asChild><Button variant="ghost" size="icon" disabled={isSubmitting}><MoreHorizontal className="h-4 w-4" /></Button></DropdownMenuTrigger><DropdownMenuContent align="end"><DropdownMenuItem onClick={() => handleOpenEditDialog(recipe)} disabled={isSubmitting}><Edit className="mr-2 h-4 w-4" />Editar</DropdownMenuItem><DropdownMenuItem onClick={() => handleOpenDeleteDialog(recipe.id)} className="text-destructive focus:text-destructive-foreground focus:bg-destructive" disabled={isSubmitting}><Trash2 className="mr-2 h-4 w-4" />Eliminar</DropdownMenuItem></DropdownMenuContent></DropdownMenu></TableCell>
                  </TableRow>);
              })}
            </TableBody>
          </Table>
           {currentRecipes.length === 0 && !isLoading && (<p className="text-center text-muted-foreground py-8">No hay recetas registradas.</p>)}
        </CardContent>
      </Card>
      <Dialog open={isAddRecipeDialogOpen || isEditRecipeDialogOpen} onOpenChange={(isOpen) => { if (isSubmitting) return; if (isEditRecipeDialogOpen) { if (!isOpen) { setEditingRecipe(null); setEditIsIntermediate(false); setEditOutputUnit('kg'); setEditRecipeCategory(''); setEditRecipeAiHint(''); setDynamicCostMinForEdit(null); setDynamicCostMaxForEdit(null); } setIsEditRecipeDialogOpen(isOpen); } else { if (!isOpen) resetAddForm(); setIsAddRecipeDialogOpen(isOpen); }}}>
        <DialogContent className="sm:max-w-2xl max-h-[85vh]"><DialogHeader><DialogTitle>{isEditRecipeDialogOpen ? "Editar Receta" : "Añadir Nueva Receta"}</DialogTitle><DialogDescription>{isEditRecipeDialogOpen ? "Actualiza los detalles de la receta." : (<>Define los ingredientes e instrucciones. <br/> Los ingredientes deben ser para una producción base de <strong>1 saco</strong> (del ingrediente principal, ej. harina).</>)}</DialogDescription></DialogHeader><ScrollArea className="max-h-[calc(70vh-100px)] p-1 pr-3">{renderDialogContent()}</ScrollArea>
          <DialogFooter className="pt-4 border-t"><DialogClose asChild><Button variant="outline" onClick={() => { if (isSubmitting) return; if (isEditRecipeDialogOpen) { setIsEditRecipeDialogOpen(false); setEditingRecipe(null); setDynamicCostMinForEdit(null); setDynamicCostMaxForEdit(null); } else { setIsAddRecipeDialogOpen(false); resetAddForm(); }}} disabled={isSubmitting}>Cancelar</Button></DialogClose><Button type="button" onClick={isEditRecipeDialogOpen ? handleUpdateRecipe : handleAddRecipe} disabled={isSubmitting}>{isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : (isEditRecipeDialogOpen ? <Edit className="mr-2 h-4 w-4" /> : <PlusCircle className="mr-2 h-4 w-4" />)}{isSubmitting ? "Guardando..." : (isEditRecipeDialogOpen ? "Guardar Cambios" : "Guardar Receta")}</Button></DialogFooter>
        </DialogContent>
      </Dialog>
       <Dialog open={isDeleteConfirmDialogOpen} onOpenChange={(isOpen) => { if (!isSubmitting) setIsDeleteConfirmDialogOpen(isOpen); }}><DialogContent className="sm:max-w-md"><DialogHeader><DialogTitle>Confirmar Eliminación</DialogTitle><DialogDescription>¿Estás seguro de que quieres eliminar esta receta? Esta acción no se puede deshacer.</DialogDescription></DialogHeader><DialogFooter className="sm:justify-end"><DialogClose asChild><Button variant="outline" onClick={() => {if (!isSubmitting) {setIsDeleteConfirmDialogOpen(false); setRecipeToDeleteId(null);}}} disabled={isSubmitting}>Cancelar</Button></DialogClose><Button variant="destructive" onClick={handleConfirmDelete} disabled={isSubmitting}>{isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Trash2 className="mr-2 h-4 w-4" />}{isSubmitting ? 'Eliminando...' : 'Eliminar Receta'}</Button></DialogFooter></DialogContent></Dialog>
    </div>
  );
}

// --- reports ---



"use client";

import React, { useState, useEffect, useMemo } from 'react';
import { PageHeader } from '@/components/page-header';
import { Card, CardContent, CardDescription, CardHeader, CardTitle, CardFooter } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { FileText, Download, CalendarDays, Package, Calendar as CalendarIcon, DollarSign, Archive, Layers, BarChart2 as BarChartIconLucide, PieChart as PieChartIconLucide, Loader2, Shuffle, TrendingDown, Combine, Building, Eye, TrendingUp as TrendingUpIcon } from 'lucide-react'; 
import { useToast } from "@/hooks/use-toast";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter as UiDialogFooter, DialogClose } from '@/components/ui/dialog'; 
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Calendar } from "@/components/ui/calendar";
import type { DateRange } from "react-day-picker";
import { format, parseISO, isWithinInterval, startOfDay, endOfDay, isValid, differenceInCalendarWeeks, startOfWeek, endOfWeek } from "date-fns";
import { es } from "date-fns/locale";
import { cn } from "@/lib/utils";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  salesData as initialSalesDataGlobal,
  type Sale,
  type Expense,
  type Product,
  loadExchangeRate,
  type PurchaseOrder,
  type RawMaterialInventoryItem,
  type Recipe,
  calculateDynamicRecipeCost,
  type Employee,
  loadExpenseFixedCategories,
  type ExpenseFixedCategory,
  WEEKS_IN_MONTH,
  getActiveBranchId,
  availableBranches,
  loadFromLocalStorageForBranch,
  loadExpenseVariableCategories,
  KEYS,
  calculatePackagingCost,
  weeklyLossReportsData as initialWeeklyLossReportsData,
  type WeeklyLossReport,
  weeklyProfitReportsData as initialWeeklyProfitReportsData,
  type WeeklyProfitReport
} from '@/lib/data-storage';
import jsPDF from 'jspdf';
import 'jspdf-autotable';
import {
  Bar,
  BarChart,
  Pie,
  PieChart,
  Cell,
  CartesianGrid,
  XAxis,
  YAxis,
  Tooltip as RechartsTooltip,
  Legend as RechartsLegend,
  ResponsiveContainer
} from "recharts";
import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { ScrollArea } from '@/components/ui/scroll-area';
import { FormattedNumber } from '@/components/ui/formatted-number';


interface jsPDFWithAutoTable extends jsPDF {
  autoTable: (options: any) => jsPDFWithAutoTable;
}

interface ProductSalesQuantityData { name: string; quantity: number; }
interface ProductChangeData { name: string; quantity: number; }
interface ExpenseChartData { category: string; total: number; fill: string; }
interface StockChartData { name: string; stock: number; }
interface PurchaseOrderChartData { supplierName: string; totalCost: number; }

interface ProductWastageData {
  name: string;
  totalExpected: number;
  totalActual: number;
  totalWastageQuantity: number;
  totalWastageCostUSD: number;
  baseUnitPriceForWastage?: number;
}

interface ProductLossItem {
  name: string;
  quantityChanged: number;
  costChangedUSD: number;
  quantityWasted: number;
  costWastedUSD: number;
  quantitySampled: number;
  costSampledUSD: number;
  totalQuantityLost: number;
  totalCostLostUSD: number;
}


const PIE_CHART_COLORS = [
  "hsl(var(--chart-1))", "hsl(var(--chart-2))", "hsl(var(--chart-3))",
  "hsl(var(--chart-4))", "hsl(var(--chart-5))",
  "hsl(var(--primary))", "hsl(var(--accent))", "hsl(var(--secondary))"
];
const TOP_N_PRODUCTS_REPORTS = 10;
const TOP_N_CHANGES_REPORTS = 10;
const TOP_N_WASTAGE_PRODUCTS_REPORTS = 10;
const TOP_N_LOSSES_REPORTS = 10;


export default function ReportsPage() {
  const { toast } = useToast();
  const [isDateRangeDialogOpen, setIsDateRangeDialogOpen] = useState(false);
  const [selectedDateRange, setSelectedDateRange] = React.useState<DateRange | undefined>(undefined);
  const [exchangeRate, setExchangeRate] = useState<number>(0);
  const [isLoading, setIsLoading] = useState(true);
  const [activeBranchName, setActiveBranchName] = useState<string>('');
  const [activeBranchIdState, setActiveBranchIdState] = useState<string | null>(null);

  const [weeklyLossReports, setWeeklyLossReports] = useState<WeeklyLossReport[]>([]);
  const [isLossReportDialogOpen, setIsLossReportDialogOpen] = useState(false);
  const [selectedLossReport, setSelectedLossReport] = useState<WeeklyLossReport | null>(null);

  const [weeklyProfitReports, setWeeklyProfitReports] = useState<WeeklyProfitReport[]>([]);
  const [isProfitReportDialogOpen, setIsProfitReportDialogOpen] = useState(false);
  const [selectedProfitReport, setSelectedProfitReport] = useState<WeeklyProfitReport | null>(null);


  useEffect(() => {
    setExchangeRate(loadExchangeRate());
    const currentBranchId = getActiveBranchId();
    setActiveBranchIdState(currentBranchId);
    const branch = availableBranches.find(b => b.id === currentBranchId);
    setActiveBranchName(branch ? branch.name : 'Desconocida');
    setWeeklyLossReports(initialWeeklyLossReportsData);
    setWeeklyProfitReports(initialWeeklyProfitReportsData);
    setIsLoading(false);

    const handleDataUpdate = (event: Event) => {
        const customEvent = event as CustomEvent;
        if (customEvent.detail?.key === KEYS.WEEKLY_LOSS_REPORTS) {
            setWeeklyLossReports([...initialWeeklyLossReportsData]);
        }
        if (customEvent.detail?.key === KEYS.WEEKLY_PROFIT_REPORTS) {
            setWeeklyProfitReports([...initialWeeklyProfitReportsData]);
        }
    };
    window.addEventListener('data-updated', handleDataUpdate);
    return () => {
        window.removeEventListener('data-updated', handleDataUpdate);
    };
  }, []);

  const formatVesPrice = (usdPrice: number): string => {
    if (exchangeRate > 0 && usdPrice) {
      return `Bs. ${(usdPrice * exchangeRate).toFixed(2)}`;
    }
    return "Bs. --";
  };

  const getReportFilename = (baseName: string): string => {
    const today = format(new Date(), "yyyy-MM-dd");
    let branchSuffix = '';
    const currentBranchId = getActiveBranchId();
    if (baseName.includes("gastos") || baseName.includes("stock") || baseName.includes("materia_prima") || baseName.includes("ordenes_compra") || baseName.includes("merma") || baseName.includes("perdidas")) {
        if (currentBranchId) branchSuffix = `_${currentBranchId}`;
    }

    if (selectedDateRange?.from) {
      const from = format(selectedDateRange.from, "yyyy-MM-dd");
      if (selectedDateRange.to) {
        const to = format(selectedDateRange.to, "yyyy-MM-dd");
        return `${baseName}${branchSuffix}_${from}_a_${to}.pdf`;
      }
      return `${baseName}${branchSuffix}_${from}.pdf`;
    }
    return `${baseName}${branchSuffix}_general_${today}.pdf`;
  };

  const productSalesQuantityChartData = useMemo(() => {
    let filteredSales = initialSalesDataGlobal;
    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      filteredSales = initialSalesDataGlobal.filter(sale => {
        const saleDate = parseISO(sale.date);
        return isValid(saleDate) && isWithinInterval(saleDate, { start: from, end: to });
      });
    }

    const productSales: { [productName: string]: number } = {};
    filteredSales.forEach(sale => {
      sale.itemsPerBranch.forEach(branchDetail => {
        branchDetail.items.forEach(item => {
          if (item.productName) {
            productSales[item.productName] = (productSales[item.productName] || 0) + item.quantity;
          }
        });
      });
    });

    return Object.entries(productSales)
      .map(([name, quantity]) => ({ name, quantity }))
      .sort((a, b) => b.quantity - a.quantity)
      .slice(0, TOP_N_PRODUCTS_REPORTS);
  }, [selectedDateRange]);

  const productSalesQuantityChartConfig = {
    quantity: { label: "Cantidad Vendida", color: "hsl(var(--chart-1))" },
  } satisfies ChartConfig;

  const productChangesChartData = useMemo(() => {
    let filteredSales = initialSalesDataGlobal;
    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      filteredSales = initialSalesDataGlobal.filter(sale => {
        const saleDate = parseISO(sale.date);
        return isValid(saleDate) && isWithinInterval(saleDate, { start: from, end: to });
      });
    }

    const productChanges: { [productName: string]: number } = {};
    filteredSales.forEach(sale => {
      if (sale.changes) {
        sale.changes.forEach(item => {
          if (item.productName) {
            productChanges[item.productName] = (productChanges[item.productName] || 0) + item.quantity;
          }
        });
      }
    });

    return Object.entries(productChanges)
      .map(([name, quantity]) => ({ name, quantity }))
      .sort((a, b) => b.quantity - a.quantity)
      .slice(0, TOP_N_CHANGES_REPORTS);
  }, [selectedDateRange]);

  const productChangesChartConfig = {
    quantity: { label: "Cantidad Cambiada/Devuelta", color: "hsl(var(--chart-5))" },
  } satisfies ChartConfig;

  const expensesChartData = useMemo(() => {
    if (!activeBranchIdState) return [];
    let branchExpenses = loadFromLocalStorageForBranch<Expense[]>(KEYS.EXPENSES, activeBranchIdState);
    let filteredExpenses = branchExpenses;

    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      filteredExpenses = branchExpenses.filter(expense => {
        const expenseDate = parseISO(expense.date);
        return isValid(expenseDate) && isWithinInterval(expenseDate, { start: from, end: to });
      });
    }
    const expensesByCategory: { [category: string]: number } = {};
    const fixedCats = loadExpenseFixedCategories(activeBranchIdState);
    const varCats = loadExpenseVariableCategories(activeBranchIdState);
    const allBranchCategories = [...fixedCats.map(fc => fc.name), ...varCats];

    allBranchCategories.forEach(cat => expensesByCategory[cat] = 0);

    filteredExpenses.forEach(expense => {
      if (expensesByCategory.hasOwnProperty(expense.category)) {
        expensesByCategory[expense.category] = (expensesByCategory[expense.category] || 0) + expense.amount;
      } else if (expense.category === 'Compra de Materia Prima') {
        expensesByCategory[expense.category] = (expensesByCategory[expense.category] || 0) + expense.amount;
      }
    });

    return Object.entries(expensesByCategory)
      .filter(([_, total]) => total > 0)
      .map(([category, total], index) => ({
        category,
        total: parseFloat(total.toFixed(2)),
        fill: PIE_CHART_COLORS[index % PIE_CHART_COLORS.length],
      }));
  }, [selectedDateRange, activeBranchIdState]);

  const expensesChartConfig = useMemo(() =>
    expensesChartData.reduce((acc, item) => {
      acc[item.category] = { label: item.category, color: item.fill };
      return acc;
    }, {} as ChartConfig)
  , [expensesChartData]);

  const productStockChartData = useMemo(() => {
    if (!activeBranchIdState) return [];
    const productsForBranch = loadFromLocalStorageForBranch<Product[]>(KEYS.PRODUCTS, activeBranchIdState);
    return productsForBranch
        .filter(p => p.stock > 0)
        .sort((a,b) => b.stock - a.stock)
        .slice(0, 10)
        .map(product => ({
            name: product.name,
            stock: product.stock,
        }));
  }, [activeBranchIdState]);

  const productStockChartConfig = {
    stock: { label: "Stock", color: "hsl(var(--chart-2))" },
  } satisfies ChartConfig;

  const rawMaterialStockChartData = useMemo(() => {
    if (!activeBranchIdState) return [];
    const rawMaterialsForBranch = loadFromLocalStorageForBranch<RawMaterialInventoryItem[]>(KEYS.RAW_MATERIAL_INVENTORY, activeBranchIdState);
    return rawMaterialsForBranch
        .filter(m => m.quantity > 0)
        .sort((a,b) => b.quantity - a.quantity)
        .slice(0, 10)
        .map(material => ({
            name: `${material.name} (${material.unit})`,
            stock: parseFloat(material.quantity.toFixed(2)),
        }));
  }, [activeBranchIdState]);

  const rawMaterialStockChartConfig = {
    stock: { label: "Cantidad", color: "hsl(var(--chart-3))" },
  } satisfies ChartConfig;

  const purchaseOrdersChartData = useMemo(() => {
    if (!activeBranchIdState) return [];
    const ordersForBranch = loadFromLocalStorageForBranch<PurchaseOrder[]>(KEYS.PURCHASE_ORDERS, activeBranchIdState);
    let filteredOrders = ordersForBranch;
    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      filteredOrders = ordersForBranch.filter(po => {
        const orderDate = parseISO(po.orderDate);
        return isValid(orderDate) && isWithinInterval(orderDate, { start: from, end: to });
      });
    }
    const ordersBySupplier: { [supplierName: string]: number } = {};
    filteredOrders.forEach(order => {
        if (order.status === 'Pagado') {
             ordersBySupplier[order.supplierName] = (ordersBySupplier[order.supplierName] || 0) + order.totalCost;
        }
    });
    return Object.entries(ordersBySupplier)
      .map(([supplierName, totalCost]) => ({
        supplierName,
        totalCost: parseFloat(totalCost.toFixed(2)),
      }))
      .sort((a,b) => b.totalCost - a.totalCost)
      .slice(0,10);
  }, [selectedDateRange, activeBranchIdState]);

  const purchaseOrdersChartConfig = {
    totalCost: { label: "Costo Total (USD)", color: "hsl(var(--chart-4))" },
  } satisfies ChartConfig;

  const wastageReportFullData = useMemo(() => {
    if (!activeBranchIdState) return [];
    const productionLogsForBranch = loadFromLocalStorageForBranch<ProductionLogEntry[]>(KEYS.PRODUCTION_LOG, activeBranchIdState);
    const recipesForBranch = loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, activeBranchIdState);

    let filteredLogs = productionLogsForBranch;
    let reportRangeStart = selectedDateRange?.from ? startOfDay(selectedDateRange.from) : null;
    let reportRangeEnd = selectedDateRange?.to ? endOfDay(selectedDateRange.to) : (selectedDateRange?.from ? endOfDay(selectedDateRange.from) : null);

    if (reportRangeStart && reportRangeEnd) {
        filteredLogs = productionLogsForBranch.filter(log => {
            const logDate = parseISO(log.date);
            return isValid(logDate) && isWithinInterval(logDate, { start: reportRangeStart!, end: reportRangeEnd! });
        });
    }

    let fixedWeeklyCostForPeriod = 0;
    let payrollWeeklyCostForPeriod = 0;
    let numberOfWeeksInPeriod = 1;

    const fixedCategories: ExpenseFixedCategory[] = loadExpenseFixedCategories(activeBranchIdState);
    const employees: Employee[] = loadFromLocalStorageForBranch<Employee[]>(KEYS.EMPLOYEES, activeBranchIdState);

    fixedWeeklyCostForPeriod = fixedCategories
      .filter(cat => cat.name.toLowerCase() !== 'nómina' && cat.monthlyAmount && cat.monthlyAmount > 0)
      .reduce((sum, cat) => sum + (cat.monthlyAmount! / WEEKS_IN_MONTH), 0);

    payrollWeeklyCostForPeriod = employees.reduce((sum, emp) => sum + (emp.salary || 0), 0);

    if (reportRangeStart && reportRangeEnd) {
      numberOfWeeksInPeriod = differenceInCalendarWeeks(reportRangeEnd, reportRangeStart, { weekStartsOn: 1 }) + 1;
      if (numberOfWeeksInPeriod <= 0) numberOfWeeksInPeriod = 1;
    }
    const totalOperatingCostForPeriod = (fixedWeeklyCostForPeriod + payrollWeeklyCostForPeriod) * numberOfWeeksInPeriod;


    const totalSacksProducedInPeriod = filteredLogs.reduce((sum, log) => {
      const recipeDetails = recipesForBranch.find(r => r.name === log.product);
      if (recipeDetails && !recipeDetails.isIntermediate) {
        return sum + (log.batchSizeMultiplier || 0);
      }
      return sum;
    }, 0);

    const costPerSackForPeriod = totalSacksProducedInPeriod > 0 && totalOperatingCostForPeriod >=0 ? totalOperatingCostForPeriod / totalSacksProducedInPeriod : 0;

    const productWastageMap: { [productName: string]: ProductWastageData; } = {};
    filteredLogs.forEach(log => {
        const recipe = recipesForBranch.find(r => r.name === log.product);
        if (recipe && !recipe.isIntermediate) {
            const wastageQuantityInThisLog = log.expectedQuantity - log.actualQuantity;
            if (wastageQuantityInThisLog > 0) {
                const costoIngredientesPorTanda = calculateDynamicRecipeCost(recipe.id, 'highest', recipesForBranch);
                const costoIngredientesPorUnidad = (recipe.expectedYield && recipe.expectedYield > 0) ? costoIngredientesPorTanda / recipe.expectedYield : 0;
                
                let costoOperativoPorUnidad = 0;
                if (recipe.expectedYield && recipe.expectedYield > 0 && costPerSackForPeriod >= 0) {
                    costoOperativoPorUnidad = costPerSackForPeriod / recipe.expectedYield;
                }
                const costoTotalPorUnidadParaMerma = costoIngredientesPorUnidad + costoOperativoPorUnidad;
                const wastageCostInThisLog = wastageQuantityInThisLog * costoTotalPorUnidadParaMerma;

                if (!productWastageMap[log.product]) {
                    productWastageMap[log.product] = {
                        name: log.product, totalExpected: 0, totalActual: 0,
                        totalWastageQuantity: 0, totalWastageCostUSD: 0,
                        baseUnitPriceForWastage: costoTotalPorUnidadParaMerma
                    };
                }
                productWastageMap[log.product].totalExpected += log.expectedQuantity;
                productWastageMap[log.product].totalActual += log.actualQuantity;
                productWastageMap[log.product].totalWastageQuantity += wastageQuantityInThisLog;
                productWastageMap[log.product].totalWastageCostUSD += wastageCostInThisLog;
                if (productWastageMap[log.product].baseUnitPriceForWastage === undefined) {
                     productWastageMap[log.product].baseUnitPriceForWastage = costoTotalPorUnidadParaMerma;
                 }
            }
        }
    });

    return Object.values(productWastageMap)
        .sort((a, b) => b.totalWastageCostUSD - a.totalWastageCostUSD);
  }, [selectedDateRange, activeBranchIdState]);

  const productWastageChartData = useMemo(() => {
    return wastageReportFullData.slice(0, TOP_N_WASTAGE_PRODUCTS_REPORTS).map(item => ({
        name: item.name,
        wastageCostUSD: parseFloat(item.totalWastageCostUSD.toFixed(2)),
        wastageQuantity: item.totalWastageQuantity
    }));
  }, [wastageReportFullData]);

  const productWastageChartConfig = {
    wastageCostUSD: { label: "Costo Merma (USD)", color: "hsl(var(--destructive))" },
    wastageQuantity: { label: "Cantidad Mermada", color: "hsl(var(--chart-2))" }
  } satisfies ChartConfig;

  const productLossesData = useMemo(() => {
    const lossesMap: { [productName: string]: ProductLossItem } = {};
    let filteredSales = initialSalesDataGlobal;
    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      filteredSales = initialSalesDataGlobal.filter(sale => {
        const saleDate = parseISO(sale.date);
        return isValid(saleDate) && isWithinInterval(saleDate, { start: from, end: to });
      });
    }

    if (!activeBranchIdState) return [];
    const recipesForBranch = loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, activeBranchIdState);
    const productionLogsForBranch = loadFromLocalStorageForBranch<ProductionLogEntry[]>(KEYS.PRODUCTION_LOG, activeBranchIdState);

    let fixedWeeklyCostForPeriod = 0;
    let payrollWeeklyCostForPeriod = 0;
    let numberOfWeeksInPeriod = 1;
    const fixedCategories: ExpenseFixedCategory[] = loadExpenseFixedCategories(activeBranchIdState);
    const employees: Employee[] = loadFromLocalStorageForBranch<Employee[]>(KEYS.EMPLOYEES, activeBranchIdState);
    fixedWeeklyCostForPeriod = fixedCategories
      .filter(cat => cat.name.toLowerCase() !== 'nómina' && cat.monthlyAmount && cat.monthlyAmount > 0)
      .reduce((sum, cat) => sum + (cat.monthlyAmount! / WEEKS_IN_MONTH), 0);
    payrollWeeklyCostForPeriod = employees.reduce((sum, emp) => sum + (emp.salary || 0), 0);
    if (selectedDateRange?.from && selectedDateRange.to) {
      numberOfWeeksInPeriod = differenceInCalendarWeeks(selectedDateRange.to, selectedDateRange.from, { weekStartsOn: 1 }) + 1;
      if (numberOfWeeksInPeriod <= 0) numberOfWeeksInPeriod = 1;
    }
    const totalOperatingCostForPeriod = (fixedWeeklyCostForPeriod + payrollWeeklyCostForPeriod) * numberOfWeeksInPeriod;
    const totalSacksProducedInPeriod = productionLogsForBranch
      .filter(log => {
        if (!selectedDateRange?.from || !selectedDateRange.to) return true;
        const logDate = parseISO(log.date);
        return isValid(logDate) && isWithinInterval(logDate, { start: startOfDay(selectedDateRange.from), end: endOfDay(selectedDateRange.to) });
      })
      .reduce((sum, log) => {
        const recipeDetails = recipesForBranch.find(r => r.name === log.product);
        if (recipeDetails && !recipeDetails.isIntermediate) return sum + (log.batchSizeMultiplier || 0);
        return sum;
      }, 0);
    const costPerSackForPeriod = totalSacksProducedInPeriod > 0 && totalOperatingCostForPeriod >=0 ? totalOperatingCostForPeriod / totalSacksProducedInPeriod : 0;


    filteredSales.forEach(sale => {
      if (sale.changes) {
        sale.changes.forEach(item => {
          if (item.productName && item.sourceBranchId === activeBranchIdState) {
            if (!lossesMap[item.productName]) {
              lossesMap[item.productName] = { name: item.productName, quantityChanged: 0, costChangedUSD: 0, quantityWasted: 0, costWastedUSD: 0, quantitySampled: 0, costSampledUSD: 0, totalQuantityLost: 0, totalCostLostUSD: 0 };
            }
            lossesMap[item.productName].quantityChanged += item.quantity;
            const recipe = recipesForBranch.find(r => r.name === item.productName);
            if (recipe && recipe.name.toLowerCase().startsWith('no despachable')) {
              const lossCostPerUnit = recipe.costPerUnit || 0;
              lossesMap[item.productName].costChangedUSD += item.quantity * lossCostPerUnit;
            }
          }
        });
      }
      if (sale.samples) {
        sale.samples.forEach(sample => {
          if (sample.productName && sample.sourceBranchId === activeBranchIdState) {
            if (!lossesMap[sample.productName]) {
              lossesMap[sample.productName] = { name: sample.productName, quantityChanged: 0, costChangedUSD: 0, quantityWasted: 0, costWastedUSD: 0, quantitySampled: 0, costSampledUSD: 0, totalQuantityLost: 0, totalCostLostUSD: 0 };
            }
            lossesMap[sample.productName].quantitySampled += sample.quantity;
            const recipe = recipesForBranch.find(r => r.name === sample.productName);
            if (recipe) {
                const costOfIngredientsPerTanda = calculateDynamicRecipeCost(recipe.id, 'highest', recipesForBranch);
                const costOfIngredientsPerUnit = (recipe.expectedYield && recipe.expectedYield > 0) ? costOfIngredientsPerTanda / recipe.expectedYield : 0;
                const operatingCostPerUnit = (recipe.expectedYield && recipe.expectedYield > 0 && costPerSackForPeriod >= 0) ? costPerSackForPeriod / recipe.expectedYield : 0;
                const packagingCostPerUnit = calculatePackagingCost(1).maxCost;
                const totalCostPerUnitSampled = costOfIngredientsPerUnit + operatingCostPerUnit + packagingCostPerUnit;
                lossesMap[sample.productName].costSampledUSD += sample.quantity * totalCostPerUnitSampled;
            }
          }
        });
      }
    });

    wastageReportFullData.forEach(wastageItem => {
      if (!lossesMap[wastageItem.name]) {
        lossesMap[wastageItem.name] = { name: wastageItem.name, quantityChanged: 0, costChangedUSD: 0, quantityWasted: 0, costWastedUSD: 0, quantitySampled: 0, costSampledUSD: 0, totalQuantityLost: 0, totalCostLostUSD: 0 };
      }
      lossesMap[wastageItem.name].quantityWasted += wastageItem.totalWastageQuantity;
      lossesMap[wastageItem.name].costWastedUSD += wastageItem.totalWastageCostUSD;
    });

    return Object.values(lossesMap).map(item => ({
      ...item,
      totalQuantityLost: item.quantityChanged + item.quantityWasted + item.quantitySampled,
      totalCostLostUSD: item.costChangedUSD + item.costWastedUSD + item.costSampledUSD,
    }))
    .sort((a, b) => b.totalCostLostUSD - a.totalCostLostUSD)
    .slice(0, TOP_N_LOSSES_REPORTS);

  }, [selectedDateRange, wastageReportFullData, activeBranchIdState]);

  const productLossesChartConfig = {
    totalQuantityLost: { label: "Cantidad Perdida", color: "hsl(var(--chart-2))" },
    totalCostLostUSD: { label: "Costo Pérdida (USD)", color: "hsl(var(--destructive))" },
  } satisfies ChartConfig;


  const handleDownloadSalesReport = () => {
    let filteredSales = initialSalesDataGlobal;
    let reportPeriod = "General";

    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      filteredSales = initialSalesDataGlobal.filter(sale => {
        const saleDate = parseISO(sale.date);
        return isValid(saleDate) && isWithinInterval(saleDate, { start: from, end: to });
      });
      reportPeriod = `${format(from, "dd/MM/yyyy", { locale: es })}${selectedDateRange.to ? ` - ${format(to, "dd/MM/yyyy", { locale: es })}` : ''}`;
    }

    if (filteredSales.length === 0) {
      toast({ title: "Sin Datos", description: "No hay ventas para el período seleccionado.", variant: "default" });
      return;
    }

    const doc = new jsPDF() as jsPDFWithAutoTable;
    doc.setFontSize(18);
    doc.text("Panificadora Valladares", 14, 22);
    doc.setFontSize(12);
    doc.text("Reporte de Ventas (Global)", 14, 30);
    doc.setFontSize(10);
    doc.text(`Período: ${reportPeriod}`, 14, 38);
    doc.text(`Tasa de Cambio (USD/VES): ${exchangeRate > 0 ? exchangeRate.toFixed(2) : 'No establecida'}`, 14, 44);

    const head = [["ID Venta", "Fecha", "Cliente", "Total (USD)", "Total (VES)", "Método Pago", "Estado"]];
    const body = filteredSales.map(sale => [
      sale.id,
      format(parseISO(sale.date), "dd/MM/yyyy", { locale: es }),
      sale.customerName || 'N/A',
      `$${sale.totalAmount.toFixed(2)}`,
      formatVesPrice(sale.totalAmount),
      sale.paymentMethod,
      sale.status
    ]);

    doc.autoTable({
      startY: 52, head: head, body: body, theme: 'striped', headStyles: { fillColor: [224, 122, 95], fontSize: 10 }, bodyStyles: { fontSize: 9 },
    });

    doc.save(getReportFilename("reporte_ventas_global"));
    toast({
      title: "Reporte de Ventas Generado",
      description: `Se generó un PDF con ${filteredSales.length} registros de ventas.`,
      duration: 5000,
    });
  };

  const handleDownloadProductChangesReport = () => {
    let filteredSales = initialSalesDataGlobal;
    let reportPeriod = "General";

    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      filteredSales = initialSalesDataGlobal.filter(sale => {
        const saleDate = parseISO(sale.date);
        return isValid(saleDate) && isWithinInterval(saleDate, { start: from, end: to });
      });
      reportPeriod = `${format(from, "dd/MM/yyyy", { locale: es })}${selectedDateRange.to ? ` - ${format(to, "dd/MM/yyyy", { locale: es })}` : ''}`;
    }

    const productChangesAggregated: { name: string; quantity: number; costUSD: number }[] = [];
    const productChangesMap: { [productName: string]: { quantity: number; costUSD: number } } = {};

    const activeBranchRecipes = activeBranchIdState ? loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, activeBranchIdState) : [];

    filteredSales.forEach(sale => {
      if (sale.changes) {
        sale.changes.forEach(item => {
          if (item.productName) {
            if (!productChangesMap[item.productName]) {
              productChangesMap[item.productName] = { quantity: 0, costUSD: 0 };
            }
            productChangesMap[item.productName].quantity += item.quantity;
            const recipe = activeBranchRecipes.find(r => r.name === item.productName);
            if (recipe && recipe.name.toLowerCase().startsWith('no despachable')) {
              const lossCostPerUnit = recipe.costPerUnit || 0;
              productChangesMap[item.productName].costUSD += item.quantity * lossCostPerUnit;
            }
          }
        });
      }
    });

    for (const name in productChangesMap) {
        productChangesAggregated.push({ name, quantity: productChangesMap[name].quantity, costUSD: productChangesMap[name].costUSD });
    }
    const productChangesList = productChangesAggregated.sort((a, b) => b.costUSD - a.costUSD);

    if (productChangesList.length === 0) {
      toast({ title: "Sin Datos", description: "No hay cambios/devoluciones de productos para el período seleccionado.", variant: "default" });
      return;
    }

    const doc = new jsPDF() as jsPDFWithAutoTable;
    doc.setFontSize(18);
    doc.text("Panificadora Valladares", 14, 22);
    doc.setFontSize(12);
    doc.text("Reporte de Cambios/Devoluciones de Productos (Global)", 14, 30);
    doc.setFontSize(10);
    doc.text(`Período: ${reportPeriod}`, 14, 38);
    doc.text(`Tasa de Cambio (USD/VES): ${exchangeRate > 0 ? exchangeRate.toFixed(2) : 'No establecida'}`, 14, 44);
    doc.text(`Nota: El costo se basa en el costo de "No despachable" (recetas sede: ${activeBranchName}).`, 14, 50);

    const head = [["Producto", "Cantidad Cambiada/Devuelta", "Costo Total Cambio (USD)", "Costo Total Cambio (VES)"]];
    const body = productChangesList.map(item => [
      item.name,
      item.quantity,
      `$${item.costUSD.toFixed(2)}`,
      formatVesPrice(item.costUSD)
    ]);
    const totalQuantity = productChangesList.reduce((sum, item) => sum + item.quantity, 0);
    const totalCost = productChangesList.reduce((sum, item) => sum + item.costUSD, 0);
    body.push([
        { content: "TOTALES", styles: { fontStyle: 'bold', halign: 'right' } },
        { content: totalQuantity, styles: { fontStyle: 'bold' } },
        { content: `$${totalCost.toFixed(2)}`, styles: { fontStyle: 'bold' } },
        { content: formatVesPrice(totalCost), styles: { fontStyle: 'bold' } },
    ]);

    doc.autoTable({
      startY: 58, head: head, body: body, theme: 'striped', headStyles: { fillColor: [224, 122, 95], fontSize: 10 }, bodyStyles: { fontSize: 9 },
    });
    doc.save(getReportFilename("reporte_cambios_productos_global"));
    toast({ title: "Reporte de Cambios Generado", description: `Se generó un PDF con ${productChangesList.length} productos cambiados/devueltos.`, duration: 5000, });
  };

  const handleDownloadExpenseReport = () => {
    if (!activeBranchIdState) {
      toast({ title: "Error de Sede", description: "Selecciona una sede activa primero.", variant: "destructive" });
      return;
    }
    let branchExpenses = loadFromLocalStorageForBranch<Expense[]>(KEYS.EXPENSES, activeBranchIdState);
    let filteredExpenses = branchExpenses;
    let reportPeriod = "General";

    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      filteredExpenses = branchExpenses.filter(expense => {
        const expenseDate = parseISO(expense.date);
        return isValid(expenseDate) && isWithinInterval(expenseDate, { start: from, end: to });
      });
      reportPeriod = `${format(from, "dd/MM/yyyy", { locale: es })}${selectedDateRange.to ? ` - ${format(to, "dd/MM/yyyy", { locale: es })}` : ''}`;
    }

    if (filteredExpenses.length === 0) {
      toast({ title: "Sin Datos", description: `No hay gastos para el período y sede ${activeBranchName}.`, variant: "default" });
      return;
    }

    const doc = new jsPDF() as jsPDFWithAutoTable;
    doc.setFontSize(18);
    doc.text("Panificadora Valladares", 14, 22);
    doc.setFontSize(12);
    doc.text(`Reporte de Gastos (Sede: ${activeBranchName})`, 14, 30);
    doc.setFontSize(10);
    doc.text(`Período: ${reportPeriod}`, 14, 38);
    doc.text(`Tasa de Cambio (USD/VES): ${exchangeRate > 0 ? exchangeRate.toFixed(2) : 'No establecida'}`, 14, 44);

    const head = [["ID Gasto", "Fecha", "Categoría", "Descripción", "Monto (USD)", "Monto (VES)", "Pagado A"]];
    const body = filteredExpenses.map(expense => [
      expense.id,
      format(parseISO(expense.date), "dd/MM/yyyy", { locale: es }),
      expense.category,
      expense.description,
      `$${expense.amount.toFixed(2)}`,
      formatVesPrice(expense.amount),
      expense.paidTo
    ]);

    doc.autoTable({
      startY: 52, head: head, body: body, theme: 'striped', headStyles: { fillColor: [224, 122, 95], fontSize: 10 }, bodyStyles: { fontSize: 9 },
    });
    doc.save(getReportFilename("reporte_gastos"));
    toast({ title: "Reporte de Gastos Generado", description: `Se generó un PDF con ${filteredExpenses.length} registros de gastos de la sede ${activeBranchName}.`, duration: 5000, });
  };

  const handleDownloadInventoryReport = () => {
    if (!activeBranchIdState) {
      toast({ title: "Error de Sede", description: "Selecciona una sede activa primero.", variant: "destructive" });
      return;
    }
    const productsForReport = loadFromLocalStorageForBranch<Product[]>(KEYS.PRODUCTS, activeBranchIdState);
    if (productsForReport.length === 0) {
      toast({ title: "Sin Datos", description: `No hay productos en el stock de producción de la sede ${activeBranchName}.`, variant: "default" });
      return;
    }
    const doc = new jsPDF() as jsPDFWithAutoTable;
    doc.setFontSize(18);
    doc.text("Panificadora Valladares", 14, 22);
    doc.setFontSize(12);
    doc.text(`Reporte de Stock de Producción (Sede: ${activeBranchName})`, 14, 30);
    doc.setFontSize(10);
    doc.text(`Fecha del Reporte: ${format(new Date(), "dd/MM/yyyy HH:mm", { locale: es })}`, 14, 38);
    doc.text(`Tasa de Cambio (USD/VES): ${exchangeRate > 0 ? exchangeRate.toFixed(2) : 'No establecida'}`, 14, 44);

    const head = [["ID Producto", "Nombre", "Categoría", "Stock", "P.Unit(USD)", "P.Unit(VES)", "Últ. Actualización"]];
    const body = productsForReport.map(product => [
      product.id, product.name, product.category, product.stock,
      `$${product.unitPrice.toFixed(2)}`, formatVesPrice(product.unitPrice),
      product.lastUpdated ? format(parseISO(product.lastUpdated), "dd/MM/yyyy", { locale: es }) : '-'
    ]);

    doc.autoTable({
      startY: 52, head: head, body: body, theme: 'striped', headStyles: { fillColor: [224, 122, 95], fontSize: 10 }, bodyStyles: { fontSize: 9 },
    });
    doc.save(getReportFilename("reporte_stock_produccion"));
    toast({ title: "Reporte de Stock de Producción Generado", description: `Se generó un PDF con ${productsForReport.length} productos de la sede ${activeBranchName}.`, duration: 5000, });
  };

  const handleDownloadRawMaterialInventoryReport = () => {
    if (!activeBranchIdState) {
      toast({ title: "Error de Sede", description: "Selecciona una sede activa primero.", variant: "destructive" });
      return;
    }
    const rawMaterialsForReport = loadFromLocalStorageForBranch<RawMaterialInventoryItem[]>(KEYS.RAW_MATERIAL_INVENTORY, activeBranchIdState);
    if (rawMaterialsForReport.length === 0) {
      toast({ title: "Sin Datos", description: `No hay materia prima en el inventario de la sede ${activeBranchName}.`, variant: "default" });
      return;
    }
    const doc = new jsPDF() as jsPDFWithAutoTable;
    doc.setFontSize(18);
    doc.text("Panificadora Valladares", 14, 22);
    doc.setFontSize(12);
    doc.text(`Reporte de Inventario de Materia Prima (Sede: ${activeBranchName})`, 14, 30);
    doc.setFontSize(10);
    doc.text(`Fecha del Reporte: ${format(new Date(), "dd/MM/yyyy HH:mm", { locale: es })}`, 14, 38);

    const head = [["Ingrediente", "Cantidad Total", "Unidad (Base)"]];
    const body = rawMaterialsForReport.map(material => [
      material.name, material.quantity.toFixed(3), material.unit
    ]);

    doc.autoTable({
      startY: 46, head: head, body: body, theme: 'striped', headStyles: { fillColor: [224, 122, 95], fontSize: 10 }, bodyStyles: { fontSize: 9 },
    });
    doc.save(getReportFilename("reporte_materia_prima"));
    toast({ title: "Reporte de Materia Prima Generado", description: `Se generó un PDF con ${rawMaterialsForReport.length} ítems de la sede ${activeBranchName}.`, duration: 5000, });
  };

  const handleDownloadPurchaseOrdersReport = () => {
    if (!activeBranchIdState) {
      toast({ title: "Error de Sede", description: "Selecciona una sede activa primero.", variant: "destructive" });
      return;
    }
    const ordersForBranch = loadFromLocalStorageForBranch<PurchaseOrder[]>(KEYS.PURCHASE_ORDERS, activeBranchIdState);
    let filteredOrders = ordersForBranch;
    let reportPeriod = "General";

    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      filteredOrders = ordersForBranch.filter(po => {
        const orderDate = parseISO(po.orderDate);
        return isValid(orderDate) && isWithinInterval(orderDate, { start: from, end: to });
      });
      reportPeriod = `${format(from, "dd/MM/yyyy", { locale: es })}${selectedDateRange.to ? ` - ${format(to, "dd/MM/yyyy", { locale: es })}` : ''}`;
    }

    if (filteredOrders.length === 0) {
      toast({ title: "Sin Datos", description: `No hay órdenes de compra para el período y sede ${activeBranchName}.`, variant: "default" });
      return;
    }

    const doc = new jsPDF("landscape") as jsPDFWithAutoTable;
    doc.setFontSize(18);
    doc.text("Panificadora Valladares", 14, 20);
    doc.setFontSize(12);
    doc.text(`Reporte de Órdenes de Compra (Sede: ${activeBranchName})`, 14, 28);
    doc.setFontSize(10);
    doc.text(`Período: ${reportPeriod}`, 14, 36);
    doc.text(`Tasa de Cambio (USD/VES): ${exchangeRate > 0 ? exchangeRate.toFixed(2) : 'No establecida'}`, 14, 42);

    const head = [["ID OC", "Proveedor", "Fecha Pedido", "Entrega Esperada", "Artículos (Resumen)", "Costo Total (USD)", "Costo Total (VES)", "Estado"]];
    const body = filteredOrders.map(po => [
      po.id, po.supplierName, format(parseISO(po.orderDate), "dd/MM/yyyy", { locale: es }),
      format(parseISO(po.expectedDelivery), "dd/MM/yyyy", { locale: es }),
      po.items.map(item => `${item.rawMaterialName} (${item.quantity} ${item.unit})`).join('; '),
      `$${po.totalCost.toFixed(2)}`, formatVesPrice(po.totalCost), po.status
    ]);

    doc.autoTable({
      startY: 50, head: head, body: body, theme: 'striped', headStyles: { fillColor: [224, 122, 95], fontSize: 10 }, bodyStyles: { fontSize: 9 },
      columnStyles: { 4: { cellWidth: 'auto' } }
    });
    doc.save(getReportFilename("reporte_ordenes_compra"));
    toast({ title: "Reporte de Órdenes de Compra Generado", description: `Se generó un PDF con ${filteredOrders.length} órdenes de la sede ${activeBranchName}.`, duration: 5000, });
  };

  const handleDownloadWastageReport = () => {
    if (wastageReportFullData.length === 0) {
      toast({ title: "Sin Datos", description: `No hay datos de merma para el período y sede ${activeBranchName}.`, variant: "default" });
      return;
    }
    let reportPeriod = "General";
    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      reportPeriod = `${format(from, "dd/MM/yyyy", { locale: es })}${selectedDateRange.to ? ` - ${format(to, "dd/MM/yyyy", { locale: es })}` : ''}`;
    }

    const doc = new jsPDF("landscape") as jsPDFWithAutoTable;
    doc.setFontSize(18);
    doc.text("Panificadora Valladares", 14, 20);
    doc.setFontSize(12);
    doc.text(`Reporte de Merma de Producción (Sede: ${activeBranchName})`, 14, 28);
    doc.setFontSize(10);
    doc.text(`Período: ${reportPeriod}`, 14, 36);
    doc.text(`Tasa de Cambio (USD/VES): ${exchangeRate > 0 ? exchangeRate.toFixed(2) : 'No establecida'}`, 14, 42);
    doc.text("Nota: Costo de merma incluye costo de ingredientes y operativos (basados en sede actual).", 14, 48);

    const head = [["Producto", "Esperado", "Real", "Mermado", "Costo Unit. Merma (USD)", "Costo Merma (USD)", "Costo Merma (VES)"]];
    const body = wastageReportFullData.map(item => [
      item.name, item.totalExpected, item.totalActual, item.totalWastageQuantity,
      `$${(item.baseUnitPriceForWastage || 0).toFixed(2)}`, `$${item.totalWastageCostUSD.toFixed(2)}`, formatVesPrice(item.totalWastageCostUSD)
    ]);
    const totalWastageQty = wastageReportFullData.reduce((sum, item) => sum + item.totalWastageQuantity, 0);
    const totalWastageCost = wastageReportFullData.reduce((sum, item) => sum + item.totalWastageCostUSD, 0);
    body.push([
        { content: "TOTALES", colSpan: 3, styles: { fontStyle: 'bold', halign: 'right' } },
        { content: totalWastageQty, styles: { fontStyle: 'bold' } },
        { content: "", styles: { fontStyle: 'bold' } }, // Empty for unit cost
        { content: `$${totalWastageCost.toFixed(2)}`, styles: { fontStyle: 'bold' } },
        { content: formatVesPrice(totalWastageCost), styles: { fontStyle: 'bold' } },
    ]);

    doc.autoTable({
      startY: 56, head: head, body: body, theme: 'striped', headStyles: { fillColor: [224, 122, 95], fontSize: 10 }, bodyStyles: { fontSize: 9 },
    });
    doc.save(getReportFilename("reporte_merma_produccion"));
    toast({ title: "Reporte de Merma Generado", description: `Se generó un PDF para la sede ${activeBranchName}.`, duration: 5000, });
  };

  const handleDownloadLossesReport = () => {
    if (productLossesData.length === 0 && wastageReportFullData.length === 0 && productChangesChartData.length === 0) {
      toast({ title: "Sin Datos", description: "No hay datos de pérdidas (merma, cambios o muestras) para el período y sede actual.", variant: "default" });
      return;
    }
    let reportPeriod = "General";
    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      reportPeriod = `${format(from, "dd/MM/yyyy", { locale: es })}${selectedDateRange.to ? ` - ${format(to, "dd/MM/yyyy", { locale: es })}` : ''}`;
    }

    const doc = new jsPDF("landscape") as jsPDFWithAutoTable;
    doc.setFontSize(18);
    doc.text("Panificadora Valladares", 14, 20);
    doc.setFontSize(12);
    doc.text(`Reporte de Pérdidas Totales (Sede: ${activeBranchName})`, 14, 28);
    doc.setFontSize(10);
    doc.text(`Período: ${reportPeriod}`, 14, 36);
    doc.text(`Tasa de Cambio (USD/VES): ${exchangeRate > 0 ? exchangeRate.toFixed(2) : 'No establecida'}`, 14, 42);
    doc.text("Nota: Costo cambios/muestras/merma basados en costos de la sede actual.", 14, 48);

    const head = [["Producto", "Cant. Cambiada", "Costo Cambios (USD)", "Cant. Mermada", "Costo Merma (USD)", "Cant. Muestras", "Costo Muestras (USD)", "Cant. Total Perdida", "Costo Total Pérdida (USD)"]];
    const body = productLossesData.map(item => [
      item.name, item.quantityChanged, `$${item.costChangedUSD.toFixed(2)}`,
      item.quantityWasted, `$${item.costWastedUSD.toFixed(2)}`,
      item.quantitySampled, `$${item.costSampledUSD.toFixed(2)}`,
      item.totalQuantityLost, `$${item.totalCostLostUSD.toFixed(2)}`,
    ]);
    const totalQuantityChanged = productLossesData.reduce((sum, item) => sum + item.quantityChanged, 0);
    const totalCostChanged = productLossesData.reduce((sum, item) => sum + item.costChangedUSD, 0);
    const totalQuantityWasted = productLossesData.reduce((sum, item) => sum + item.quantityWasted, 0);
    const totalCostWasted = productLossesData.reduce((sum, item) => sum + item.costWastedUSD, 0);
    const totalQuantitySampled = productLossesData.reduce((sum, item) => sum + item.quantitySampled, 0);
    const totalCostSampled = productLossesData.reduce((sum, item) => sum + item.costSampledUSD, 0);
    const grandTotalQuantityLost = productLossesData.reduce((sum, item) => sum + item.totalQuantityLost, 0);
    const grandTotalCostLost = productLossesData.reduce((sum, item) => sum + item.totalCostLostUSD, 0);

    body.push([
        { content: "TOTALES", styles: { fontStyle: 'bold', halign: 'right' } },
        { content: totalQuantityChanged, styles: { fontStyle: 'bold' } },
        { content: `$${totalCostChanged.toFixed(2)}`, styles: { fontStyle: 'bold' } },
        { content: totalQuantityWasted, styles: { fontStyle: 'bold' } },
        { content: `$${totalCostWasted.toFixed(2)}`, styles: { fontStyle: 'bold' } },
        { content: totalQuantitySampled, styles: { fontStyle: 'bold' } },
        { content: `$${totalCostSampled.toFixed(2)}`, styles: { fontStyle: 'bold' } },
        { content: grandTotalQuantityLost, styles: { fontStyle: 'bold' } },
        { content: `$${grandTotalCostLost.toFixed(2)}`, styles: { fontStyle: 'bold' } },
    ]);

    doc.autoTable({
      startY: 56, head: head, body: body, theme: 'striped', headStyles: { fillColor: [224, 122, 95], fontSize: 10 }, bodyStyles: { fontSize: 9 },
    });
    doc.save(getReportFilename("reporte_perdidas_totales"));
    toast({ title: "Reporte de Pérdidas Generado", description: `Se generó un PDF con el resumen de pérdidas de la sede ${activeBranchName}.`, duration: 5000, });
  };
  
  const handleDownloadDetailedLossReportPDF = (report: WeeklyLossReport) => {
    const doc = new jsPDF("landscape") as jsPDFWithAutoTable;
    doc.setFontSize(18);
    doc.text("Panificadora Valladares", 14, 20);
    doc.setFontSize(12);
    doc.text(`Reporte Detallado de Pérdidas Semanales`, 14, 28);
    doc.setFontSize(10);
    doc.text(`Semana del: ${format(parseISO(report.weekStartDate), "dd/MM/yyyy", { locale: es })} al ${format(parseISO(report.weekEndDate), "dd/MM/yyyy", { locale: es })}`, 14, 36);
    doc.text(`Generado el: ${format(parseISO(report.generatedOn), "dd/MM/yyyy HH:mm", { locale: es })}`, 14, 42);

    const head = [["Fecha", "Sede", "Tipo Pérdida", "Producto", "Cliente", "Cant.", "Costo Unit. (USD)", "Costo Total (USD)"]];
    const body = report.entries.map(entry => [
      format(parseISO(entry.date), "dd/MM/yy", { locale: es }),
      entry.sourceBranchName,
      entry.type,
      entry.productName,
      entry.customerName || '-',
      entry.quantity,
      `$${entry.costPerUnitUSD.toFixed(3)}`,
      `$${entry.totalCostUSD.toFixed(2)}`
    ]);
    body.push([
        { content: "TOTAL PÉRDIDA SEMANAL", colSpan: 7, styles: { fontStyle: 'bold', halign: 'right' } },
        { content: `$${report.totalLossUSD.toFixed(2)}`, styles: { fontStyle: 'bold' } },
    ]);

    doc.autoTable({
      startY: 50, head: head, body: body, theme: 'striped', headStyles: { fillColor: [220, 53, 69], fontSize: 10 }, bodyStyles: { fontSize: 9 },
    });

    doc.save(`reporte_perdida_semanal_${format(parseISO(report.weekEndDate), "yyyy-MM-dd")}.pdf`);
    toast({ title: "Reporte de Pérdida Detallado Generado", description: "PDF descargado.", duration: 5000 });
};

const handleDownloadDetailedProfitReportPDF = (report: WeeklyProfitReport) => {
    const doc = new jsPDF("landscape") as jsPDFWithAutoTable;
    doc.setFontSize(18);
    doc.text("Panificadora Valladares", 14, 20);
    doc.setFontSize(12);
    doc.text(`Reporte Detallado de Ganancias Semanales`, 14, 28);
    doc.setFontSize(10);
    doc.text(`Semana del: ${format(parseISO(report.weekStartDate), "dd/MM/yyyy", { locale: es })} al ${format(parseISO(report.weekEndDate), "dd/MM/yyyy", { locale: es })}`, 14, 36);
    doc.text(`Generado el: ${format(parseISO(report.generatedOn), "dd/MM/yyyy HH:mm", { locale: es })}`, 14, 42);

    const head = [["Fecha", "Sede", "Producto", "Cant. Vendida", "P. Venta (USD)", "Costo Prod. (USD)", "Ganancia Unit. (USD)", "Ganancia Total (USD)"]];
    const body = report.entries.map(entry => [
      format(parseISO(entry.date), "dd/MM/yy", { locale: es }),
      entry.sourceBranchName,
      entry.productName,
      entry.quantitySold,
      `$${entry.salePricePerUnitUSD.toFixed(2)}`,
      `$${entry.costPerUnitUSD.toFixed(3)}`,
      `$${entry.profitPerUnitUSD.toFixed(3)}`,
      `$${entry.totalProfitUSD.toFixed(2)}`
    ]);

    // Totals footer row
    body.push([
        { content: "TOTALES", colSpan: 7, styles: { fontStyle: 'bold', halign: 'right' } },
        { content: `$${report.totalProfitUSD.toFixed(2)}`, styles: { fontStyle: 'bold', fillColor: [230, 245, 230] } },
    ]);

    // Summary below the table
    let finalY = (doc as any).lastAutoTable.finalY || 50;
    const addSummaryText = (label: string, value: string, yOffset: number) => {
        doc.setFontSize(10);
        doc.setFont("helvetica", "bold");
        doc.text(label, 14, finalY + yOffset);
        doc.setFont("helvetica", "normal");
        doc.text(value, 50, finalY + yOffset);
    };

    doc.autoTable({
      startY: 50, head: head, body: body, theme: 'striped', headStyles: { fillColor: [34, 139, 34], fontSize: 10 }, bodyStyles: { fontSize: 9 },
      didDrawPage: (data) => {
          finalY = data.cursor?.y ?? 50;
      }
    });

    finalY = (doc as any).lastAutoTable.finalY + 10;
    
    addSummaryText("Ingresos Totales (USD):", `$${report.totalRevenueUSD.toFixed(2)}`, 0);
    addSummaryText("Costos Totales (USD):", `$${report.totalCostsUSD.toFixed(2)}`, 6);
    addSummaryText("Ganancia Neta (USD):", `$${report.totalProfitUSD.toFixed(2)}`, 12);

    doc.save(`reporte_ganancia_semanal_${format(parseISO(report.weekEndDate), "yyyy-MM-dd")}.pdf`);
    toast({ title: "Reporte de Ganancia Detallado Generado", description: "PDF descargado.", duration: 5000 });
};




  if (isLoading) {
    return <div className="flex justify-center items-center h-screen"><Loader2 className="h-12 w-12 animate-spin text-primary" /><p className="ml-3">Cargando reportes...</p></div>;
  }

  return (
    <div className="space-y-6">
      <PageHeader
        title="Reportes y Analíticas"
        description={`Información de rendimiento. Ventas y Cambios son globales. Inventarios, Producción, OCs, Merma, Pérdidas y Gastos se muestran para la Sede Actual: ${activeBranchName}.`}
        icon={FileText}
        actions={
            <Button variant="outline" onClick={() => setIsDateRangeDialogOpen(true)}>
                <CalendarDays className="mr-2 h-4 w-4" />
                Seleccionar Rango de Fechas
            </Button>
        }
      />
        {selectedDateRange?.from && (
            <Card className="shadow-sm border-dashed border-primary">
                <CardContent className="p-3 text-center">
                    <p className="text-sm text-primary font-medium">
                        Rango de fechas activo para reportes (Ventas, Gastos, OC, Cambios, Merma, Pérdidas):
                        {format(selectedDateRange.from, "dd/MM/yyyy", { locale: es })}
                        {selectedDateRange.to && ` - ${format(selectedDateRange.to, "dd/MM/yyyy", { locale: es })}`}
                    </p>
                </CardContent>
            </Card>
        )}
        
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <Card className="shadow-lg">
            <CardHeader>
              <CardTitle>Historial de Reportes de Pérdida Semanal</CardTitle>
              <CardDescription>Reportes detallados de todas las pérdidas (merma, cambios, muestras) generados automáticamente cada domingo.</CardDescription>
            </CardHeader>
            <CardContent>
              {weeklyLossReports.length > 0 ? (
                <Table>
                  <TableHeader><TableRow><TableHead>Semana del</TableHead><TableHead className="text-right">Pérdida Total (USD)</TableHead><TableHead className="text-right">Acciones</TableHead></TableRow></TableHeader>
                  <TableBody>
                    {weeklyLossReports.map(report => (
                      <TableRow key={report.id}>
                        <TableCell>
                          <div className="font-medium">{format(parseISO(report.weekStartDate), "dd MMM yyyy", { locale: es })} - {format(parseISO(report.weekEndDate), "dd MMM yyyy", { locale: es })}</div>
                          <div className="text-sm text-muted-foreground">Generado: {format(parseISO(report.generatedOn), "dd/MM/yy HH:mm", { locale: es })}</div>
                        </TableCell>
                        <TableCell className="text-right text-destructive font-semibold">${report.totalLossUSD.toFixed(2)}</TableCell>
                        <TableCell className="text-right">
                          <Button variant="outline" size="sm" onClick={() => { setSelectedLossReport(report); setIsLossReportDialogOpen(true); }}>
                            <Eye className="mr-2 h-4 w-4" />Ver Detalles
                          </Button>
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              ) : (<p className="text-center text-muted-foreground py-8">No se han generado reportes semanales de pérdidas.</p>)}
            </CardContent>
          </Card>
          <Card className="shadow-lg">
            <CardHeader>
              <CardTitle>Historial de Reportes de Ganancia Semanal</CardTitle>
              <CardDescription>Reportes detallados de la ganancia estimada generados automáticamente cada domingo.</CardDescription>
            </CardHeader>
            <CardContent>
              {weeklyProfitReports.length > 0 ? (
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>Semana del</TableHead>
                      <TableHead className="text-right">Ingresos Totales (USD)</TableHead>
                      <TableHead className="text-right">Ganancia Total (USD)</TableHead>
                      <TableHead className="text-right">Acciones</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {weeklyProfitReports.map(report => (
                      <TableRow key={report.id}>
                        <TableCell>
                          <div className="font-medium">{format(parseISO(report.weekStartDate), "dd MMM yyyy", { locale: es })} - {format(parseISO(report.weekEndDate), "dd MMM yyyy", { locale: es })}</div>
                          <div className="text-sm text-muted-foreground">Generado: {format(parseISO(report.generatedOn), "dd/MM/yy HH:mm", { locale: es })}</div>
                        </TableCell>
                        <TableCell className="text-right">${report.totalRevenueUSD.toFixed(2)}</TableCell>
                        <TableCell className="text-right text-green-600 font-semibold">${report.totalProfitUSD.toFixed(2)}</TableCell>
                        <TableCell className="text-right">
                          <Button variant="outline" size="sm" onClick={() => { setSelectedProfitReport(report); setIsProfitReportDialogOpen(true); }}>
                            <Eye className="mr-2 h-4 w-4" />Ver Detalles
                          </Button>
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              ) : (<p className="text-center text-muted-foreground py-8">No se han generado reportes semanales de ganancias.</p>)}
            </CardContent>
          </Card>
      </div>

      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
        <Card className="shadow-lg">
          <CardHeader>
            <CardTitle className="flex items-center gap-2"><BarChartIconLucide className="h-5 w-5 text-primary" /> Top {TOP_N_PRODUCTS_REPORTS} Productos Vendidos (Global)</CardTitle>
            <CardDescription>Cantidad de unidades vendidas por producto en el período seleccionado.</CardDescription>
          </CardHeader>
          <CardContent className="h-[300px]">
            {productSalesQuantityChartData.length > 0 ? (
              <ChartContainer config={productSalesQuantityChartConfig} className="h-full w-full">
                <BarChart data={productSalesQuantityChartData} layout="vertical" margin={{ top: 5, right: 20, left: 30, bottom: 5 }}>
                  <CartesianGrid strokeDasharray="3 3" /><XAxis type="number" allowDecimals={false} tickLine={false} axisLine={false} tickMargin={10} fontSize={12}/><YAxis dataKey="name" type="category" tickLine={false} axisLine={false} tickMargin={5} width={120} interval={0} fontSize={12}/>
                  <ChartTooltip content={<ChartTooltipContent indicator="dot" className="text-sm"/>} />
                  <Bar dataKey="quantity" fill="var(--color-quantity)" radius={4} nameKey="name" />
                </BarChart>
              </ChartContainer>
            ) : (<p className="text-center text-muted-foreground py-8">No hay datos de ventas de productos para el período.</p>)}
          </CardContent>
          <CardFooter>
            <Button className="w-full" onClick={handleDownloadSalesReport}><Download className="mr-2 h-4 w-4" /> Descargar Ventas (Global)</Button>
          </CardFooter>
        </Card>

        <Card className="shadow-lg">
          <CardHeader>
            <CardTitle className="flex items-center gap-2"><Shuffle className="h-5 w-5 text-primary" /> Top {TOP_N_CHANGES_REPORTS} Productos Cambiados (Global)</CardTitle>
            <CardDescription>Cantidad cambiada/devuelta por producto en el período. Costo basado en recetas sede: {activeBranchName}.</CardDescription>
          </CardHeader>
          <CardContent className="h-[300px]">
            {productChangesChartData.length > 0 ? (
              <ChartContainer config={productChangesChartConfig} className="h-full w-full">
                <BarChart data={productChangesChartData} layout="vertical" margin={{ top: 5, right: 20, left: 30, bottom: 5 }}>
                  <CartesianGrid strokeDasharray="3 3" /><XAxis type="number" allowDecimals={false} tickLine={false} axisLine={false} tickMargin={10} fontSize={12}/><YAxis dataKey="name" type="category" tickLine={false} axisLine={false} tickMargin={5} width={120} interval={0} fontSize={12}/>
                  <ChartTooltip content={<ChartTooltipContent indicator="dot" className="text-sm"/>} />
                  <Bar dataKey="quantity" fill="var(--color-quantity)" radius={4} nameKey="name" />
                </BarChart>
              </ChartContainer>
            ) : (<p className="text-center text-muted-foreground py-8">No hay datos de cambios/devoluciones para el período.</p>)}
          </CardContent>
          <CardFooter>
            <Button className="w-full" onClick={handleDownloadProductChangesReport}><Download className="mr-2 h-4 w-4" /> Descargar Cambios (Global)</Button>
          </CardFooter>
        </Card>

        <Card className="shadow-lg">
          <CardHeader>
            <CardTitle className="flex items-center gap-2"><TrendingDown className="h-5 w-5 text-destructive" /> Top {TOP_N_WASTAGE_PRODUCTS_REPORTS} Merma (Costo - Sede: {activeBranchName})</CardTitle>
            <CardDescription>Costo total de merma (USD, ingr. + oper. sede actual) por producto en el período.</CardDescription>
          </CardHeader>
          <CardContent className="h-[300px]">
            {productWastageChartData.length > 0 ? (
              <ChartContainer config={productWastageChartConfig} className="h-full w-full">
                <BarChart data={productWastageChartData} layout="vertical" margin={{ top: 5, right: 20, left: 30, bottom: 5 }}>
                  <CartesianGrid strokeDasharray="3 3" /><XAxis type="number" tickFormatter={(value) => `$${value}`} tickLine={false} axisLine={false} tickMargin={10} fontSize={12}/><YAxis dataKey="name" type="category" tickLine={false} axisLine={false} tickMargin={5} width={120} interval={0} fontSize={12}/>
                  <ChartTooltip content={({ active, payload }) => { if (active && payload && payload.length) { const data = payload[0].payload; return (<div className="rounded-lg border bg-background p-2 shadow-sm text-sm"><div className="grid grid-cols-1 gap-1.5"><span className="font-medium">{data.name}</span><span className="text-muted-foreground">Costo Merma: <span className="font-semibold text-destructive">${data.wastageCostUSD.toFixed(2)}</span></span><span className="text-muted-foreground">Cant. Mermada: <span className="font-semibold">{data.wastageQuantity} unid.</span></span></div></div>); } return null; }} />
                  <Bar dataKey="wastageCostUSD" fill="var(--color-wastageCostUSD)" radius={4} nameKey="name" />
                </BarChart>
              </ChartContainer>
            ) : (<p className="text-center text-muted-foreground py-8">No hay datos de merma para el período y sede actual.</p>)}
          </CardContent>
          <CardFooter>
            <Button className="w-full" onClick={handleDownloadWastageReport}><Download className="mr-2 h-4 w-4" /> Descargar Merma (Sede: {activeBranchName})</Button>
          </CardFooter>
        </Card>

        <Card className="shadow-lg">
          <CardHeader>
            <CardTitle className="flex items-center gap-2"><Combine className="h-5 w-5 text-destructive" /> Top {TOP_N_LOSSES_REPORTS} Pérdidas Totales (Costo - Sede: {activeBranchName})</CardTitle>
            <CardDescription>Suma de costo merma, cambios y muestras (todos costos basados en sede actual).</CardDescription>
          </CardHeader>
          <CardContent className="h-[300px]">
            {productLossesData.length > 0 ? (
              <ChartContainer config={productLossesChartConfig} className="h-full w-full">
                <BarChart data={productLossesData} layout="vertical" margin={{ top: 5, right: 20, left: 30, bottom: 5 }}>
                  <CartesianGrid strokeDasharray="3 3" /><XAxis type="number" tickFormatter={(value) => `$${value}`} tickLine={false} axisLine={false} tickMargin={10} fontSize={12}/><YAxis dataKey="name" type="category" tickLine={false} axisLine={false} tickMargin={5} width={120} interval={0} fontSize={12}/>
                  <ChartTooltip content={({ active, payload }) => {
                    if (active && payload && payload.length) {
                      const data = payload[0].payload;
                      return (
                        <div className="rounded-lg border bg-background p-2 shadow-sm text-sm">
                          <div className="grid grid-cols-1 gap-1.5">
                            <span className="font-medium">{data.name}</span>
                            <span className="text-muted-foreground">Costo Total Perdido: <span className="font-semibold text-destructive">${data.totalCostLostUSD.toFixed(2)}</span></span>
                            <span className="text-muted-foreground">Cant. Total Perdida: <span className="font-semibold">{data.totalQuantityLost} unid.</span></span>
                            <span className="text-xs text-muted-foreground">(Cambios: {data.quantityChanged} unid, ${data.costChangedUSD.toFixed(2)})</span>
                            <span className="text-xs text-muted-foreground">(Merma: {data.quantityWasted} unid, ${data.costWastedUSD.toFixed(2)})</span>
                            <span className="text-xs text-muted-foreground">(Muestras: {data.quantitySampled} unid, ${data.costSampledUSD.toFixed(2)})</span>
                          </div>
                        </div>
                      );
                    }
                    return null;
                  }} />
                  <Bar dataKey="totalCostLostUSD" fill="var(--color-totalCostLostUSD)" radius={4} nameKey="name" />
                </BarChart>
              </ChartContainer>
            ) : (<p className="text-center text-muted-foreground py-8">No hay datos consolidados de pérdidas para el período y sede actual.</p>)}
          </CardContent>
          <CardFooter>
            <Button className="w-full" onClick={handleDownloadLossesReport}><Download className="mr-2 h-4 w-4" /> Descargar Pérdidas (Sede: {activeBranchName})</Button>
          </CardFooter>
        </Card>

        <Card className="shadow-lg">
          <CardHeader>
            <CardTitle className="flex items-center gap-2"><PieChartIconLucide className="h-5 w-5 text-primary" /> Desglose de Gastos (Sede: {activeBranchName})</CardTitle>
            <CardDescription>Distribución de gastos por categoría en el período para la sede actual.</CardDescription>
          </CardHeader>
          <CardContent className="h-[300px]">
            {expensesChartData.length > 0 ? (
              <ChartContainer config={expensesChartConfig} className="h-full w-full">
                <ResponsiveContainer width="100%" height="100%"><PieChart><ChartTooltip content={<ChartTooltipContent nameKey="category" hideLabel className="text-sm"/>} /><Pie data={expensesChartData} dataKey="total" nameKey="category" cx="50%" cy="50%" outerRadius={80} labelLine={false} label={({ cx, cy, midAngle, innerRadius, outerRadius, percent }) => { const RADIAN = Math.PI / 180; const radius = innerRadius + (outerRadius - innerRadius) * 0.5; const x = cx + radius * Math.cos(-midAngle * RADIAN); const y = cy + radius * Math.sin(-midAngle * RADIAN); return (percent || 0) * 100 > 5 ? (<text x={x} y={y} fill="white" textAnchor={x > cx ? 'start' : 'end'} dominantBaseline="central" fontSize={12}>{`${((percent || 0) * 100).toFixed(0)}%`}</text>) : null; }}>{expensesChartData.map((entry, index) => (<Cell key={`cell-${index}`} fill={entry.fill} />))}</Pie><ChartLegend content={<ChartLegendContent nameKey="category" className="text-sm"/>} /></PieChart></ResponsiveContainer>
              </ChartContainer>
            ) : (<p className="text-center text-muted-foreground py-8">No hay datos de gastos para el período y sede actual.</p>)}
          </CardContent>
          <CardFooter>
            <Button className="w-full" onClick={handleDownloadExpenseReport}><Download className="mr-2 h-4 w-4" /> Descargar Gastos (Sede: {activeBranchName})</Button>
          </CardFooter>
        </Card>

        <Card className="shadow-lg">
          <CardHeader>
            <CardTitle className="flex items-center gap-2"><Package className="h-5 w-5 text-primary" /> Stock de Producción (Sede: {activeBranchName})</CardTitle>
            <CardDescription>Top 10 productos con más stock en la sede actual.</CardDescription>
          </CardHeader>
          <CardContent className="h-[300px]">
             {productStockChartData.length > 0 ? (
              <ChartContainer config={productStockChartConfig} className="h-full w-full">
                <BarChart data={productStockChartData} layout="vertical" margin={{ top: 5, right: 20, left: 30, bottom: 5 }}>
                  <CartesianGrid strokeDasharray="3 3" /><XAxis type="number" tickLine={false} axisLine={false} tickMargin={10} fontSize={12} /><YAxis dataKey="name" type="category" tickLine={false} axisLine={false} tickMargin={5} fontSize={12} width={120} interval={0} /><ChartTooltip content={<ChartTooltipContent className="text-sm"/>} /><Bar dataKey="stock" fill="var(--color-stock)" radius={4} />
                </BarChart>
              </ChartContainer>
            ) : (<p className="text-center text-muted-foreground py-8">No hay productos en stock en la sede actual.</p>)}
          </CardContent>
          <CardFooter>
            <Button className="w-full" onClick={handleDownloadInventoryReport}><Download className="mr-2 h-4 w-4" /> Descargar Stock Prod. (Sede: {activeBranchName})</Button>
          </CardFooter>
        </Card>

        <Card className="shadow-lg">
          <CardHeader>
            <CardTitle className="flex items-center gap-2"><Archive className="h-5 w-5 text-primary" /> Inventario Materia Prima (Sede: {activeBranchName})</CardTitle>
            <CardDescription>Top 10 materias primas con más stock en la sede actual (en unidad base).</CardDescription>
          </CardHeader>
          <CardContent className="h-[300px]">
            {rawMaterialStockChartData.length > 0 ? (
              <ChartContainer config={rawMaterialStockChartConfig} className="h-full w-full">
                <BarChart data={rawMaterialStockChartData} layout="vertical" margin={{ top: 5, right: 20, left: 30, bottom: 5 }}>
                  <CartesianGrid strokeDasharray="3 3" /><XAxis type="number" tickLine={false} axisLine={false} tickMargin={10} fontSize={12} /><YAxis dataKey="name" type="category" tickLine={false} axisLine={false} tickMargin={5} fontSize={12} width={120} interval={0} /><ChartTooltip content={<ChartTooltipContent className="text-sm"/>} /><Bar dataKey="stock" fill="var(--color-stock)" radius={4} />
                </BarChart>
              </ChartContainer>
            ) : (<p className="text-center text-muted-foreground py-8">No hay materia prima en inventario en la sede actual.</p>)}
          </CardContent>
          <CardFooter>
             <Button className="w-full" onClick={handleDownloadRawMaterialInventoryReport}><Download className="mr-2 h-4 w-4" /> Descargar Materia Prima (Sede: {activeBranchName})</Button>
          </CardFooter>
        </Card>

        <Card className="shadow-lg col-span-1 md:col-span-2 lg:col-span-1">
          <CardHeader>
            <CardTitle className="flex items-center gap-2"><Layers className="h-5 w-5 text-primary" /> Órdenes de Compra (Pagadas - Sede: {activeBranchName})</CardTitle>
            <CardDescription>Top 10 proveedores por costo total (USD) en el período para la sede actual.</CardDescription>
          </CardHeader>
          <CardContent className="h-[300px]">
            {purchaseOrdersChartData.length > 0 ? (
              <ChartContainer config={purchaseOrdersChartConfig} className="h-full w-full">
                <BarChart data={purchaseOrdersChartData} layout="vertical" margin={{ top: 5, right: 20, left: 30, bottom: 5 }}>
                  <CartesianGrid strokeDasharray="3 3" /><XAxis type="number" tickFormatter={(value) => `$${value}`} tickLine={false} axisLine={false} tickMargin={10} fontSize={12} /><YAxis dataKey="supplierName" type="category" tickLine={false} axisLine={false} tickMargin={5} fontSize={12} width={120} interval={0} /><ChartTooltip content={<ChartTooltipContent className="text-sm"/>} /><Bar dataKey="totalCost" fill="var(--color-totalCost)" radius={4} />
                </BarChart>
              </ChartContainer>
            ) : (<p className="text-center text-muted-foreground py-8">No hay órdenes de compra pagadas para el período y sede actual.</p>)}
          </CardContent>
          <CardFooter>
             <Button className="w-full" onClick={handleDownloadPurchaseOrdersReport}><Download className="mr-2 h-4 w-4" /> Descargar Órdenes Compra (Sede: {activeBranchName})</Button>
          </CardFooter>
        </Card>
      </div>

      <Dialog open={isDateRangeDialogOpen} onOpenChange={setIsDateRangeDialogOpen}>
        <DialogContent className="sm:max-w-2xl">
          <DialogHeader>
            <DialogTitle>Seleccionar Rango de Fechas para Reportes</DialogTitle>
            <DialogDescription>Elige un rango para reportes. Los de Inventarios y Stock siempre muestran el estado actual.</DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4 justify-center">
            <Calendar mode="range" selected={selectedDateRange} onSelect={setSelectedDateRange} locale={es} numberOfMonths={2}/>
            {selectedDateRange?.from && (<p className="text-center text-sm text-muted-foreground">Rango: {format(selectedDateRange.from, "dd/MM/yyyy", { locale: es })}{selectedDateRange.to && ` - ${format(selectedDateRange.to, "dd/MM/yyyy", { locale: es })}`}</p>)}
          </div>
          <UiDialogFooter>
            <Button variant="outline" onClick={() => setSelectedDateRange(undefined)}>Limpiar Rango</Button>
            <DialogClose asChild><Button onClick={() => { setIsDateRangeDialogOpen(false); if (selectedDateRange?.from) { toast({ title: "Rango Aplicado", description: `Reportes usarán este rango.`}); } else { toast({ title: "Rango Limpiado", description: `Reportes mostrarán todos los datos.`}); }}}>Aplicar y Cerrar</Button></DialogClose>
          </UiDialogFooter>
        </DialogContent>
      </Dialog>
      
      <Dialog open={isLossReportDialogOpen} onOpenChange={setIsLossReportDialogOpen}>
        <DialogContent className="sm:max-w-4xl max-h-[90vh]">
          <DialogHeader>
            <DialogTitle>Detalle del Reporte de Pérdida Semanal</DialogTitle>
            {selectedLossReport && (
                <DialogDescription>
                    Semana del {format(parseISO(selectedLossReport.weekStartDate), "dd MMM yyyy", { locale: es })} al {format(parseISO(selectedLossReport.weekEndDate), "dd MMM yyyy", { locale: es })}.
                    Pérdida Total: <span className="font-bold text-destructive">${selectedLossReport.totalLossUSD.toFixed(2)}</span>.
                </DialogDescription>
            )}
          </DialogHeader>
          <div className="flex-1 min-h-0">
            <ScrollArea className="h-[60vh]">
              <Table className="text-base">
                <TableHeader>
                  <TableRow>
                    <TableHead>Fecha</TableHead>
                    <TableHead>Sede</TableHead>
                    <TableHead>Tipo Pérdida</TableHead>
                    <TableHead>Producto</TableHead>
                    <TableHead>Cliente</TableHead>
                    <TableHead className="text-right">Cant.</TableHead>
                    <TableHead className="text-right">Costo Unit. (USD)</TableHead>
                    <TableHead className="text-right">Costo Total (USD)</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {selectedLossReport?.entries.map((entry, index) => (
                    <TableRow key={`${entry.date}-${entry.productName}-${index}`}>
                      <TableCell>{format(parseISO(entry.date), "dd/MM/yy", { locale: es })}</TableCell>
                      <TableCell>{entry.sourceBranchName}</TableCell>
                      <TableCell>{entry.type}</TableCell>
                      <TableCell>{entry.productName}</TableCell>
                      <TableCell>{entry.customerName || '-'}</TableCell>
                      <TableCell className="text-right">{entry.quantity}</TableCell>
                      <TableCell className="text-right">${entry.costPerUnitUSD.toFixed(3)}</TableCell>
                      <TableCell className="text-right text-destructive">${entry.totalCostUSD.toFixed(2)}</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </ScrollArea>
          </div>
          <UiDialogFooter>
            <Button variant="outline" onClick={() => setIsLossReportDialogOpen(false)}>Cerrar</Button>
            <Button onClick={() => selectedLossReport && handleDownloadDetailedLossReportPDF(selectedLossReport)} disabled={!selectedLossReport}>
                <Download className="mr-2 h-4 w-4" /> Descargar PDF
            </Button>
          </UiDialogFooter>
        </DialogContent>
      </Dialog>

      <Dialog open={isProfitReportDialogOpen} onOpenChange={setIsProfitReportDialogOpen}>
        <DialogContent className="sm:max-w-4xl max-h-[90vh]">
          <DialogHeader>
            <DialogTitle>Detalle del Reporte de Ganancia Semanal</DialogTitle>
            {selectedProfitReport && (
                <DialogDescription>
                    <p>Semana del {format(parseISO(selectedProfitReport.weekStartDate), "dd MMM yyyy", { locale: es })} al {format(parseISO(selectedProfitReport.weekEndDate), "dd MMM yyyy", { locale: es })}.</p>
                    <p>
                        <span className="font-semibold">Ingresos Totales:</span> <span className="text-green-600">${selectedProfitReport.totalRevenueUSD.toFixed(2)}</span> | 
                        <span className="font-semibold"> Costos Totales:</span> <span className="text-destructive">${selectedProfitReport.totalCostsUSD.toFixed(2)}</span> | 
                        <span className="font-semibold"> Ganancia Neta:</span> <span className="font-bold text-primary">${selectedProfitReport.totalProfitUSD.toFixed(2)}</span>
                    </p>
                </DialogDescription>
            )}
          </DialogHeader>
          <div className="flex-1 min-h-0">
            <ScrollArea className="h-[60vh]">
              <Table className="text-base">
                <TableHeader>
                  <TableRow>
                    <TableHead>Fecha</TableHead>
                    <TableHead>Sede</TableHead>
                    <TableHead>Producto</TableHead>
                    <TableHead className="text-right">Cant. Vendida</TableHead>
                    <TableHead className="text-right">P. Venta (USD)</TableHead>
                    <TableHead className="text-right">Costo Prod. (USD)</TableHead>
                    <TableHead className="text-right">Ganancia Unit. (USD)</TableHead>
                    <TableHead className="text-right">Ganancia Total (USD)</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {selectedProfitReport?.entries.map((entry, index) => (
                    <TableRow key={`${entry.date}-${entry.productName}-${index}`}>
                      <TableCell>{format(parseISO(entry.date), "dd/MM/yy", { locale: es })}</TableCell>
                      <TableCell>{entry.sourceBranchName}</TableCell>
                      <TableCell>{entry.productName}</TableCell>
                      <TableCell className="text-right">{entry.quantitySold}</TableCell>
                      <TableCell className="text-right">${entry.salePricePerUnitUSD.toFixed(2)}</TableCell>
                      <TableCell className="text-right">${entry.costPerUnitUSD.toFixed(3)}</TableCell>
                      <TableCell className="text-right text-green-600">${entry.profitPerUnitUSD.toFixed(3)}</TableCell>
                      <TableCell className="text-right text-green-600 font-semibold">${entry.totalProfitUSD.toFixed(2)}</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </ScrollArea>
          </div>
          <UiDialogFooter>
            <Button variant="outline" onClick={() => setIsProfitReportDialogOpen(false)}>Cerrar</Button>
            <Button onClick={() => selectedProfitReport && handleDownloadDetailedProfitReportPDF(selectedProfitReport)} disabled={!selectedProfitReport}>
                <Download className="mr-2 h-4 w-4" /> Descargar PDF
            </Button>
          </UiDialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}

// --- sales ---


"use client";

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { PageHeader } from '@/components/page-header';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Badge } from '@/components/ui/badge';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogClose } from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { ShoppingCart, PlusCircle, MoreHorizontal, Edit, Trash2, Calendar as CalendarIcon, Loader2, Trash, FileText as InvoiceIcon, Filter, Gift, AlertTriangle, Eye, DollarSign, Info, ShieldCheck } from 'lucide-react';
import { useToast } from "@/hooks/use-toast";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Calendar } from "@/components/ui/calendar";
import { format, parseISO, addDays, differenceInDays, isWithinInterval, startOfDay, endOfDay, isValid, compareDesc } from "date-fns";
import type { DateRange } from "react-day-picker";
import { es } from "date-fns/locale";
import { cn } from "@/lib/utils";
import {
  type Product,
  salesData as initialSalesDataGlobal,
  saveSalesData,
  type Sale,
  type SaleItem,
  type SaleBranchDetail,
  customersData as initialCustomersDataGlobal,
  saveCustomersData,
  type Customer,
  salePaymentMethods,
  loadExchangeRate,
  type AccountTransaction,
  type CompanyAccountsData,
  type AccountType,
  accountTypeNames,
  getInvoiceStatus,
  type SaleStatus,
  paymentsData as initialPaymentsDataGlobal,
  savePaymentsData,
  type Payment,
  KEYS,
  loadAllProductsFromAllBranches,
  loadProductsForBranch,
  saveProductsDataForBranch,
  type PendingFundTransfer,
  savePendingFundTransfersData,
  pendingFundTransfersData as initialPendingFundTransfersData,
  availableBranches,
  getActiveBranchId,
  loadFromLocalStorageForBranch,
  saveToLocalStorageForBranch,
  calculateCustomerBalance,
  type PaymentSplit,
  type PaymentMethodType,
  paymentMethodList,
  userProfileData,
  updateGlobalSaleDataAndFinances,
  loadFromLocalStorage,
  type Recipe // Importar Recipe
} from '@/lib/data-storage';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';
import jsPDF from 'jspdf';
import 'jspdf-autotable';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Textarea } from '@/components/ui/textarea';
import { FormattedNumber } from '@/components/ui/formatted-number';
import { Checkbox } from '@/components/ui/checkbox';


interface jsPDFWithAutoTable extends jsPDF {
  autoTable: (options: any) => jsPDFWithAutoTable;
}

const ALL_CUSTOMERS_FILTER_VALUE = "__ALL_CUSTOMERS__";
const ALL_STATUSES_FILTER_VALUE = "__ALL_STATUSES__";
const saleStatusOptions: SaleStatus[] = ['Completada', 'Pendiente de Pago', 'Vencida', 'Pagada Parcialmente'];


export default function SalesPage() {
  const { toast } = useToast();
  const [allSales, setAllSales] = useState<Sale[]>([]);
  const [filteredSales, setFilteredSales] = useState<Sale[]>([]);
  const [availableProducts, setAvailableProducts] = useState<Product[]>([]);
  const [availableCustomers, setAvailableCustomers] = useState<Customer[]>([]);
  const [allRecipes, setAllRecipes] = useState<Recipe[]>([]); // Estado para recetas
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [exchangeRate, setExchangeRate] = useState<number>(0);

  const [isAddSaleDialogOpen, setIsAddSaleDialogOpen] = useState(false);
  const [newSaleDate, setNewSaleDate] = useState<Date | undefined>(new Date());
  const [newSaleItems, setNewSaleItems] = useState<SaleItem[]>([{ productId: '', productName: '', quantity: 1, unitPrice: 0, subtotal: 0, sourceBranchId: '', sourceBranchName: '' }]);
  const [newSaleChanges, setNewSaleChanges] = useState<SaleItem[]>([{ productId: '', productName: '', quantity: 1, unitPrice: 0, subtotal: 0, sourceBranchId: '', sourceBranchName: '' }]);
  const [newSampleItems, setNewSampleItems] = useState<SaleItem[]>([{ productId: '', productName: '', quantity: 1, unitPrice: 0, subtotal: 0, sourceBranchId: '', sourceBranchName: '' }]);
  const [newSelectedCustomerId, setNewSelectedCustomerId] = useState<string>('');
  const [newPaymentMethod, setNewPaymentMethod] = useState<Sale['paymentMethod']>('Pagado');
  const [newSaleNotes, setNewSaleNotes] = useState('');
  
  const [newPaymentSplits, setNewPaymentSplits] = useState<PaymentSplit[]>([{ id: `split-${Date.now()}`, amount: 0, currency: 'VES', paymentMethod: 'Transferencia (VES)', paidToBranchId: '', paidToAccountId: 'vesElectronic', referenceNumber: ''}]);
  const [creditNoteTargetInvoiceId, setCreditNoteTargetInvoiceId] = useState<string>('');
  const [pendingInvoicesForCustomer, setPendingInvoicesForCustomer] = useState<Sale[]>([]); // Para el diálogo de NC

  const [customerBalance, setCustomerBalance] = useState(0);
  const [applyCustomerCredit, setApplyCustomerCredit] = useState(false);


  const [isEditSaleDialogOpen, setIsEditSaleDialogOpen] = useState(false);
  const [editingSale, setEditingSale] = useState<Sale | null>(null);
  const [originalSaleForEdit, setOriginalSaleForEdit] = useState<Sale | null>(null);
  const [editSaleDate, setEditSaleDate] = useState<Date | undefined>(undefined);
  const [editSaleItems, setEditSaleItems] = useState<SaleItem[]>([]);
  const [editSaleChanges, setEditSaleChanges] = useState<SaleItem[]>([{ productId: '', productName: '', quantity: 1, unitPrice: 0, subtotal: 0, sourceBranchId: '', sourceBranchName: '' }]);
  const [editSampleItems, setEditSampleItems] = useState<SaleItem[]>([{ productId: '', productName: '', quantity: 1, unitPrice: 0, subtotal: 0, sourceBranchId: '', sourceBranchName: '' }]);
  const [editSelectedCustomerId, setEditSelectedCustomerId] = useState<string>('');
  const [editPaymentMethod, setEditPaymentMethod] = useState<Sale['paymentMethod']>('Pagado');
  const [editSaleNotes, setEditSaleNotes] = useState('');
  const [editPaymentSplits, setEditPaymentSplits] = useState<PaymentSplit[]>([]);


  const [isDeleteConfirmDialogOpen, setIsDeleteConfirmDialogOpen] = useState(false);
  const [saleToDeleteId, setSaleToDeleteId] = useState<string | null>(null);

  const [dateRangeFilter, setDateRangeFilter] = useState<DateRange | undefined>(undefined);
  const [filterCustomerId, setFilterCustomerId] = useState<string>(ALL_CUSTOMERS_FILTER_VALUE);
  const [filterSaleStatus, setFilterSaleStatus] = useState<string>(ALL_STATUSES_FILTER_VALUE);

  const [isViewSaleDialogOpen, setIsViewSaleDialogOpen] = useState(false);
  const [saleToViewDetails, setSaleToViewDetails] = useState<Sale | null>(null);

  const [isSaleDatePickerOpen, setIsSaleDatePickerOpen] = useState(false);

  const vendibleProducts = useMemo(() => {
    return availableProducts.filter(p => 
        p.category?.toLowerCase() !== 'no despachable' && 
        !p.name.toLowerCase().startsWith('no despachable')
    );
  }, [availableProducts]);

  const loadPageData = useCallback(() => {
    setIsLoading(true);
    setAvailableProducts(loadAllProductsFromAllBranches());
    const recipesByBranch: Recipe[] = [];
    availableBranches.forEach(branch => {
        recipesByBranch.push(...loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, branch.id));
    });
    setAllRecipes(recipesByBranch);
    const currentSales = [...initialSalesDataGlobal].sort((a, b) => {
        const dateA = a.timestamp && isValid(parseISO(a.timestamp)) ? parseISO(a.timestamp).getTime() : (a.date ? parseISO(a.date).getTime() : 0);
        const dateB = b.timestamp && isValid(parseISO(b.timestamp)) ? parseISO(b.timestamp).getTime() : (b.date ? parseISO(b.date).getTime() : 0);
        return dateB - dateA;
    });
    setAllSales(currentSales);
    setFilteredSales(currentSales);
    setAvailableCustomers([...initialCustomersDataGlobal].sort((a, b) => a.name.localeCompare(b.name)));
    setExchangeRate(loadExchangeRate());
    const activeBranch = getActiveBranchId();
    const initialBranchId = activeBranch || (availableBranches.length > 0 ? availableBranches[0].id : '');
    const initialAccountId: AccountType = 'vesElectronic';
    const initialCurrency: 'VES' | 'USD' = 'VES';
    const initialPaymentMethod: PaymentMethodType = 'Transferencia (VES)';
    
    setNewPaymentSplits([{ id: `split-${Date.now()}`, amount: 0, currency: initialCurrency, paymentMethod: initialPaymentMethod, paidToBranchId: initialBranchId, paidToAccountId: initialAccountId, referenceNumber: ''}]);

    setIsLoading(false);
  }, []);

  useEffect(() => {
    loadPageData();
    const handleDataUpdate = (event: Event) => {
        const customEvent = event as CustomEvent;
        if (customEvent.detail?.key === KEYS.SALES ||
            customEvent.detail?.key === KEYS.PRODUCTS ||
            customEvent.detail?.key === KEYS.CUSTOMERS ||
            customEvent.detail?.key === KEYS.PAYMENTS ||
            customEvent.detail?.key === KEYS.ACCOUNT_TRANSACTIONS ||
            customEvent.detail?.key === KEYS.COMPANY_ACCOUNTS ||
            customEvent.detail?.key === KEYS.PENDING_FUND_TRANSFERS ||
            customEvent.detail?.key === KEYS.EXCHANGE_RATE_HISTORY ||
            customEvent.detail?.key === KEYS.RECIPES
            ) {
            loadPageData();
        }
    };
    window.addEventListener('data-updated', handleDataUpdate);
    return () => {
        window.removeEventListener('data-updated', handleDataUpdate);
    };
  }, [loadPageData]);
  
  useEffect(() => {
    const customerId = isAddSaleDialogOpen ? newSelectedCustomerId : (isEditSaleDialogOpen ? editSelectedCustomerId : '');
    if (customerId) {
        const balance = calculateCustomerBalance(customerId);
        setCustomerBalance(balance);
        const invoices = initialSalesDataGlobal.filter(s => s.customerId === customerId && getInvoiceStatus(s, initialPaymentsDataGlobal) !== 'Completada').sort((a, b) => parseISO(a.date).getTime() - parseISO(b.date).getTime());
        setPendingInvoicesForCustomer(invoices);
    } else {
        setCustomerBalance(0);
        setPendingInvoicesForCustomer([]);
    }
     setApplyCustomerCredit(false);
  }, [newSelectedCustomerId, editSelectedCustomerId, isAddSaleDialogOpen, isEditSaleDialogOpen, allSales]);


  useEffect(() => {
    if (isAddSaleDialogOpen && newSaleDate) {
      setExchangeRate(loadExchangeRate(newSaleDate));
    } else if (isEditSaleDialogOpen && editSaleDate) {
      setExchangeRate(loadExchangeRate(editSaleDate));
    } else if (!isAddSaleDialogOpen && !isEditSaleDialogOpen) {
      setExchangeRate(loadExchangeRate());
    }
  }, [isAddSaleDialogOpen, newSaleDate, isEditSaleDialogOpen, editSaleDate]);


  const applyFilters = useCallback(() => {
    let salesToFilter = [...allSales];
    if (dateRangeFilter?.from) {
      const toDate = dateRangeFilter.to ? endOfDay(dateRangeFilter.to) : endOfDay(dateRangeFilter.from);
      salesToFilter = salesToFilter.filter(sale =>
        isValid(parseISO(sale.date)) && isWithinInterval(parseISO(sale.date), { start: startOfDay(dateRangeFilter.from!), end: toDate })
      );
    }
    if (filterCustomerId && filterCustomerId !== ALL_CUSTOMERS_FILTER_VALUE) {
      salesToFilter = salesToFilter.filter(sale => sale.customerId === filterCustomerId);
    }
    if (filterSaleStatus && filterSaleStatus !== ALL_STATUSES_FILTER_VALUE) {
      salesToFilter = salesToFilter.filter(sale => getInvoiceStatus(sale, initialPaymentsDataGlobal) === filterSaleStatus);
    }
    setFilteredSales(salesToFilter);
  }, [allSales, dateRangeFilter, filterCustomerId, filterSaleStatus]);


  useEffect(() => {
    applyFilters();
  }, [allSales, dateRangeFilter, filterCustomerId, filterSaleStatus, applyFilters]);

  const handleApplyFilters = () => { applyFilters(); };
  const handleClearFilters = () => {
    setDateRangeFilter(undefined);
    setFilterCustomerId(ALL_CUSTOMERS_FILTER_VALUE);
    setFilterSaleStatus(ALL_STATUSES_FILTER_VALUE);
  };

  const calculateItemsSubtotal = (items: SaleItem[]): number => {
    return items.reduce((total, item) => total + (item.subtotal || 0), 0);
  };
  
  const calculateTotalAmount = (items: SaleItem[], changes: SaleItem[]): number => {
    const itemsSubtotal = calculateItemsSubtotal(items);
    const changesSubtotal = calculateItemsSubtotal(changes);
    return parseFloat((itemsSubtotal - changesSubtotal).toFixed(4));
  };

  const resetAddForm = () => {
    setNewSaleDate(new Date());
    setNewSaleItems([{ productId: '', productName: '', quantity: 1, unitPrice: 0, subtotal: 0, sourceBranchId: '', sourceBranchName: '' }]);
    setNewSaleChanges([{ productId: '', productName: '', quantity: 1, unitPrice: 0, subtotal: 0, sourceBranchId: '', sourceBranchName: '' }]);
    setNewSampleItems([{ productId: '', productName: '', quantity: 1, unitPrice: 0, subtotal: 0, sourceBranchId: '', sourceBranchName: '' }]);
    setNewSelectedCustomerId(availableCustomers.length > 0 ? availableCustomers[0].id : '');
    setNewPaymentMethod('Pagado');
    setNewSaleNotes('');
    const activeBranch = getActiveBranchId();
    const initialBranchId = activeBranch || (availableBranches.length > 0 ? availableBranches[0].id : '');
    const initialAccountId: AccountType = 'vesElectronic';
    const initialCurrency: 'VES' | 'USD' = 'VES';
    const initialPaymentMethod: PaymentMethodType = 'Transferencia (VES)';
    
    setNewPaymentSplits([{ id: `split-${Date.now()}`, amount: 0, currency: initialCurrency, paymentMethod: initialPaymentMethod, paidToBranchId: initialBranchId, paidToAccountId: initialAccountId, referenceNumber: ''}]);
    setCreditNoteTargetInvoiceId('');
    setApplyCustomerCredit(false);
  };

  const handleAddSplit = (formType: 'new' | 'edit') => {
    const activeBranch = getActiveBranchId();
    const initialBranchId = activeBranch || (availableBranches.length > 0 ? availableBranches[0].id : '');
    const initialAccountId: AccountType = 'vesElectronic';
    const initialCurrency: 'VES' | 'USD' = 'VES';
    const initialPaymentMethod: PaymentMethodType = 'Transferencia (VES)';
    
    const newSplit: PaymentSplit = { id: `split-${Date.now()}-${(formType === 'new' ? newPaymentSplits : editPaymentSplits).length}`, amount: 0, currency: initialCurrency, paymentMethod: initialPaymentMethod, paidToBranchId: initialBranchId, paidToAccountId: initialAccountId, referenceNumber: '' };
    if (formType === 'new') setNewPaymentSplits(prev => [...prev, newSplit]);
    else setEditPaymentSplits(prev => [...prev, newSplit]);
  };

  const handleRemoveSplit = (id: string, formType: 'new' | 'edit') => {
    if (formType === 'new') setNewPaymentSplits(prev => prev.filter(s => s.id !== id));
    else setEditPaymentSplits(prev => prev.filter(s => s.id !== id));
  };

  const handleSplitChange = (id: string, field: keyof Omit<PaymentSplit, 'id'>, value: string | number, formType: 'new' | 'edit') => {
    const listSetter = formType === 'new' ? setNewPaymentSplits : setEditPaymentSplits;
    listSetter(prevList => prevList.map(split => {
      if (split.id === id) {
        let updatedSplit = { ...split, [field]: value };

        if (field === 'currency') {
          const newCurrency = value as 'USD' | 'VES';
          if (newCurrency === 'USD') {
            updatedSplit.paymentMethod = 'Efectivo USD';
            updatedSplit.paidToAccountId = 'usdCash';
          } else { // VES
            if (updatedSplit.paymentMethod === 'Efectivo USD' || updatedSplit.paymentMethod === 'Otro') { // Reset if coming from USD or 'Otro'
                updatedSplit.paymentMethod = 'Transferencia (VES)';
                updatedSplit.paidToAccountId = 'vesElectronic';
            } else if (updatedSplit.paymentMethod === 'Efectivo VES') {
                updatedSplit.paidToAccountId = 'vesCash';
            } else { // For Pago Movil or Transferencia
                updatedSplit.paidToAccountId = 'vesElectronic';
            }
          }
        } else if (field === 'paymentMethod') {
          const newMethod = value as PaymentMethodType;
          if (updatedSplit.currency === 'VES') {
            if (newMethod === 'Pago Móvil (VES)' || newMethod === 'Transferencia (VES)') {
              updatedSplit.paidToAccountId = 'vesElectronic';
            } else if (newMethod === 'Efectivo VES') {
              updatedSplit.paidToAccountId = 'vesCash';
            }
          } else if (updatedSplit.currency === 'USD') {
             updatedSplit.paymentMethod = 'Efectivo USD'; // Enforce
             updatedSplit.paidToAccountId = 'usdCash';
          }
        }
        if (field === 'paidToBranchId') {
            if (updatedSplit.currency === 'USD') {
                 updatedSplit.paymentMethod = 'Efectivo USD';
                 updatedSplit.paidToAccountId = 'usdCash';
            } else if (updatedSplit.currency === 'VES') {
                if (updatedSplit.paymentMethod === 'Efectivo VES') {
                    updatedSplit.paidToAccountId = 'vesCash';
                } else { 
                    updatedSplit.paymentMethod = 'Transferencia (VES)';
                    updatedSplit.paidToAccountId = 'vesElectronic';
                }
            }
        }
        return updatedSplit;
      }
      return split;
    }));
  };


  const handleAddItemOrChange = (formType: 'new' | 'edit', itemType: 'items' | 'changes' | 'samples') => {
    const emptyItem: SaleItem = { productId: '', productName: '', quantity: 1, unitPrice: 0, subtotal: 0, sourceBranchId: '', sourceBranchName: '' };
    if (formType === 'new') {
      if (itemType === 'items') setNewSaleItems(prev => [...prev, emptyItem]);
      else if (itemType === 'changes') setNewSaleChanges(prev => [...prev, emptyItem]);
      else if (itemType === 'samples') setNewSampleItems(prev => [...prev, emptyItem]);
    } else {
      if (itemType === 'items') setEditSaleItems(prev => [...prev, emptyItem]);
      else if (itemType === 'changes') setEditSaleChanges(prev => [...prev, emptyItem]);
      else if (itemType === 'samples') setEditSampleItems(prev => [...prev, emptyItem]);
    }
  };

  const handleRemoveItemOrChange = (index: number, formType: 'new' | 'edit', itemType: 'items' | 'changes' | 'samples') => {
    const currentListSetter = formType === 'new'
      ? (itemType === 'items' ? setNewSaleItems : itemType === 'changes' ? setNewSaleChanges : setNewSampleItems)
      : (itemType === 'items' ? setEditSaleItems : itemType === 'changes' ? setEditSaleChanges : setEditSampleItems);

    currentListSetter(prevList => {
      const newList = prevList.filter((_, i) => i !== index);
      if (newList.length === 0 && (itemType === 'items' || itemType === 'changes' || itemType === 'samples')) {
        return [{ productId: '', productName: '', quantity: 1, unitPrice: 0, subtotal: 0, sourceBranchId: '', sourceBranchName: '' }];
      }
      return newList;
    });
  };

  const handleItemOrChangeValue = (
    index: number,
    field: keyof Omit<SaleItem, 'subtotal'>,
    value: string | number,
    formType: 'new' | 'edit',
    itemType: 'items' | 'changes' | 'samples'
  ) => {
    const listSetter = formType === 'new'
      ? (itemType === 'items' ? setNewSaleItems : itemType === 'changes' ? setNewSaleChanges : setNewSampleItems)
      : (itemType === 'items' ? setEditSaleItems : itemType === 'changes' ? setEditSaleChanges : setEditSampleItems);

    listSetter(prevList => {
      const newList = [...prevList];
      const updatedItem = { ...newList[index] };

      if (field === 'productId') {
        const product = availableProducts.find(p => p.id === value);
        updatedItem.productId = product ? product.id : '';
        updatedItem.productName = product ? product.name : '';
        
        let priceToSet = 0;
        if (product) {
          if (itemType === 'items') {
            priceToSet = product.unitPrice;
          } else if (itemType === 'changes') {
            const recipe = allRecipes.find(r => r.name === product.name);
            priceToSet = recipe ? recipe.costPerUnit : 0;
          }
        }
        
        updatedItem.unitPrice = itemType === 'samples' ? 0 : priceToSet;
        updatedItem.sourceBranchId = product?.sourceBranchId || '';
        updatedItem.sourceBranchName = product?.sourceBranchName || '';

      } else if (field === 'quantity') {
        updatedItem.quantity = Number(value) >= 0 ? Number(value) : 0;
      } else if (field === 'unitPrice' && itemType !== 'samples') {
        updatedItem.unitPrice = Number(value) >=0 ? Number(value) : 0;
      } else if (field === 'productName') {
        updatedItem.productName = value as string;
      }

      updatedItem.subtotal = itemType === 'samples' ? 0 : parseFloat((updatedItem.unitPrice * updatedItem.quantity).toFixed(4));
      newList[index] = updatedItem;
      return newList;
    });
  };

  const validateAndUpdateStock = (
    itemsSold: SaleItem[],
    itemsReturned: SaleItem[],
    itemsSampled: SaleItem[],
    isEdit: boolean,
    originalSale?: Sale | null
  ): { success: boolean; itemsPerBranch: SaleBranchDetail[] } => {
    const stockChanges = new Map<string, number>(); // Key: `${branchId}-${productId}`

    const updateStockChange = (productId: string, branchId: string, quantity: number) => {
      if (!productId || !branchId) return;
      const key = `${branchId}-${productId}`;
      stockChanges.set(key, (stockChanges.get(key) || 0) + quantity);
    };

    if (isEdit && originalSale) {
      originalSale.itemsPerBranch.forEach(branchDetail => {
        branchDetail.items.forEach(item => updateStockChange(item.productId, branchDetail.branchId, item.quantity));
      });
      (originalSale.samples || []).forEach(item => updateStockChange(item.productId, item.sourceBranchId, item.quantity));
      (originalSale.changes || []).forEach(item => updateStockChange(item.productId, item.sourceBranchId, -item.quantity));
    }
    
    itemsSold.forEach(item => updateStockChange(item.productId, item.sourceBranchId, -item.quantity));
    itemsSampled.forEach(item => updateStockChange(item.productId, item.sourceBranchId, -item.quantity));
    itemsReturned.forEach(item => updateStockChange(item.productId, item.sourceBranchId, item.quantity));
    
    for (const [key, netChange] of stockChanges.entries()) {
      if (netChange !== 0) { 
        const [branchId, productId] = key.split('-');
        let branchProducts = loadProductsForBranch(branchId);
        const productIndex = branchProducts.findIndex(p => p.id === productId);
        
        if (productIndex === -1 && netChange < 0) {
          const productName = itemsSold.find(i=>i.productId === productId)?.productName || 'Producto desconocido';
          const branchName = availableBranches.find(b=>b.id === branchId)?.name || 'Sede desconocida';
          toast({ title: "Error de Producto", description: `Producto ${productName} no encontrado en sede ${branchName}.`, variant: "destructive" });
          return { success: false, itemsPerBranch: [] };
        }
        
        const currentStock = productIndex !== -1 ? branchProducts[productIndex].stock : 0;
        if (currentStock + netChange < 0) {
          const productName = branchProducts[productIndex].name;
          const branchName = branchProducts[productIndex].sourceBranchName;
          toast({ title: "Error de Stock", description: `Stock insuficiente para ${productName} en sede ${branchName}. Disp: ${currentStock}, Cambio Neto Req: ${netChange}.`, variant: "destructive", duration: 7000 });
          return { success: false, itemsPerBranch: [] };
        }
      }
    }

    for (const [key, netChange] of stockChanges.entries()) {
      if (netChange === 0) continue;
      const [branchId, productId] = key.split('-');
      let branchProducts = loadProductsForBranch(branchId);
      const productIndex = branchProducts.findIndex(p => p.id === productId);

      if (productIndex !== -1) {
        branchProducts[productIndex].stock += netChange;
        branchProducts[productIndex].lastUpdated = format(new Date(), "yyyy-MM-dd");
      } else if (netChange > 0) {
         const allItems = [...itemsSold, ...itemsReturned, ...itemsSampled];
         const itemInfo = allItems.find(i => i.productId === productId);
         if (itemInfo) {
             const originalProductInfo = availableProducts.find(p => p.id === productId);
             branchProducts.push({
                id: productId, name: itemInfo.productName, category: originalProductInfo?.category || 'General',
                stock: netChange, unitPrice: itemInfo.unitPrice, lastUpdated: format(new Date(), "yyyy-MM-dd"),
                image: originalProductInfo?.image || 'https://placehold.co/40x40.png', aiHint: originalProductInfo?.aiHint || 'producto panaderia',
                sourceBranchId: branchId, sourceBranchName: availableBranches.find(b => b.id === branchId)?.name || 'Desconocida'
            });
         }
      }
      saveProductsDataForBranch(branchId, branchProducts);
    }

    setAvailableProducts(loadAllProductsFromAllBranches());

    const saleItemsPerBranch: SaleBranchDetail[] = [];
    const itemsGroupedByBranch: { [branchId: string]: SaleItem[] } = {};
    
    itemsSold.filter(i => i.productId && i.sourceBranchId).forEach(item => {
      const branchId = item.sourceBranchId;
      if (!itemsGroupedByBranch[branchId]) itemsGroupedByBranch[branchId] = [];
      itemsGroupedByBranch[branchId].push(item);
    });
    
    const changesSubtotalByBranch: { [branchId: string]: number } = {};
    itemsReturned.filter(i => i.productId && i.sourceBranchId).forEach(item => {
        const branchId = item.sourceBranchId;
        changesSubtotalByBranch[branchId] = (changesSubtotalByBranch[branchId] || 0) + item.subtotal;
    });

    const allInvolvedBranches = new Set([...Object.keys(itemsGroupedByBranch), ...Object.keys(changesSubtotalByBranch)]);
    
    allInvolvedBranches.forEach(branchId => {
        const branchName = availableBranches.find(b => b.id === branchId)?.name || 'Sede Desconocida';
        const soldItemsForBranch = itemsGroupedByBranch[branchId] || [];
        const soldSubtotal = soldItemsForBranch.reduce((sum, item) => sum + item.subtotal, 0);
        const returnedSubtotal = changesSubtotalByBranch[branchId] || 0;
        
        saleItemsPerBranch.push({
            branchId,
            branchName,
            items: soldItemsForBranch,
            totalAmount: soldSubtotal - returnedSubtotal,
            amountPaidUSD: 0
        });
    });

    return { success: true, itemsPerBranch: saleItemsPerBranch };
  };

  const handleAddSale = async () => {
    setIsSubmitting(true);

    const validSaleItems = newSaleItems.filter(item => item.productId && item.quantity > 0 && item.unitPrice >= 0 && item.sourceBranchId);
    const validChangeItems = newSaleChanges.filter(item => item.productId && item.quantity > 0 && item.unitPrice >= 0 && item.sourceBranchId);
    const validSampleItems = newSampleItems.filter(item => item.productId && item.quantity > 0 && item.sourceBranchId);

    if (!newSaleDate || !newSelectedCustomerId || (validSaleItems.length === 0 && validChangeItems.length === 0 && validSampleItems.length === 0)) {
        toast({ title: "Error de Validación", description: "Fecha, cliente y al menos un ítem, cambio o muestra son obligatorios.", variant: "destructive" });
        setIsSubmitting(false); return;
    }
    const totalInvoiceAmount = calculateTotalAmount(validSaleItems, validChangeItems);
    if (totalInvoiceAmount < 0 && !creditNoteTargetInvoiceId) {
        toast({ title: "Acción Requerida", description: "Para ventas con total negativo (notas de crédito), debe seleccionar una factura pendiente a la cual aplicar el crédito.", variant: "destructive" });
        setIsSubmitting(false); return;
    }

    const saleId = `SALE${Date.now().toString().slice(-4)}${Math.floor(Math.random() * 100)}`;
    const saleTimestamp = new Date().toISOString();
    
    const stockValidationResult = validateAndUpdateStock(validSaleItems, validChangeItems, validSampleItems, false);
    if (!stockValidationResult.success) {
        setIsSubmitting(false); return; 
    }

    const newSaleEntry: Sale = {
      id: saleId,
      date: format(newSaleDate, "yyyy-MM-dd"),
      itemsPerBranch: stockValidationResult.itemsPerBranch,
      changes: validChangeItems.length > 0 ? validChangeItems : undefined,
      samples: validSampleItems.length > 0 ? validSampleItems.map(s => ({...s, unitPrice: 0, subtotal: 0})) : undefined,
      customerId: newSelectedCustomerId,
      customerName: availableCustomers.find(c => c.id === newSelectedCustomerId)?.name || 'Desconocido',
      totalAmount: totalInvoiceAmount,
      paymentMethod: totalInvoiceAmount <= 0 ? 'Pagado' : newPaymentMethod,
      dueDate: (newPaymentMethod === 'Crédito' && totalInvoiceAmount > 0) ? format(addDays(newSaleDate, 7), "yyyy-MM-dd") : undefined,
      amountPaidUSD: 0, 
      timestamp: saleTimestamp,
      notes: newSaleNotes.trim() || undefined,
      creditNoteTargetInvoiceId: totalInvoiceAmount < 0 ? creditNoteTargetInvoiceId : undefined,
    };
    
    let currentSales = loadFromLocalStorage<Sale[]>(KEYS.SALES);
    currentSales.push(newSaleEntry);
    saveSalesData(currentSales.sort((a,b) => compareDesc(parseISO(a.timestamp || a.date), parseISO(b.timestamp || b.date))));
    
    const customer = initialCustomersDataGlobal.find(c => c.id === newSelectedCustomerId);
    if (customer) {
        const updatedCustomers = initialCustomersDataGlobal.map(c => 
            c.id === newSelectedCustomerId ? { ...c, lastOrder: newSaleEntry.date } : c
        );
        saveCustomersData(updatedCustomers);
    }

    const paymentsToCreate: Payment[] = [];
    const parentId = `PAY-P-${saleId.slice(-6)}`;
    
    if (applyCustomerCredit && customerBalance < -0.01 && totalInvoiceAmount > 0) {
        const creditToApply = Math.min(totalInvoiceAmount, Math.abs(customerBalance));
        if (creditToApply > 0) {
            const creditPayment: Payment = {
                id: `PAY-CREDIT-${saleId}`, parentPaymentId: parentId, customerId: newSelectedCustomerId,
                customerName: newSaleEntry.customerName, paymentDate: newSaleEntry.date,
                amountPaidInput: creditToApply, currencyPaidInput: 'USD',
                amountAppliedToDebtUSD: creditToApply, paymentMethod: 'Crédito a Favor',
                status: 'verificado', appliedToInvoiceId: saleId, paymentSource: 'invoice',
                verifiedBy: 'Sistema', verificationDate: saleTimestamp, creationTimestamp: saleTimestamp,
                paidToBranchId: newSaleEntry.itemsPerBranch[0]?.branchId || availableBranches[0]?.id || '',
                paidToAccountId: 'usdCash',
            };
            paymentsToCreate.push(creditPayment);
            updateGlobalSaleDataAndFinances(creditPayment, 'add');
        }
    }
    
    if (newPaymentMethod === 'Pagado' && totalInvoiceAmount > 0) {
        newPaymentSplits.forEach((split, index) => {
            if (split.amount > 0) {
                const rate = split.currency === 'VES' ? (split.exchangeRateAtPayment || exchangeRate || 1) : 1;
                const amountInUSD = split.currency === 'USD' ? split.amount : (rate > 0 ? split.amount / rate : 0);
                const isVerified = split.paymentMethod === 'Efectivo USD' || split.paymentMethod === 'Efectivo VES';
                const payment = {
                    id: `PAY-SALE-${saleId}-${index}`, parentPaymentId: parentId, customerId: newSelectedCustomerId,
                    customerName: newSaleEntry.customerName, paymentDate: newSaleEntry.date,
                    amountPaidInput: split.amount, currencyPaidInput: split.currency,
                    exchangeRateAtPayment: split.exchangeRateAtPayment, amountAppliedToDebtUSD: amountInUSD,
                    paymentMethod: split.paymentMethod, status: isVerified ? 'verificado' : 'pendiente de verificación' as PaymentStatus,
                    appliedToInvoiceId: saleId, paymentSource: 'invoice' as PaymentSource,
                    verifiedBy: isVerified ? userProfileData.fullName : undefined,
                    verificationDate: isVerified ? saleTimestamp : undefined,
                    creationTimestamp: saleTimestamp, paidToBranchId: split.paidToBranchId,
                    paidToAccountId: split.paidToAccountId, referenceNumber: split.referenceNumber,
                };
                paymentsToCreate.push(payment);
                if (payment.status === 'verificado') {
                    updateGlobalSaleDataAndFinances(payment, 'add');
                }
            }
        });
    }
    
    if (totalInvoiceAmount < 0) {
      const creditNotePayment: Payment = {
          id: `PAY-CN-${saleId}`, parentPaymentId: parentId, customerId: newSelectedCustomerId,
          customerName: newSaleEntry.customerName, paymentDate: newSaleEntry.date,
          amountPaidInput: Math.abs(totalInvoiceAmount), currencyPaidInput: 'USD',
          amountAppliedToDebtUSD: Math.abs(totalInvoiceAmount), paymentMethod: 'Nota de Crédito',
          status: 'verificado', appliedToInvoiceId: creditNoteTargetInvoiceId, paymentSource: 'invoice',
          verifiedBy: 'Sistema', verificationDate: saleTimestamp, creationTimestamp: saleTimestamp,
          paidToBranchId: newSaleEntry.itemsPerBranch[0]?.branchId || availableBranches[0]?.id || '', // Heurística
          paidToAccountId: 'usdCash', notes: `Aplicado desde NC: ${saleId}`
      };
      paymentsToCreate.push(creditNotePayment);
      updateGlobalSaleDataAndFinances(creditNotePayment, 'add');
    }
    
    if (paymentsToCreate.length > 0) {
        let allPayments = loadFromLocalStorage<Payment[]>(KEYS.PAYMENTS);
        allPayments.push(...paymentsToCreate);
        savePaymentsData(allPayments);
    }

    toast({ title: totalInvoiceAmount < 0 ? "Nota de Crédito Creada" : "Venta Registrada", description: `La operación se ha registrado exitosamente.` });
    setIsAddSaleDialogOpen(false); resetAddForm(); setIsSubmitting(false);
  };


  const handleOpenEditDialog = (sale: Sale) => {
    setEditingSale(sale);
    setOriginalSaleForEdit(JSON.parse(JSON.stringify(sale)));
    setEditSaleDate(parseISO(sale.date));
    const flatItems: SaleItem[] = [];
    sale.itemsPerBranch.forEach(branchDetail => {
        branchDetail.items.forEach(item => {
            flatItems.push({...item, sourceBranchId: branchDetail.branchId, sourceBranchName: branchDetail.branchName});
        });
    });
    setEditSaleItems(flatItems.length > 0 ? flatItems : [{ productId: '', productName: '', quantity: 1, unitPrice: 0, subtotal: 0, sourceBranchId: '', sourceBranchName: '' }]);
    setEditSaleChanges(sale.changes && sale.changes.length > 0 ? sale.changes.map(item => ({ ...item })) : [{ productId: '', productName: '', quantity: 1, unitPrice: 0, subtotal: 0, sourceBranchId: '', sourceBranchName: '' }]);
    setEditSampleItems(sale.samples && sale.samples.length > 0 ? sale.samples.map(item => ({ ...item, unitPrice: 0, subtotal: 0 })) : [{ productId: '', productName: '', quantity: 1, unitPrice: 0, subtotal: 0, sourceBranchId: '', sourceBranchName: '' }]);
    setEditSelectedCustomerId(sale.customerId || '');
    setEditPaymentMethod(sale.paymentMethod);
    setEditSaleNotes(sale.notes || '');

    setCreditNoteTargetInvoiceId(sale.creditNoteTargetInvoiceId || '');
    
    let initialSplits: PaymentSplit[] = [];
    if (sale.paymentSplits && sale.paymentSplits.length > 0) {
        initialSplits = JSON.parse(JSON.stringify(sale.paymentSplits));
    } else if (sale.paymentMethod === 'Pagado') { 
        const activeBranch = getActiveBranchId();
        const initialBranchId = activeBranch || (availableBranches.length > 0 ? availableBranches[0].id : '');
        let initialAccountId: AccountType = 'vesElectronic';
        let initialCurrency: 'VES' | 'USD' = 'VES';
        let initialPaymentMethod: PaymentMethodType = 'Transferencia (VES)';

        if (initialBranchId === 'panaderia_principal') {
          initialAccountId = 'vesElectronic';
          initialCurrency = 'VES';
          initialPaymentMethod = 'Transferencia (VES)';
        } else {
          initialAccountId = 'usdCash';
          initialCurrency = 'USD';
          initialPaymentMethod = 'Efectivo USD';
        }
        initialSplits = [{ id: `split-edit-${Date.now()}`, amount: sale.totalAmount, currency: initialCurrency, paymentMethod: initialPaymentMethod, paidToBranchId: initialBranchId, paidToAccountId: initialAccountId, referenceNumber: ''}];
    } else { 
        const activeBranch = getActiveBranchId();
        const initialBranchId = activeBranch || (availableBranches.length > 0 ? availableBranches[0].id : '');
        let initialAccountId: AccountType = 'vesElectronic';
        let initialCurrency: 'VES' | 'USD' = 'VES';
        let initialPaymentMethod: PaymentMethodType = 'Transferencia (VES)';
         if (initialBranchId === 'panaderia_principal') {
          initialAccountId = 'vesElectronic';
          initialCurrency = 'VES';
          initialPaymentMethod = 'Transferencia (VES)';
        } else {
          initialAccountId = 'usdCash';
          initialCurrency = 'USD';
          initialPaymentMethod = 'Efectivo USD';
        }
        initialSplits = [{ id: `split-edit-${Date.now()}`, amount: 0, currency: initialCurrency, paymentMethod: initialPaymentMethod, paidToBranchId: initialBranchId, paidToAccountId: initialAccountId, referenceNumber: ''}];
    }
    setEditPaymentSplits(initialSplits);
    setIsEditSaleDialogOpen(true);
  };

  const handleUpdateSale = () => {
    if (!editingSale || !originalSaleForEdit) return;
    setIsSubmitting(true);
  
    const validSaleItems = editSaleItems.filter(item => item.productId && item.quantity > 0 && item.unitPrice >= 0 && item.sourceBranchId);
    const validChangeItems = editSaleChanges.filter(item => item.productId && item.quantity > 0 && item.unitPrice >= 0 && item.sourceBranchId);
    const validSampleItems = editSampleItems.filter(item => item.productId && item.quantity > 0 && item.sourceBranchId);
  
    if (!editSaleDate || !editSelectedCustomerId) {
      toast({ title: "Error de Validación", description: "Fecha y cliente son obligatorios.", variant: "destructive" });
      setIsSubmitting(false); return;
    }
    
    // Primero, revertir los efectos de la venta original
    const stockRevertResult = validateAndUpdateStock([], [], [], true, originalSaleForEdit);
    if (!stockRevertResult.success) {
      toast({ title: "Error Crítico", description: "No se pudo revertir el stock de la venta original. La edición ha sido cancelada para prevenir inconsistencias.", variant: "destructive", duration: 8000 });
      setIsSubmitting(false); return;
    }
    
    // Borrar pagos y transferencias asociadas a la venta original
    let currentPayments = loadFromLocalStorage<Payment[]>(KEYS.PAYMENTS);
    const paymentsForOriginalSale = currentPayments.filter(p => p.appliedToInvoiceId === originalSaleForEdit.id);
    paymentsForOriginalSale.forEach(p => {
        if (p.status === 'verificado') {
            updateGlobalSaleDataAndFinances(p, 'subtract');
        }
    });
    currentPayments = currentPayments.filter(p => p.appliedToInvoiceId !== originalSaleForEdit.id);
    savePaymentsData(currentPayments);

    // Ahora aplicar los nuevos cambios
    const stockValidationResult = validateAndUpdateStock(validSaleItems, validChangeItems, validSampleItems, false);
    if (!stockValidationResult.success) {
        // Re-aplicar el stock de la venta original si la nueva validación falla
        validateAndUpdateStock(
            originalSaleForEdit.itemsPerBranch.flatMap(bd => bd.items),
            originalSaleForEdit.changes || [],
            originalSaleForEdit.samples || [],
            false
        );
        toast({ title: "Error de Stock", description: "No se pudo actualizar el stock con los nuevos datos de la venta. Cambios revertidos.", variant: "destructive" });
        setIsSubmitting(false); return;
    }

    const totalInvoiceAmount = calculateTotalAmount(validSaleItems, validChangeItems);
  
    const updatedSaleEntry: Sale = {
      ...originalSaleForEdit,
      date: format(editSaleDate, "yyyy-MM-dd"),
      itemsPerBranch: stockValidationResult.itemsPerBranch,
      changes: validChangeItems.length > 0 ? validChangeItems : undefined,
      samples: validSampleItems.length > 0 ? validSampleItems.map(s => ({...s, unitPrice: 0, subtotal: 0})) : undefined,
      customerId: editSelectedCustomerId,
      customerName: availableCustomers.find(c => c.id === editSelectedCustomerId)?.name || 'Desconocido',
      totalAmount: totalInvoiceAmount,
      paymentMethod: editPaymentMethod,
      dueDate: (editPaymentMethod === 'Crédito' && totalInvoiceAmount > 0) ? format(addDays(editSaleDate, 7), "yyyy-MM-dd") : undefined,
      amountPaidUSD: 0, // Se recalculará con los nuevos pagos
      notes: editSaleNotes.trim() || undefined,
      timestamp: new Date().toISOString(), // Actualizar el timestamp
    };
  
    // Guardar la venta actualizada
    let currentSales = loadFromLocalStorage<Sale[]>(KEYS.SALES);
    currentSales = currentSales.filter(s => s.id !== originalSaleForEdit.id);
    currentSales.push(updatedSaleEntry);
    saveSalesData(currentSales.sort((a,b) => compareDesc(parseISO(a.timestamp || a.date), parseISO(b.timestamp || b.date))));
  
    // Procesar nuevos pagos si existen
    if (editPaymentMethod === 'Pagado' && totalInvoiceAmount > 0) {
      const paymentsToCreate: Payment[] = [];
      const parentId = `PAY-P-EDIT-${updatedSaleEntry.id.slice(-6)}`;
      editPaymentSplits.forEach((split, index) => {
        if (split.amount > 0) {
            const rate = split.currency === 'VES' ? (split.exchangeRateAtPayment || exchangeRate || 1) : 1;
            const amountInUSD = split.currency === 'USD' ? split.amount : (rate > 0 ? split.amount / rate : 0);
            const isVerified = split.paymentMethod === 'Efectivo USD' || split.paymentMethod === 'Efectivo VES';
            const payment = {
                id: `PAY-SALE-EDIT-${updatedSaleEntry.id}-${index}`, parentPaymentId: parentId, customerId: editSelectedCustomerId,
                customerName: updatedSaleEntry.customerName, paymentDate: updatedSaleEntry.date,
                amountPaidInput: split.amount, currencyPaidInput: split.currency,
                exchangeRateAtPayment: split.exchangeRateAtPayment, amountAppliedToDebtUSD: amountInUSD,
                paymentMethod: split.paymentMethod, status: isVerified ? 'verificado' : 'pendiente de verificación' as PaymentStatus,
                appliedToInvoiceId: updatedSaleEntry.id, paymentSource: 'invoice' as PaymentSource,
                verifiedBy: isVerified ? userProfileData.fullName : undefined,
                verificationDate: isVerified ? updatedSaleEntry.timestamp : undefined,
                creationTimestamp: updatedSaleEntry.timestamp, paidToBranchId: split.paidToBranchId,
                paidToAccountId: split.paidToAccountId, referenceNumber: split.referenceNumber,
            };
            paymentsToCreate.push(payment);
            if (payment.status === 'verificado') {
                updateGlobalSaleDataAndFinances(payment, 'add');
            }
        }
      });
      if(paymentsToCreate.length > 0) {
        let allPayments = loadFromLocalStorage<Payment[]>(KEYS.PAYMENTS);
        allPayments.push(...paymentsToCreate);
        savePaymentsData(allPayments);
      }
    }
  
    toast({ title: "Venta Actualizada", description: "La venta ha sido modificada y los datos actualizados." });
    setIsEditSaleDialogOpen(false);
    setEditingSale(null);
    setOriginalSaleForEdit(null);
    setIsSubmitting(false);
  };
  

  const handleOpenDeleteDialog = (saleId: string) => { setSaleToDeleteId(saleId); setIsDeleteConfirmDialogOpen(true); };
  
  const handleConfirmDelete = () => {
    if (!saleToDeleteId) return;
    setIsSubmitting(true);
  
    const saleToDelete = allSales.find(s => s.id === saleToDeleteId);
    if (!saleToDelete) {
      toast({ title: "Error", description: "No se pudo encontrar la venta para eliminar.", variant: "destructive" });
      setIsSubmitting(false);
      return;
    }
  
    // 1. Revertir el stock
    const stockRevertResult = validateAndUpdateStock([], [], [], true, saleToDelete);
    if (!stockRevertResult.success) {
      toast({ title: "Error Crítico de Stock", description: "No se pudo revertir el stock. La eliminación ha sido cancelada.", variant: "destructive" });
      setIsSubmitting(false);
      return;
    }
  
    // 2. Revertir los pagos y sus efectos financieros
    let currentPayments = loadFromLocalStorage<Payment[]>(KEYS.PAYMENTS);
    const paymentsForSale = currentPayments.filter(p => p.appliedToInvoiceId === saleToDelete.id);
    paymentsForSale.forEach(p => {
        if(p.status === 'verificado') {
            updateGlobalSaleDataAndFinances(p, 'subtract');
        }
    });
    const updatedPayments = currentPayments.filter(p => p.appliedToInvoiceId !== saleToDelete.id);
    savePaymentsData(updatedPayments);

    // 3. Eliminar la venta
    const updatedSales = allSales.filter(s => s.id !== saleToDeleteId);
    saveSalesData(updatedSales);
  
    toast({ title: "Venta Eliminada", description: "La venta y todas sus transacciones asociadas han sido eliminadas." });
    setSaleToDeleteId(null);
    setIsDeleteConfirmDialogOpen(false);
    setIsSubmitting(false);
  };

  const handleOpenViewDialog = (sale: Sale) => {
    setSaleToViewDetails(sale);
    setIsViewSaleDialogOpen(true);
  };
  
  const renderItemsTable = (
    data: SaleBranchDetail | SaleItem[] | undefined,
    type: 'branchDetail' | 'changes' | 'samples'
  ) => {
    if (!data || (Array.isArray(data) && data.length === 0) || (Array.isArray(data) && data.every(i => !i.productId))) return null;

    let items: SaleItem[] = [];
    let title = '';

    if (type === 'branchDetail' && !Array.isArray(data)) {
        title = `Artículos de Sede: ${data.branchName}`;
        items = data.items;
    } else if (type === 'changes' && Array.isArray(data)) {
        title = "Cambios/Devoluciones";
        items = data.filter(i => i.productId);
    } else if (type === 'samples' && Array.isArray(data)) {
        title = "Muestras/Regalos";
        items = data.filter(i => i.productId);
    }

    if (items.length === 0) return null;

    return (
      <div className="mt-2">
        <p className="text-xs font-semibold text-muted-foreground mb-1">{title}</p>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Producto (Sede Origen)</TableHead>
              <TableHead className="text-right">Cant.</TableHead>
              {type !== 'samples' && <TableHead className="text-right">P.Unit(USD)</TableHead>}
              {type !== 'samples' && <TableHead className="text-right">Subtotal(USD)</TableHead>}
            </TableRow>
          </TableHeader>
          <TableBody>
            {items.map((item, index) => (
              <TableRow key={`view-item-${type}-${item.productId}-${index}`}>
                <TableCell>{item.productName} <span className="text-xs text-muted-foreground">({item.sourceBranchName})</span></TableCell>
                <TableCell className="text-right">{item.quantity}</TableCell>
                {type !== 'samples' && (
                  <TableCell className="text-right"><FormattedNumber value={item.unitPrice} prefix="$" /></TableCell>
                )}
                {type !== 'samples' && (
                  <TableCell className="text-right">
                    <FormattedNumber value={item.subtotal} prefix={type === 'changes' ? '-$' : '$'} />
                  </TableCell>
                )}
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>
    );
  };

  const generateInvoicePDF = (sale: Sale) => {
    const customer = availableCustomers.find(c => c.id === sale.customerId);
    const doc = new jsPDF() as jsPDFWithAutoTable;
    
    const creditPayment = initialPaymentsDataGlobal.find(p => p.appliedToInvoiceId === sale.id && p.paymentMethod === 'Crédito a Favor');
    const creditApplied = creditPayment ? creditPayment.amountAppliedToDebtUSD : 0;
    const finalAmountToPay = sale.totalAmount - creditApplied;


    doc.setFontSize(18);
    doc.text("Panificadora Valladares", 14, 22);
    doc.setFontSize(12);
    doc.text("Factura (Global)", 14, 30);
    doc.setFontSize(11);
    doc.text(`Factura #: ${sale.id}`, 14, 38);
    doc.text(`Fecha: ${sale.date ? format(parseISO(sale.date), "dd/MM/yy", { locale: es }) : '-'} ${sale.timestamp && isValid(parseISO(sale.timestamp)) ? format(parseISO(sale.timestamp), "hh:mm a", { locale: es }) : ''}`, 14, 44);
    let currentY = 54;
    if (customer) { 
        doc.text(`Cliente: ${customer.name}`, 14, currentY); 
        currentY += 6;
        doc.text(`Contacto: ${customer.contact || 'N/A'}`, 14, currentY); 
        currentY += 6;
        doc.text(`Email: ${customer.email || 'N/A'}`, 14, currentY);
        currentY += 6;
    } else { 
        doc.text("Cliente: Consumidor Final", 14, currentY); 
        currentY += 6;
    }
    
    if (sale.notes) {
      currentY += 4;
      doc.setFontSize(11);
      doc.setFont("helvetica", "bold");
      doc.text("Observaciones:", 14, currentY);
      currentY += 6;
      doc.setFont("helvetica", "normal");
      doc.setFontSize(10);
      const splitNotes = doc.splitTextToSize(sale.notes, 180); // 180mm width
      doc.text(splitNotes, 14, currentY);
      currentY += (splitNotes.length * 5); // Adjust Y based on number of lines
    }
    currentY += 4;

    sale.itemsPerBranch.forEach(branchDetail => {
        doc.setFontSize(12); doc.setFont("helvetica", "bold"); doc.text(`Artículos de Sede: ${branchDetail.branchName}`, 14, currentY);
        doc.setFont("helvetica", "normal"); currentY += 7;
        const soldItemsHead = [["Producto", "Cant.", "P.Unit(USD)", "Subtotal(USD)"]];
        const soldItemsBody: any[][] = branchDetail.items.map(item => ([ item.productName, item.quantity, `$${item.unitPrice.toFixed(2)}`, `$${item.subtotal.toFixed(2)}` ]));
        doc.autoTable({ startY: currentY, head: soldItemsHead, body: soldItemsBody, theme: 'striped', headStyles: { fillColor: [224, 122, 95] } });
        currentY = (doc as any).lastAutoTable.finalY + 10;
    });
    if (sale.changes && sale.changes.length > 0 && sale.changes.some(c => c.productId)) {
      doc.setFontSize(12); doc.setFont("helvetica", "bold"); doc.text("Cambios/Devoluciones:", 14, currentY);
      currentY += 7;
      const changesByBranch: { [branchName: string]: SaleItem[] } = {};
      sale.changes.filter(c => c.productId).forEach(change => {
        const branchName = change.sourceBranchName || 'Sede Desconocida';
        if (!changesByBranch[branchName]) changesByBranch[branchName] = [];
        changesByBranch[branchName].push(change);
      });
      Object.entries(changesByBranch).forEach(([branchName, changes]) => {
        doc.setFontSize(10); doc.setFont("helvetica", "italic"); doc.text(`Desde Sede: ${branchName}`, 14, currentY);
        currentY += 5;
        const changedItemsHead = [["Producto Devuelto", "Cant.", "P.Unit(USD)", "Subtotal Dev.(USD)"]];
        const changedItemsBody: any[][] = changes.map(item => ([ item.productName, item.quantity, `$${item.unitPrice.toFixed(2)}`, `-$${item.subtotal.toFixed(2)}` ]));
        doc.autoTable({ startY: currentY, head: changedItemsHead, body: changedItemsBody, theme: 'grid', headStyles: { fillColor: [150, 150, 150], fontSize: 9 }, bodyStyles: { fontSize: 8, textColor: [200,0,0] }, didDrawPage: () => currentY = 20 });
        currentY = (doc as any).lastAutoTable.finalY + 5;
      });
      currentY += 5;
    }
    
    if (sale.samples && sale.samples.length > 0 && sale.samples.some(s => s.productId)) {
      doc.setFontSize(12); doc.setFont("helvetica", "bold"); doc.text("Muestras/Regalos:", 14, currentY);
      currentY += 7;
      const samplesByBranch: { [branchName: string]: SaleItem[] } = {};
      sale.samples.filter(s => s.productId).forEach(sample => {
        const branchName = sample.sourceBranchName || 'Sede Desconocida';
        if (!samplesByBranch[branchName]) samplesByBranch[branchName] = [];
        samplesByBranch[branchName].push(sample);
      });

      Object.entries(samplesByBranch).forEach(([branchName, samples]) => {
        doc.setFontSize(10); doc.setFont("helvetica", "italic"); doc.text(`Desde Sede: ${branchName}`, 14, currentY);
        currentY += 5;
        const sampleItemsHead = [["Producto (Muestra)", "Cant."]];
        const sampleItemsBody: any[][] = samples.map(item => ([ item.productName, item.quantity ]));
        doc.autoTable({ startY: currentY, head: sampleItemsHead, body: sampleItemsBody, theme: 'grid', headStyles: { fillColor: [180, 180, 220], fontSize: 9 }, bodyStyles: { fontSize: 8 }, didDrawPage: () => currentY = 20 });
        currentY = (doc as any).lastAutoTable.finalY + 5;
      });
      currentY += 5; 
    }

    doc.setFont("helvetica", "normal"); 
    doc.setFontSize(12); doc.text(`Método de Pago: ${sale.paymentMethod}`, 14, currentY);
    if (sale.paymentMethod === 'Crédito' && sale.dueDate) { doc.text(`Fecha de Vencimiento: ${format(parseISO(sale.dueDate), "dd/MM/yyyy", { locale: es })}`, 14, currentY + 6); currentY +=6; }
    else if (sale.paymentMethod === 'Pagado' && sale.paymentSplits && sale.paymentSplits.length > 0) {
      currentY += 6;
      doc.setFontSize(10); doc.text("Desglose de Pagos:", 14, currentY); currentY += 5;
      sale.paymentSplits.forEach(split => {
        doc.text(`- ${split.paymentMethod}: ${split.currency === 'USD' ? '$' : 'Bs.'}${split.amount.toFixed(2)} (Sede: ${availableBranches.find(b=>b.id===split.paidToBranchId)?.name || 'N/A'}, Cta: ${accountTypeNames[split.paidToAccountId]})`, 16, currentY);
        currentY += 5;
      });
    }

    currentY += 8; 
    doc.setFontSize(12);
    doc.setFont("helvetica", "normal"); 
    doc.text(`Total Neto (USD):`, 14, currentY);
    doc.text(`$${sale.totalAmount.toFixed(2)}`, 190, currentY, { align: 'right' });
    currentY += 6;

    if (creditApplied > 0) {
      doc.text(`Crédito Aplicado (USD):`, 14, currentY);
      doc.text(`-$${creditApplied.toFixed(2)}`, 190, currentY, { align: 'right' });
      currentY += 3;
      doc.setDrawColor(0, 0, 0);
      doc.line(14, currentY, 190, currentY); // Draw line AFTER credit
      currentY += 5; // Add space after the line
    }

    doc.setFontSize(14); 
    doc.setFont("helvetica", "bold"); 
    doc.text(`Total a Pagar (USD):`, 14, currentY);
    doc.text(`$${finalAmountToPay.toFixed(2)}`, 190, currentY, { align: 'right' });

    currentY += 10;
    doc.setFont("helvetica", "normal"); 
    doc.setFontSize(10); 
    doc.setFont("helvetica", "bold"); 
    doc.text("Saldo Pendiente por Sede:", 14, currentY);
    doc.setFont("helvetica", "normal"); 
    currentY += 5;
    sale.itemsPerBranch.forEach(branchDetail => {
        const saldoSede = branchDetail.totalAmount - branchDetail.amountPaidUSD;
        doc.text(`${branchDetail.branchName}: $${saldoSede.toFixed(2)}`, 14, currentY); currentY += 5;
    });

    doc.save(`factura_global-${sale.id}.pdf`); 
    toast({ title: "Factura Global Generada", description: `Factura ${sale.id}.pdf descargada.` });
  };

  if (isLoading && availableProducts.length === 0) {
    return (<div className="flex items-center justify-center h-screen"><Loader2 className="h-12 w-12 animate-spin text-primary" /><p className="ml-4 text-lg">Cargando...</p></div>);
  }

const renderSaleDialogContent = (
    formType: 'new' | 'edit',
    currentSaleItems: SaleItem[], setSaleItems: React.Dispatch<React.SetStateAction<SaleItem[]>>,
    currentChangeItems: SaleItem[], setChangeItems: React.Dispatch<React.SetStateAction<SaleItem[]>>,
    currentSampleItems: SaleItem[], setSampleItems: React.Dispatch<React.SetStateAction<SaleItem[]>>,
    saleDate: Date | undefined, setSaleDate: React.Dispatch<React.SetStateAction<Date | undefined>>,
    selectedCustomerId: string, setSelectedCustomerIdParam: React.Dispatch<React.SetStateAction<string>>,
    paymentMethod: Sale['paymentMethod'], setPaymentMethodParam: React.Dispatch<React.SetStateAction<Sale['paymentMethod']>>,
    paymentSplitsParam: PaymentSplit[], setPaymentSplitsParam: React.Dispatch<React.SetStateAction<PaymentSplit[]>>
  ) => {
    const itemsSubtotal = calculateItemsSubtotal(currentSaleItems);
    const changesSubtotal = calculateItemsSubtotal(currentChangeItems);
    const netTotal = calculateTotalAmount(currentSaleItems, currentChangeItems);

    const creditToApply = applyCustomerCredit && customerBalance < -0.01 ? Math.min(netTotal, Math.abs(customerBalance)) : 0;
    const totalToPayAfterCredit = netTotal - creditToApply;

    const totalPaidInSplits = paymentSplitsParam.reduce((sum, split) => {
        const rate = split.currency === 'VES' ? (split.exchangeRateAtPayment || exchangeRate || 1) : 1;
        const amountInUSD = split.currency === 'USD' ? split.amount : (rate > 0 ? split.amount / rate : 0);
        return sum + amountInUSD;
    },0);
    const remainingToPay = totalToPayAfterCredit - totalPaidInSplits;

    const getPaymentMethodsForCurrency = (currency: 'USD' | 'VES'): PaymentMethodType[] => {
        if (currency === 'USD') {
            return ['Efectivo USD'];
        } else if (currency === 'VES') {
            return ['Pago Móvil (VES)', 'Transferencia (VES)', 'Efectivo VES'];
        }
        return [];
    };
    
    const getAccountsForPaymentMethod = (currency: 'USD' | 'VES', method: PaymentMethodType): AccountType[] => {
        if (currency === 'USD') {
            if (method === 'Efectivo USD') return ['usdCash'];
        } else if (currency === 'VES') {
            if (method === 'Pago Móvil (VES)' || method === 'Transferencia (VES)') return ['vesElectronic'];
            if (method === 'Efectivo VES') return ['vesCash'];
        }
        return [];
    };

    const notesValue = formType === 'new' ? newSaleNotes : editSaleNotes;
    const setNotesValue = formType === 'new' ? setNewSaleNotes : setEditSaleNotes;

    return (
      <div className="grid gap-4 py-4">
        <div className="space-y-1"><Label htmlFor={`sale_date_${formType}`}>Fecha</Label><Popover open={isSaleDatePickerOpen} onOpenChange={setIsSaleDatePickerOpen}><PopoverTrigger asChild><Button id={`sale_date_${formType}`} variant={"outline"} className={cn("w-full justify-start", !saleDate && "text-muted-foreground")} disabled={isSubmitting}><CalendarIcon className="mr-2 h-4 w-4" />{saleDate ? format(saleDate, "PPP", { locale: es }) : <span>Elige</span>}</Button></PopoverTrigger><PopoverContent className="w-auto p-0"><Calendar mode="single" selected={saleDate} onSelect={(date) => { setSaleDate(date); setIsSaleDatePickerOpen(false); }} initialFocus locale={es} disabled={isSubmitting} /></PopoverContent></Popover></div>
        <div className="space-y-1"><Label htmlFor={`customer_id_${formType}`}>Cliente</Label><Select value={selectedCustomerId} onValueChange={setSelectedCustomerIdParam} disabled={isSubmitting}><SelectTrigger id={`customer_id_${formType}`}><SelectValue placeholder="Selecciona" /></SelectTrigger><SelectContent>{availableCustomers.sort((a,b) => a.name.localeCompare(b.name)).map(c => <SelectItem key={c.id} value={c.id}>{c.name}</SelectItem>)}{availableCustomers.length === 0 && <SelectItem value="no-cust" disabled>No hay clientes</SelectItem>}</SelectContent></Select></div>
         {customerBalance < -0.01 && (
          <Alert variant="default" className="bg-green-50 dark:bg-green-900/20 border-green-200 dark:border-green-700">
            <ShieldCheck className="h-4 w-4 text-green-600 dark:text-green-400" />
            <AlertTitle className="text-green-800 dark:text-green-300">Saldo a Favor Disponible</AlertTitle>
            <AlertDescription className="text-green-700 dark:text-green-400">
              <p>Este cliente tiene un saldo a favor de <FormattedNumber value={Math.abs(customerBalance)} prefix="$" />.</p>
              <div className="flex items-center space-x-2 mt-2">
                <Checkbox id="apply_credit" checked={applyCustomerCredit} onCheckedChange={(checked) => setApplyCustomerCredit(!!checked)} disabled={netTotal <= 0} />
                <label htmlFor="apply_credit" className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70">
                  ¿Desea aplicar este saldo a favor a la factura?
                </label>
              </div>
            </AlertDescription>
          </Alert>
        )}
        <div className="space-y-2 border p-3 rounded-md max-h-60 overflow-y-auto">
            <Label className="font-medium">Ítems de la Venta</Label>
            {currentSaleItems.map((item, index) => (
                <div key={`item-${index}-${formType}`} className="grid grid-cols-12 gap-2 items-end border-b pb-2 mb-2 last:border-b-0 last:pb-0 last:mb-0">
                    <div className="col-span-12 sm:col-span-5 space-y-1">
                        {index === 0 && <Label htmlFor={`product_id_item_${index}_${formType}`} className="text-xs">Producto (Sede)</Label>}
                        <Select value={item.productId} onValueChange={(value) => handleItemOrChangeValue(index, 'productId', value, formType, 'items')} disabled={isSubmitting}>
                            <SelectTrigger id={`product_id_item_${index}_${formType}`} className="h-9"><SelectValue placeholder="Producto" /></SelectTrigger>
                            <SelectContent>
                                {vendibleProducts.map(p => <SelectItem key={p.id} value={p.id} disabled={p.stock <= 0 && !(formType === 'edit' && editingSale?.itemsPerBranch.flatMap(bd => bd.items).find(i => i.productId === p.id))}>{p.name} ({p.sourceBranchName} - Stock: {p.stock})</SelectItem>)}
                            </SelectContent>
                        </Select>
                    </div>
                    <div className="col-span-4 sm:col-span-2 space-y-1">
                        {index === 0 && <Label htmlFor={`quantity_item_${index}_${formType}`} className="text-xs">Cant.</Label>}
                        <Input id={`quantity_item_${index}_${formType}`} type="number" placeholder="Cant." value={item.quantity} onChange={(e) => handleItemOrChangeValue(index, 'quantity', e.target.value, formType, 'items')} disabled={isSubmitting || !item.productId} min="0" className="h-9" />
                    </div>
                    <div className="col-span-8 sm:col-span-2 space-y-1">
                        {index === 0 && <Label htmlFor={`unit_price_item_${index}_${formType}`} className="text-xs">P. Unit. (USD)</Label>}
                        <Input id={`unit_price_item_${index}_${formType}`} type="number" placeholder="Precio" value={item.unitPrice} onChange={(e) => handleItemOrChangeValue(index, 'unitPrice', e.target.value, formType, 'items')} disabled={isSubmitting || !item.productId} min="0" className="h-9" />
                    </div>
                    <div className="col-span-8 sm:col-span-2 space-y-1">
                        {index === 0 && <Label className="text-xs">Subtotal (USD)</Label>}
                        <div className="h-9 rounded-md bg-muted/50 px-3 flex items-center justify-end">
                            <FormattedNumber value={item.subtotal} prefix="$" />
                        </div>
                    </div>
                    <div className="col-span-4 sm:col-span-1 flex items-end justify-end">
                        <Button type="button" variant="ghost" size="icon" onClick={() => handleRemoveItemOrChange(index, formType, 'items')} disabled={isSubmitting} className="h-9 w-9 text-destructive hover:bg-destructive/10"><Trash className="h-4 w-4" /></Button>
                    </div>
                </div>
            ))}
            <Button type="button" variant="outline" size="sm" onClick={() => handleAddItemOrChange(formType, 'items')} disabled={isSubmitting || availableProducts.filter(p => p.category?.toLowerCase() !== 'no despachable').length === 0} className="mt-2"><PlusCircle className="mr-2 h-4 w-4" /> Añadir Ítem</Button>
        </div>
        <div className="space-y-2 border p-3 rounded-md max-h-60 overflow-y-auto">
            <Label className="font-medium">Cambios/Devoluciones</Label>
            {currentChangeItems.map((changeItem, index) => (
                <div key={`change-${index}-${formType}`} className="grid grid-cols-12 gap-2 items-end border-b pb-2 mb-2 last:border-b-0 last:pb-0 last:mb-0">
                    <div className="col-span-12 sm:col-span-5 space-y-1">
                        {index === 0 && <Label htmlFor={`product_id_change_${index}_${formType}`} className="text-xs">Producto Devuelto (Sede)</Label>}
                        <Select value={changeItem.productId} onValueChange={(value) => handleItemOrChangeValue(index, 'productId', value, formType, 'changes')} disabled={isSubmitting}>
                            <SelectTrigger id={`product_id_change_${index}_${formType}`} className="h-9"><SelectValue placeholder="Producto" /></SelectTrigger>
                            <SelectContent>{availableProducts.map(p => <SelectItem key={p.id} value={p.id}>{p.name} ({p.sourceBranchName} - Stock: {p.stock})</SelectItem>)}</SelectContent>
                        </Select>
                    </div>
                    <div className="col-span-4 sm:col-span-2 space-y-1">
                        {index === 0 && <Label htmlFor={`quantity_change_${index}_${formType}`} className="text-xs">Cant. Dev.</Label>}
                        <Input id={`quantity_change_${index}_${formType}`} type="number" placeholder="Cant." value={changeItem.quantity} onChange={(e) => handleItemOrChangeValue(index, 'quantity', e.target.value, formType, 'changes')} disabled={isSubmitting || !changeItem.productId} min="0" className="h-9" />
                    </div>
                    <div className="col-span-8 sm:col-span-2 space-y-1">
                        {index === 0 && <Label htmlFor={`unit_price_change_${index}_${formType}`} className="text-xs">P. Unit. Dev. (USD)</Label>}
                        <Input id={`unit_price_change_${index}_${formType}`} type="number" placeholder="Precio" value={changeItem.unitPrice} onChange={(e) => handleItemOrChangeValue(index, 'unitPrice', e.target.value, formType, 'changes')} disabled={isSubmitting || !changeItem.productId} min="0" className="h-9" />
                    </div>
                    <div className="col-span-8 sm:col-span-2 space-y-1">
                        {index === 0 && <Label className="text-xs">Subtotal Dev. (USD)</Label>}
                         <div className="h-9 rounded-md bg-muted/50 px-3 flex items-center justify-end">
                            <FormattedNumber value={changeItem.subtotal} prefix="$" />
                        </div>
                    </div>
                    <div className="col-span-4 sm:col-span-1 flex items-end justify-end">
                        <Button type="button" variant="ghost" size="icon" onClick={() => handleRemoveItemOrChange(index, formType, 'changes')} disabled={isSubmitting} className="h-9 w-9 text-destructive hover:bg-destructive/10"><Trash className="h-4 w-4" /></Button>
                    </div>
                </div>
            ))}
            <Button type="button" variant="outline" size="sm" onClick={() => handleAddItemOrChange(formType, 'changes')} disabled={isSubmitting || availableProducts.length === 0} className="mt-2"><PlusCircle className="mr-2 h-4 w-4" /> Añadir Cambio</Button>
        </div>
        <div className="space-y-2 border p-3 rounded-md max-h-60 overflow-y-auto"><Label className="font-medium">Muestra/Regalo</Label>{currentSampleItems.map((sampleItem, index) => (<div key={`sample-${index}-${formType}`} className="grid grid-cols-12 gap-2 items-end border-b pb-2 mb-2 last:border-b-0 last:pb-0 last:mb-0"><div className="col-span-11 sm:col-span-7 space-y-1">{index === 0 && <Label htmlFor={`product_id_sample_${index}_${formType}`} className="text-xs">Producto Muestra (Sede)</Label>}
        <Select value={sampleItem.productId} onValueChange={(value) => handleItemOrChangeValue(index, 'productId', value, formType, 'samples')} disabled={isSubmitting}>
            <SelectTrigger id={`product_id_sample_${index}_${formType}`} className="h-9"><SelectValue placeholder="Producto" /></SelectTrigger>
            <SelectContent>
                {availableProducts.map(p => <SelectItem key={p.id} value={p.id} disabled={p.stock <= 0 && !(formType === 'edit' && editingSale?.samples?.find(s => s.productId === p.id))}>{p.name} ({p.sourceBranchName} - Stock: {p.stock})</SelectItem>)}
            </SelectContent>
        </Select></div><div className="col-span-5 sm:col-span-4 space-y-1">{index === 0 && <Label htmlFor={`quantity_sample_${index}_${formType}`} className="text-xs">Cant.</Label>}<Input id={`quantity_sample_${index}_${formType}`} type="number" placeholder="Cant." value={sampleItem.quantity} onChange={(e) => handleItemOrChangeValue(index, 'quantity', e.target.value, formType, 'samples')} disabled={isSubmitting || !sampleItem.productId} min="0" className="h-9" /></div><div className="col-span-1 flex items-end justify-end"><Button type="button" variant="ghost" size="icon" onClick={() => handleRemoveItemOrChange(index, formType, 'samples')} disabled={isSubmitting} className="h-9 w-9 text-destructive hover:bg-destructive/10"><Trash className="h-4 w-4" /></Button></div></div>))}<Button type="button" variant="outline" size="sm" onClick={() => handleAddItemOrChange(formType, 'samples')} disabled={isSubmitting || availableProducts.length === 0} className="mt-2"><Gift className="mr-2 h-4 w-4" /> Añadir Muestra</Button></div>
        
        {netTotal < 0 && (
          <Alert variant="default" className="bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-700">
            <Info className="h-4 w-4 text-blue-600 dark:text-blue-400" />
            <AlertTitle className="text-blue-800 dark:text-blue-300">Nota de Crédito Generada</AlertTitle>
            <AlertDescription className="text-blue-700 dark:text-blue-400">
              <p>Esta venta generará un crédito de <FormattedNumber value={Math.abs(netTotal)} prefix="$" /> a favor del cliente.</p>
               <div className="space-y-1 mt-2">
                  <Label htmlFor={`credit_note_target_${formType}`}>Aplicar a Factura Pendiente*</Label>
                  <Select value={creditNoteTargetInvoiceId} onValueChange={setCreditNoteTargetInvoiceId} disabled={isSubmitting}>
                      <SelectTrigger id={`credit_note_target_${formType}`}><SelectValue placeholder="Selecciona factura a acreditar..." /></SelectTrigger>
                      <SelectContent>
                          {pendingInvoicesForCustomer.length > 0 ? (
                            pendingInvoicesForCustomer.map(inv => {
                                const invoiceStatus = getInvoiceStatus(inv, initialPaymentsDataGlobal);
                                const balance = inv.totalAmount - (inv.amountPaidUSD || 0);
                                return (
                                <SelectItem key={inv.id} value={inv.id}>
                                    ID: {inv.id} (Fecha: {format(parseISO(inv.date), "dd/MM/yy")}, Saldo: ${balance.toFixed(2)})
                                </SelectItem>
                            )})
                          ) : (
                            <SelectItem value="no-invoices" disabled>No hay facturas pendientes para este cliente</SelectItem>
                          )}
                      </SelectContent>
                  </Select>
               </div>
            </AlertDescription>
          </Alert>
        )}

        {netTotal >= 0 && (
            <>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div className="space-y-1"><Label htmlFor={`payment_method_${formType}`}>Método Pago Global</Label><Select value={paymentMethod} onValueChange={(value: Sale['paymentMethod']) => setPaymentMethodParam(value)} disabled={isSubmitting}><SelectTrigger id={`payment_method_${formType}`}><SelectValue /></SelectTrigger><SelectContent>{salePaymentMethods.map(method => <SelectItem key={method} value={method}>{method}</SelectItem>)}</SelectContent></Select></div>
                </div>
                {paymentMethod === 'Pagado' && (
                    <div className="space-y-3 border p-3 rounded-md">
                        <Label className="font-medium">Formas de Pago Múltiples</Label>
                        {paymentSplitsParam.map((split, index) => {
                            const availablePaymentMethods = getPaymentMethodsForCurrency(split.currency);
                            const availableAccounts = getAccountsForPaymentMethod(split.currency, split.paymentMethod);
                            return (
                            <div key={split.id} className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-3 items-end border-b pb-3 mb-3 last:border-b-0">
                                <div className="space-y-1 lg:col-span-1">
                                    {index === 0 && <Label htmlFor={`split_amount_${split.id}`} className="text-xs">Monto</Label>}
                                    <Input id={`split_amount_${split.id}`} type="number" value={split.amount} onChange={e => handleSplitChange(split.id, 'amount', parseFloat(e.target.value) || 0, formType)} placeholder="Monto" disabled={isSubmitting} className="h-9"/>
                                </div>
                                <div className="space-y-1 lg:col-span-1">
                                    {index === 0 && <Label htmlFor={`split_currency_${split.id}`} className="text-xs">Moneda</Label>}
                                    <Select value={split.currency} onValueChange={val => handleSplitChange(split.id, 'currency', val, formType)} disabled={isSubmitting }>
                                        <SelectTrigger id={`split_currency_${split.id}`} className="h-9"><SelectValue /></SelectTrigger>
                                        <SelectContent>
                                            <SelectItem value="USD">USD</SelectItem>
                                            <SelectItem value="VES" disabled={exchangeRate <= 0}>VES {exchangeRate <= 0 ? '(Tasa no disp.)' : ''}</SelectItem>
                                        </SelectContent>
                                    </Select>
                                </div>
                                <div className="space-y-1 lg:col-span-1">
                                    {index === 0 && <Label htmlFor={`split_method_${split.id}`} className="text-xs">Método</Label>}
                                    <Select value={split.paymentMethod} onValueChange={val => handleSplitChange(split.id, 'paymentMethod', val, formType)} disabled={isSubmitting || availablePaymentMethods.length === 0}>
                                        <SelectTrigger id={`split_method_${split.id}`} className="h-9"><SelectValue /></SelectTrigger>
                                        <SelectContent>
                                            {availablePaymentMethods.map(m => <SelectItem key={m} value={m}>{m}</SelectItem>)}
                                            {availablePaymentMethods.length === 0 && <SelectItem value="no-methods-available" disabled>N/A para moneda</SelectItem>}
                                        </SelectContent>
                                    </Select>
                                </div>
                              {split.currency === 'VES' && (
                                <div className="space-y-1 lg:col-span-1">
                                    {index === 0 && <Label htmlFor={`split_exchange_rate_${split.id}`} className="text-xs">Tasa (Opc)</Label>}
                                    <Input id={`split_exchange_rate_${split.id}`} type="number" value={split.exchangeRateAtPayment || ''} onChange={e => handleSplitChange(split.id, 'exchangeRateAtPayment', parseFloat(e.target.value) || undefined, formType)} placeholder={`Global: ${exchangeRate > 0 ? exchangeRate.toFixed(2) : 'N/A'}`} disabled={isSubmitting || exchangeRate <=0} className="h-9"/>
                                </div>
                              )}
                                {(split.paymentMethod === 'Pago Móvil (VES)' || split.paymentMethod === 'Transferencia (VES)') && (
                                    <div className="space-y-1 lg:col-span-1">
                                        {index === 0 && <Label htmlFor={`split_ref_${split.id}`} className="text-xs">Ref. (6 dig)*</Label>}
                                        <Input id={`split_ref_${split.id}`} value={split.referenceNumber || ''} onChange={e => handleSplitChange(split.id, 'referenceNumber', e.target.value, formType)} placeholder="123456" disabled={isSubmitting} className="h-9" maxLength={6}/>
                                    </div>
                                )}
                                <div className="space-y-1 lg:col-span-2">
                                    {index === 0 && <Label htmlFor={`split_branch_${split.id}`} className="text-xs">Sede Ingreso</Label>}
                                    <Select value={split.paidToBranchId} onValueChange={val => handleSplitChange(split.id, 'paidToBranchId', val, formType)} disabled={isSubmitting}>
                                        <SelectTrigger id={`split_branch_${split.id}`} className="h-9"><SelectValue /></SelectTrigger>
                                        <SelectContent>{availableBranches.map(b => <SelectItem key={b.id} value={b.id}>{b.name}</SelectItem>)}</SelectContent>
                                    </Select>
                                </div>
                                <div className="space-y-1 lg:col-span-2">
                                    {index === 0 && <Label htmlFor={`split_account_${split.id}`} className="text-xs">Cuenta Ingreso</Label>}
                                    <Select value={split.paidToAccountId} onValueChange={val => handleSplitChange(split.id, 'paidToAccountId', val as AccountType, formType)} disabled={isSubmitting || availableAccounts.length === 0}>
                                        <SelectTrigger id={`split_account_${split.id}`} className="h-9"><SelectValue /></SelectTrigger>
                                        <SelectContent>
                                            {availableAccounts.map(accId => {
                                                const accountDetails = loadFromLocalStorageForBranch<CompanyAccountsData>(KEYS.COMPANY_ACCOUNTS, split.paidToBranchId || '', true)[accId as AccountType];
                                                return (<SelectItem key={accId} value={accId}>{accountTypeNames[accId]} ({accountDetails?.currency})</SelectItem>);
                                            })}
                                            {availableAccounts.length === 0 && <SelectItem value="no-accounts-available" disabled>N/A para moneda/método</SelectItem>}
                                        </SelectContent>
                                    </Select>
                                </div>
                                <div className="flex items-end justify-end lg:col-span-1">
                                    <Button type="button" variant="ghost" size="icon" onClick={() => handleRemoveSplit(split.id, formType)} disabled={isSubmitting || paymentSplitsParam.length <=1} className="h-9 w-9 text-destructive hover:bg-destructive/10"><Trash className="h-4 w-4" /></Button>
                                </div>
                            </div>
                        )})}
                        <Button type="button" variant="outline" size="sm" onClick={() => handleAddSplit(formType)} disabled={isSubmitting} className="mt-2">
                            <DollarSign className="mr-2 h-4 w-4" /> Añadir Forma de Pago
                        </Button>
                        <div className="mt-2 text-sm">
                            <p>Total Cubierto por Pagos: <span className="font-semibold"><FormattedNumber value={totalPaidInSplits} prefix="$" /></span> (<FormattedNumber value={exchangeRate > 0 ? totalPaidInSplits * exchangeRate : undefined} prefix="Bs. " />)</p>
                            <p className={cn(Math.abs(remainingToPay) < 0.01 ? "text-green-600" : "text-destructive", "font-semibold")}> 
                                {remainingToPay > 0.01 ? `Faltante por Cubrir: $${remainingToPay.toFixed(2)}` : remainingToPay < -0.01 ? `Pagado de Más: $${Math.abs(remainingToPay).toFixed(2)}` : "Monto Cubierto"}
                            </p>
                        </div>
                    </div>
                )}
            </>
        )}

        <div className="space-y-1 pt-4">
            <Label htmlFor={`sale_notes_${formType}`}>Observaciones (Opcional)</Label>
            <Textarea
                id={`sale_notes_${formType}`}
                placeholder="Anotaciones internas sobre la venta, condiciones especiales, etc."
                value={notesValue}
                onChange={(e) => setNotesValue(e.target.value)}
                disabled={isSubmitting}
                className="min-h-[60px]"
            />
        </div>
        
        <Card className="mt-2">
          <CardContent className="p-3 space-y-1">
            <div className="flex justify-between text-sm"><span>Subtotal Venta (USD):</span><span><FormattedNumber value={itemsSubtotal} prefix="$" /></span></div>
            {changesSubtotal > 0 && (<div className="flex justify-between text-sm text-destructive"><span>(-) Total Cambios (USD):</span><span><FormattedNumber value={changesSubtotal} prefix="-$" /></span></div>)}
            <div className="flex justify-between text-base font-semibold border-t pt-1 mt-1"><span>Total Neto (USD):</span><span><FormattedNumber value={netTotal} prefix="$" /></span></div>
            {creditToApply > 0 && (
              <div className="flex justify-between text-sm text-green-600">
                  <span>(-) Crédito Aplicado (USD):</span>
                  <span><FormattedNumber value={creditToApply} prefix="-$" /></span>
              </div>
            )}
            <div className="flex justify-between text-lg font-bold border-t pt-2 mt-2">
                <span>Total a Pagar (USD):</span>
                <span className={cn(creditToApply > 0 ? "text-green-700 dark:text-green-500" : "")}>
                    <FormattedNumber value={totalToPayAfterCredit} prefix="$" />
                </span>
            </div>
            <div className="flex justify-between text-sm text-muted-foreground"><span>Total a Pagar (VES):</span><span><FormattedNumber value={exchangeRate > 0 ? totalToPayAfterCredit * exchangeRate : undefined} prefix="Bs. " /></span></div>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <PageHeader title="Gestión de Ventas (Global)" description="Registra y gestiona ventas. Puedes incluir productos de múltiples sedes. Si una venta pagada es multi-sede, el ingreso se registra en la sede seleccionada y se generan transferencias de fondos pendientes." icon={ShoppingCart} actions={ <Button onClick={() => { resetAddForm(); setIsAddSaleDialogOpen(true); }} disabled={isSubmitting || isLoading}> <PlusCircle className="mr-2 h-4 w-4" /> Registrar Venta </Button> } />
      <Card className="shadow-lg">
        <CardHeader><div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4"><div><CardTitle>Historial de Ventas (Global)</CardTitle><CardDescription>Resumen de ventas globales.</CardDescription></div><div className="flex flex-col sm:flex-row items-center gap-2 w-full sm:w-auto"><Popover><PopoverTrigger asChild><Button id="date-filter-sales" variant={"outline"} className={cn("w-full sm:w-[260px] justify-start text-left font-normal", !dateRangeFilter && "text-muted-foreground")} disabled={isSubmitting || isLoading}><CalendarIcon className="mr-2 h-4 w-4" />{dateRangeFilter?.from ? (dateRangeFilter.to ? (<>{format(dateRangeFilter.from, "LLL dd, y", { locale: es })} - {format(dateRangeFilter.to, "LLL dd, y", { locale: es })}</>) : (format(dateRangeFilter.from, "LLL dd, y", { locale: es }))) : (<span>Filtrar Fecha</span>)}</Button></PopoverTrigger><PopoverContent className="w-auto p-0" align="end"><Calendar initialFocus mode="range" defaultMonth={dateRangeFilter?.from} selected={dateRangeFilter} onSelect={setDateRangeFilter} numberOfMonths={2} locale={es} /></PopoverContent></Popover><Select value={filterCustomerId} onValueChange={setFilterCustomerId} disabled={isSubmitting || isLoading}><SelectTrigger className="w-full sm:w-[200px]"><SelectValue placeholder="Filtrar Cliente" /></SelectTrigger><SelectContent><SelectItem value={ALL_CUSTOMERS_FILTER_VALUE}>Todos Clientes</SelectItem>{availableCustomers.sort((a,b) => a.name.localeCompare(b.name)).map(customer => (<SelectItem key={customer.id} value={customer.id}>{customer.name}</SelectItem>))}</SelectContent></Select><Select value={filterSaleStatus} onValueChange={setFilterSaleStatus} disabled={isSubmitting || isLoading}><SelectTrigger className="w-full sm:w-[200px]"><SelectValue placeholder="Filtrar Estado" /></SelectTrigger><SelectContent><SelectItem value={ALL_STATUSES_FILTER_VALUE}>Todos Estados</SelectItem>{saleStatusOptions.map(status => (<SelectItem key={status} value={status}>{status}</SelectItem>))}</SelectContent></Select><Button onClick={handleApplyFilters} className="w-full sm:w-auto" disabled={isSubmitting || isLoading}><Filter className="mr-2 h-4 w-4" /> Aplicar</Button><Button onClick={handleClearFilters} variant="outline" className="w-full sm:w-auto" disabled={isSubmitting || isLoading}>Limpiar</Button></div></div></CardHeader>
        <CardContent>
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead className="w-24">Fecha/Hora</TableHead>
                  <TableHead>Cliente</TableHead>
                  <TableHead className="text-right">Total (USD)</TableHead>
                  <TableHead className="text-right">Total (VES)</TableHead>
                  <TableHead>Método Pago</TableHead>
                  <TableHead>Estado</TableHead>
                  <TableHead>Vence</TableHead>
                  <TableHead className="text-right w-28">Acciones</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {filteredSales.map((sale) => {
                  const status = getInvoiceStatus(sale, initialPaymentsDataGlobal);
                  return (
                        <TableRow key={sale.id} className={cn(status === 'Vencida' ? 'bg-destructive/10 hover:bg-destructive/15' : 'hover:bg-muted/20')}>
                          <TableCell className="font-medium align-top py-3 w-auto">
                                <div>
                                {sale.date ? format(parseISO(sale.date), "dd/MM/yy", { locale: es }) : '-'}
                                {sale.timestamp && isValid(parseISO(sale.timestamp)) && (
                                    <span className="block text-xs text-muted-foreground">{format(parseISO(sale.timestamp), "hh:mm a", { locale: es })}</span>
                                )}
                                </div>
                          </TableCell>
                          <TableCell className="align-top py-3">{sale.customerName}</TableCell>
                          <TableCell className="text-right align-top py-3"><FormattedNumber value={sale.totalAmount} prefix="$" /></TableCell>
                          <TableCell className="text-right align-top py-3"><FormattedNumber value={exchangeRate > 0 ? sale.totalAmount * exchangeRate : undefined} prefix="Bs. " /></TableCell>
                          <TableCell className="align-top py-3">{sale.paymentMethod}</TableCell>
                          <TableCell className="align-top py-3">
                            <Badge variant={status === 'Completada' ? 'default' : status === 'Vencida' ? 'destructive' : 'secondary'} className={cn("whitespace-nowrap", status === 'Vencida' ? 'bg-red-500/80 text-white dark:bg-red-700/80 dark:text-red-100 border-red-700/50' : status === 'Pendiente de Pago' ? 'bg-yellow-500/80 text-black dark:bg-yellow-600/80 dark:text-yellow-100 border-yellow-600/50' : status === 'Pagada Parcialmente' ? 'bg-orange-500/80 text-white dark:bg-orange-600/80 dark:text-orange-100 border-orange-600/50' : status === 'Completada' ? 'bg-green-500/20 text-green-700 dark:text-green-400 border-green-500/50' : '')}>{status}</Badge>
                          </TableCell>
                          <TableCell className="align-top py-3">{sale.dueDate ? format(parseISO(sale.dueDate), "dd/MM/yy", { locale: es }) : '-'}</TableCell>
                          <TableCell className="text-right align-top py-3">
                            <div className="flex items-center justify-end space-x-1">
                              <Button variant="ghost" size="icon" onClick={() => handleOpenViewDialog(sale)} title="Ver Factura" disabled={isSubmitting}>
                                <Eye className="h-4 w-4" />
                              </Button>
                              <DropdownMenu>
                                <DropdownMenuTrigger asChild><Button variant="ghost" size="icon" disabled={isSubmitting} title="Más Acciones"><MoreHorizontal className="h-4 w-4" /></Button></DropdownMenuTrigger>
                                <DropdownMenuContent align="end">
                                  <DropdownMenuItem onClick={() => handleOpenEditDialog(sale)} disabled={isSubmitting}><Edit className="mr-2 h-4 w-4" />Editar</DropdownMenuItem>
                                  <DropdownMenuItem onClick={() => {setSaleToDeleteId(sale.id); setIsDeleteConfirmDialogOpen(true);}} className="text-destructive focus:text-destructive-foreground focus:bg-destructive" disabled={isSubmitting}><Trash2 className="mr-2 h-4 w-4" />Eliminar</DropdownMenuItem>
                                </DropdownMenuContent>
                              </DropdownMenu>
                            </div>
                          </TableCell>
                        </TableRow>
                  )
                })}
              </TableBody>
            </Table>
          {filteredSales.length === 0 && !isLoading && <p className="text-center text-muted-foreground py-8">{dateRangeFilter?.from || (filterCustomerId && filterCustomerId !== ALL_CUSTOMERS_FILTER_VALUE) || (filterSaleStatus && filterSaleStatus !== ALL_STATUSES_FILTER_VALUE) ? "No hay ventas para filtros." : "No hay ventas."}</p>}
        </CardContent>
      </Card>

      <Dialog open={isViewSaleDialogOpen} onOpenChange={(isOpen) => { if (!isSubmitting) { setIsViewSaleDialogOpen(isOpen); if (!isOpen) setSaleToViewDetails(null); }}}>
        <DialogContent className="sm:max-w-2xl max-h-[85vh]">
          <DialogHeader>
            <DialogTitle>Detalles de Venta: {saleToViewDetails?.id}</DialogTitle>
            <DialogDescription>Info completa.</DialogDescription>
          </DialogHeader>
          {saleToViewDetails && (
            <>
            <ScrollArea className="max-h-[calc(70vh-100px)] p-1 pr-3">
              <div className="space-y-3 py-4 text-sm">
                  <div className="grid grid-cols-2 gap-2">
                    <div><span className="font-semibold">Cliente:</span> {saleToViewDetails.customerName}</div>
                    <div><span className="font-semibold">Fecha:</span> {saleToViewDetails.date ? format(parseISO(saleToViewDetails.date), "dd/MM/yyyy", { locale: es }) : '-'} {saleToViewDetails.timestamp && isValid(parseISO(saleToViewDetails.timestamp)) ? format(parseISO(saleToViewDetails.timestamp), "hh:mm a", { locale: es }) : ''}</div>
                    <div><span className="font-semibold">Método Pago Global:</span> {saleToViewDetails.paymentMethod}</div>
                    <div><span className="font-semibold">Estado:</span> <Badge variant={getInvoiceStatus(saleToViewDetails, initialPaymentsDataGlobal) === 'Completada' ? 'default' : getInvoiceStatus(saleToViewDetails, initialPaymentsDataGlobal) === 'Vencida' ? 'destructive' : 'secondary'} className={cn("whitespace-nowrap", getInvoiceStatus(saleToViewDetails, initialPaymentsDataGlobal) === 'Vencida' ? 'bg-red-500/80 text-white dark:bg-red-700/80 dark:text-red-100 border-red-700/50' : getInvoiceStatus(saleToViewDetails, initialPaymentsDataGlobal) === 'Pendiente de Pago' ? 'bg-yellow-500/80 text-black dark:bg-yellow-600/80 dark:text-yellow-100 border-yellow-600/50' : getInvoiceStatus(saleToViewDetails, initialPaymentsDataGlobal) === 'Pagada Parcialmente' ? 'bg-orange-500/80 text-white dark:bg-orange-600/80 dark:text-orange-100 border-orange-600/50' : getInvoiceStatus(saleToViewDetails, initialPaymentsDataGlobal) === 'Completada' ? 'bg-green-500/20 text-green-700 dark:text-green-400 border-green-500/50' : '')}>{getInvoiceStatus(saleToViewDetails, initialPaymentsDataGlobal)}</Badge></div>
                    {saleToViewDetails.dueDate && <div><span className="font-semibold">Vence:</span> {format(parseISO(saleToViewDetails.dueDate), "dd/MM/yyyy", { locale: es })}</div>}
                  </div>
                  {saleToViewDetails.notes && (
                    <div className="pt-2">
                        <p className="text-xs font-semibold text-muted-foreground mb-1">Observaciones:</p>
                        <p className="text-sm whitespace-pre-wrap bg-muted/50 p-2 rounded-md border">{saleToViewDetails.notes}</p>
                    </div>
                  )}
                  {saleToViewDetails.paymentMethod === 'Pagado' && saleToViewDetails.paymentSplits && saleToViewDetails.paymentSplits.length > 0 && (
                    <div className="mt-2 border-t pt-2">
                      <p className="text-xs font-semibold text-muted-foreground mb-1">Desglose de Pagos:</p>
                      {saleToViewDetails.paymentSplits.map(split => (
                        <div key={split.id} className="text-xs text-muted-foreground/90 pl-2">
                          - {split.paymentMethod}: <FormattedNumber value={split.amount} prefix={split.currency === 'USD' ? '$' : 'Bs. '} />
                          {split.currency === 'VES' && split.exchangeRateAtPayment && ` (Tasa: ${split.exchangeRateAtPayment.toFixed(2)})`}
                          , Sede: {availableBranches.find(b => b.id === split.paidToBranchId)?.name || 'N/A'}
                          , Cta: {accountTypeNames[split.paidToAccountId]}
                          {split.referenceNumber && `, Ref: ${split.referenceNumber}`}
                        </div>
                      ))}
                    </div>
                  )}
                
                {saleToViewDetails.itemsPerBranch.map(branchDetail => (
                    <div key={`view-branchDetail-${branchDetail.branchId}-${saleToViewDetails.id}`}>{renderItemsTable(branchDetail, 'branchDetail')}</div>
                ))}
                {renderItemsTable(saleToViewDetails.changes, 'changes')}
                {renderItemsTable(saleToViewDetails.samples, 'samples')}

                <Card className="mt-3"><CardContent className="p-3 space-y-1 text-sm"><div className="flex justify-between"><span>Total Bruto (USD):</span><span><FormattedNumber value={calculateItemsSubtotal(saleToViewDetails.itemsPerBranch.flatMap(bd => bd.items))} prefix="$" /></span></div>{saleToViewDetails.changes && saleToViewDetails.changes.some(c=>c.productId) && (<div className="flex justify-between text-destructive"><span>(-) Total Cambios (USD):</span><span><FormattedNumber value={calculateItemsSubtotal(saleToViewDetails.changes)} prefix="-$" /></span></div>)}<div className="flex justify-between text-base font-semibold border-t pt-1 mt-1"><span>Total Neto (USD):</span><span><FormattedNumber value={saleToViewDetails.totalAmount} prefix="$" /></span></div></CardContent></Card>
              </div>
            </ScrollArea>
            <DialogFooter className="pt-4 border-t">
                <DialogClose asChild><Button variant="outline">Cerrar</Button></DialogClose>
                <Button onClick={() => generateInvoicePDF(saleToViewDetails)} disabled={isSubmitting}><InvoiceIcon className="mr-2 h-4 w-4" />Generar PDF</Button>
            </DialogFooter>
            </>
          )}
        </DialogContent>
      </Dialog>

      <Dialog open={isAddSaleDialogOpen} onOpenChange={(isOpen) => { if (isSubmitting) return; setIsAddSaleDialogOpen(isOpen); if (!isOpen) resetAddForm(); }}><DialogContent className="sm:max-w-2xl max-h-[85vh] overflow-y-auto"><DialogHeader><DialogTitle>Registrar Venta</DialogTitle><DialogDescription>Detalles, cambios/devoluciones y muestras/regalos.</DialogDescription></DialogHeader>{renderSaleDialogContent('new', newSaleItems, setNewSaleItems, newSaleChanges, setNewSaleChanges, newSampleItems, setNewSampleItems, newSaleDate, setNewSaleDate, newSelectedCustomerId, setNewSelectedCustomerId, newPaymentMethod, setNewPaymentMethod, newPaymentSplits, setNewPaymentSplits)}<DialogFooter><DialogClose asChild><Button variant="outline" disabled={isSubmitting}>Cancelar</Button></DialogClose><Button type="button" onClick={handleAddSale} disabled={isSubmitting || availableProducts.length === 0 || !newSelectedCustomerId || (newPaymentMethod === 'Pagado' && calculateTotalAmount(newSaleItems, newSaleChanges) > 0 && newPaymentSplits.some(s => !s.paidToBranchId || !s.paidToAccountId || s.amount <= 0)) }>{isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <PlusCircle className="mr-2 h-4 w-4" />}Guardar Venta</Button></DialogFooter></DialogContent></Dialog>
      <Dialog open={isEditSaleDialogOpen} onOpenChange={(isOpen) => { if (isSubmitting) return; setIsEditSaleDialogOpen(isOpen); if (!isOpen) { setEditingSale(null); setOriginalSaleForEdit(null); } }}><DialogContent className="sm:max-w-2xl max-h-[85vh] overflow-y-auto"><DialogHeader><DialogTitle>Editar Venta</DialogTitle><DialogDescription>Actualiza detalles, cambios/devoluciones y muestras/regalos.</DialogDescription></DialogHeader>{editingSale && renderSaleDialogContent('edit', editSaleItems, setEditSaleItems, editSaleChanges, setEditSaleChanges, editSampleItems, setEditSampleItems, editSaleDate, setEditSaleDate, editSelectedCustomerId, setEditSelectedCustomerId, editPaymentMethod, setEditPaymentMethod, editPaymentSplits, setEditPaymentSplits)}<DialogFooter><DialogClose asChild><Button variant="outline" disabled={isSubmitting}>Cancelar</Button></DialogClose><Button type="button" onClick={handleUpdateSale} disabled={isSubmitting || availableProducts.length === 0 || !editSelectedCustomerId || (editPaymentMethod === 'Pagado' && calculateTotalAmount(editSaleItems, editSaleChanges) >= 0 && editPaymentSplits.some(s => !s.paidToBranchId || !s.paidToAccountId || s.amount <=0)) }>{isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Edit className="mr-2 h-4 w-4" />}Guardar Cambios</Button></DialogFooter></DialogContent></Dialog>
      <Dialog open={isDeleteConfirmDialogOpen} onOpenChange={(isOpen) => { if (!isSubmitting) setIsDeleteConfirmDialogOpen(isOpen) }}><DialogContent className="sm:max-w-md"><DialogHeader><DialogTitle>Confirmar Eliminación</DialogTitle><DialogDescription>¿Eliminar venta? Ajustará stock y datos del cliente. Revertirá pagos/transacciones asociadas.</DialogDescription></DialogHeader><DialogFooter className="sm:justify-end"><DialogClose asChild><Button variant="outline" disabled={isSubmitting} onClick={() => { setSaleToDeleteId(null); setIsDeleteConfirmDialogOpen(false);}}>Cancelar</Button></DialogClose><Button variant="destructive" onClick={handleConfirmDelete} disabled={isSubmitting}>{isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Trash2 className="mr-2 h-4 w-4" />}Eliminar Venta</Button></DialogFooter></DialogContent></Dialog>
    </div>
  );
}

// --- select-branch ---


"use client";

import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { PageHeader } from '@/components/page-header';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Building, CheckCircle } from 'lucide-react';
import { availableBranches, setActiveBranchId, getActiveBranchId, type Branch } from '@/lib/data-storage';
import { useToast } from '@/hooks/use-toast';

export default function SelectBranchPage() {
  const router = useRouter();
  const { toast } = useToast();
  const [currentBranchId, setCurrentBranchId] = useState<string | null>(null);

  useEffect(() => {
    setCurrentBranchId(getActiveBranchId());
  }, []);

  const handleSelectBranch = (branchId: string) => {
    setActiveBranchId(branchId);
    setCurrentBranchId(branchId);
    toast({
      title: "Sede Seleccionada",
      description: `Has seleccionado la sede: ${availableBranches.find(b => b.id === branchId)?.name}. Recargando...`,
    });
    // Forzar una recarga completa para asegurar que todos los datos se cargan para la nueva sede
    // y que data-storage.ts se reinicializa con el nuevo activeBranchId
    setTimeout(() => {
      window.location.href = '/';
    }, 500);
  };

  // Si ya hay una sede seleccionada y el usuario llega aquí (ej. por URL directa),
  // podría ser útil redirigirlo de vuelta al dashboard, o permitirle cambiar.
  // Por ahora, se permite el cambio.

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-background p-4">
      <PageHeader
        title="Seleccionar Sede"
        description="Elige la sede de la panadería a la que deseas acceder."
        icon={Building}
      />
      <Card className="w-full max-w-md shadow-xl">
        <CardHeader>
          <CardTitle>Sedes Disponibles</CardTitle>
          <CardDescription>
            {currentBranchId 
              ? `Sede actual: ${availableBranches.find(b => b.id === currentBranchId)?.name || 'Desconocida'}. Selecciona otra si deseas cambiar.`
              : "Por favor, selecciona una sede para continuar."}
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-3">
          {availableBranches.map((branch: Branch) => (
            <Button
              key={branch.id}
              variant={currentBranchId === branch.id ? "default" : "outline"}
              className="w-full justify-start text-lg py-6"
              onClick={() => handleSelectBranch(branch.id)}
            >
              {currentBranchId === branch.id && <CheckCircle className="mr-3 h-5 w-5 text-green-400" />}
              {branch.name}
            </Button>
          ))}
          {availableBranches.length === 0 && (
            <p className="text-muted-foreground text-center">No hay sedes configuradas.</p>
          )}
        </CardContent>
      </Card>
      {currentBranchId && (
        <Button variant="link" onClick={() => router.push('/')} className="mt-6">
            Volver al Panel ({availableBranches.find(b => b.id === currentBranchId)?.name})
        </Button>
      )}
    </div>
  );
}

// --- suppliers ---



"use client";

import React, { useState, useEffect, useCallback } from 'react';
import { PageHeader } from '@/components/page-header';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogClose } from '@/components/ui/dialog';
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Building, PlusCircle, MoreHorizontal, Edit, Trash2, Trash, ListPlus, Loader2, Eye, CalendarDays } from 'lucide-react';
import { useToast } from "@/hooks/use-toast";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';
import { ScrollArea } from '@/components/ui/scroll-area';
import { 
  suppliersData as initialSuppliersData, 
  saveSuppliersData, 
  type Supplier, 
  type SupplierPriceListItem,
  type PriceHistoryEntry, 
  getCurrentPriceFromHistory, 
  getCurrentRawMaterialOptions, 
  commonUnitOptions,
  KEYS
} from '@/lib/data-storage';
import { format, parseISO, compareDesc, isValid, formatDistanceStrict } from 'date-fns';
import { es } from 'date-fns/locale';
import { cn } from '@/lib/utils';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Calendar } from '@/components/ui/calendar';
import { Calendar as CalendarIcon } from 'lucide-react';
import { Separator } from '@/components/ui/separator';
import { FormattedNumber } from '@/components/ui/formatted-number';


export default function SuppliersPage() {
  const { toast } = useToast();
  const [currentSuppliers, setCurrentSuppliers] = useState<Supplier[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [availableRawMaterials, setAvailableRawMaterials] = useState<string[]>([]);

  const [isAddSupplierDialogOpen, setIsAddSupplierDialogOpen] = useState(false);
  const [newSupplierName, setNewSupplierName] = useState('');
  const [newContactPerson, setNewContactPerson] = useState('');
  const [newPhone, setNewPhone] = useState('');
  const [newEmail, setNewEmail] = useState('');
  const [newAddress, setNewAddress] = useState('');
  const [newPriceList, setNewPriceList] = useState<SupplierPriceListItem[]>([]);
  const [newPriceListUSDCash, setNewPriceListUSDCash] = useState<SupplierPriceListItem[]>([]);


  const [isEditSupplierDialogOpen, setIsEditSupplierDialogOpen] = useState(false);
  const [editingSupplier, setEditingSupplier] = useState<Supplier | null>(null);
  const [editSupplierName, setEditSupplierName] = useState('');
  const [editContactPerson, setEditContactPerson] = useState('');
  const [editPhone, setEditPhone] = useState('');
  const [editEmail, setEditEmail] = useState('');
  const [editAddress, setEditAddress] = useState('');
  const [editPriceList, setEditPriceList] = useState<SupplierPriceListItem[]>([]);
  const [editPriceListUSDCash, setEditPriceListUSDCash] = useState<SupplierPriceListItem[]>([]);

  const [isDeleteConfirmDialogOpen, setIsDeleteConfirmDialogOpen] = useState(false);
  const [supplierToDeleteId, setSupplierToDeleteId] = useState<string | null>(null);

  const [isViewPriceListDialogOpen, setIsViewPriceListDialogOpen] = useState(false);
  const [supplierForPriceListView, setSupplierForPriceListView] = useState<Supplier | null>(null);
  const [activePriceListTab, setActivePriceListTab] = useState<'default' | 'usdCash'>('default');
  
  const [editingPriceHistoryFor, setEditingPriceHistoryFor] = useState<{ supplierId: string; itemId: string; materialName: string; unit: string; listType: 'default' | 'usdCash' } | null>(null);
  const [currentPriceHistory, setCurrentPriceHistory] = useState<PriceHistoryEntry[]>([]);
  const [newPriceHistoryEntry, setNewPriceHistoryEntry] = useState<{ date: Date | undefined; price: string }>({ date: new Date(), price: '' });


  const loadData = useCallback(() => {
    setIsLoading(true);
    setCurrentSuppliers([...initialSuppliersData]);
    setAvailableRawMaterials(getCurrentRawMaterialOptions());
    setIsLoading(false);
  }, []);

  useEffect(() => {
    loadData();
    const handleDataUpdate = (event: Event) => {
      const customEvent = event as CustomEvent;
      if (customEvent.detail?.key === KEYS.SUPPLIERS || customEvent.detail?.key === KEYS.RAW_MATERIAL_OPTIONS) {
        loadData();
      }
    };
    window.addEventListener('data-updated', handleDataUpdate);
    return () => window.removeEventListener('data-updated', handleDataUpdate);
  }, [loadData]);

  const resetAddForm = () => {
    setNewSupplierName(''); setNewContactPerson(''); setNewPhone(''); setNewEmail(''); setNewAddress(''); 
    setNewPriceList([]);
    setNewPriceListUSDCash([]);
  };

  const handleAddPriceListItem = (listType: 'default' | 'usdCash', formType: 'new' | 'edit') => {
    const newItem: SupplierPriceListItem = {
      id: `pli-${Date.now()}-${listType}`,
      rawMaterialName: availableRawMaterials[0] || '',
      unit: commonUnitOptions[0] || '',
      priceHistory: [{ price: 0, date: format(new Date(), "yyyy-MM-dd") }]
    };
    if (formType === 'new') {
      if (listType === 'default') setNewPriceList(prev => [...prev, newItem]);
      else setNewPriceListUSDCash(prev => [...prev, newItem]);
    } else { // formType === 'edit'
      if (listType === 'default') setEditPriceList(prev => [...prev, newItem]);
      else setEditPriceListUSDCash(prev => [...prev, newItem]);
    }
  };

  const handleRemovePriceListItem = (index: number, listType: 'default' | 'usdCash', formType: 'new' | 'edit') => {
    const listSetter = formType === 'new' 
      ? (listType === 'default' ? setNewPriceList : setNewPriceListUSDCash)
      : (listType === 'default' ? setEditPriceList : setEditPriceListUSDCash);
    
    listSetter(prevList => prevList.filter((_, i) => i !== index));
  };


  const handlePriceListItemChange = (
    index: number,
    field: 'rawMaterialName' | 'unit' | 'currentPrice',
    value: string,
    listType: 'default' | 'usdCash',
    formType: 'new' | 'edit'
  ) => {
    const list = formType === 'new' 
      ? (listType === 'default' ? newPriceList : newPriceListUSDCash)
      : (listType === 'default' ? editPriceList : editPriceListUSDCash);
    
    const setter = formType === 'new'
      ? (listType === 'default' ? setNewPriceList : setNewPriceListUSDCash)
      : (listType === 'default' ? setEditPriceList : setEditPriceListUSDCash);

    const updatedList = [...list];
    const itemToUpdate = { ...updatedList[index] };
    itemToUpdate.priceHistory = itemToUpdate.priceHistory ? [...itemToUpdate.priceHistory] : [];

    if (field === 'rawMaterialName' || field === 'unit') {
      (itemToUpdate as any)[field] = value;
    } else if (field === 'currentPrice') {
      const newPrice = parseFloat(value) || 0;
      const today = format(new Date(), "yyyy-MM-dd");
      const existingEntryIndex = itemToUpdate.priceHistory.findIndex(ph => ph.date === today);
      if (existingEntryIndex !== -1) {
        itemToUpdate.priceHistory[existingEntryIndex].price = newPrice;
      } else {
        itemToUpdate.priceHistory.push({ price: newPrice, date: today });
      }
      itemToUpdate.priceHistory.sort((a, b) => compareDesc(parseISO(a.date), parseISO(b.date)));
    }
    updatedList[index] = itemToUpdate;
    setter(updatedList);
  };

  const handleAddSupplier = () => {
    if (!newSupplierName) {
      toast({ title: "Error", description: "El nombre es obligatorio.", variant: "destructive" }); return;
    }
    setIsSubmitting(true);
    const newSupplier: Supplier = {
      id: `SUP${Date.now().toString().slice(-4)}${Math.floor(Math.random()*100)}`,
      name: newSupplierName, contactPerson: newContactPerson, phone: newPhone, email: newEmail, address: newAddress,
      priceList: newPriceList.filter(item => item.rawMaterialName && item.priceHistory.length > 0 && item.unit),
      priceListUSDCash: newPriceListUSDCash.filter(item => item.rawMaterialName && item.priceHistory.length > 0 && item.unit)
    };
    saveSuppliersData([newSupplier, ...initialSuppliersData]);
    toast({ title: "Éxito", description: "Proveedor añadido." });
    setIsAddSupplierDialogOpen(false); resetAddForm(); setIsSubmitting(false);
  };

  const handleOpenEditDialog = (supplier: Supplier) => {
    setEditingSupplier(supplier);
    setEditSupplierName(supplier.name); setEditContactPerson(supplier.contactPerson || '');
    setEditPhone(supplier.phone || ''); setEditEmail(supplier.email || ''); setEditAddress(supplier.address || '');
    setEditPriceList(supplier.priceList && supplier.priceList.length > 0 ? JSON.parse(JSON.stringify(supplier.priceList)) : []);
    setEditPriceListUSDCash(supplier.priceListUSDCash && supplier.priceListUSDCash.length > 0 ? JSON.parse(JSON.stringify(supplier.priceListUSDCash)) : []);
    setIsEditSupplierDialogOpen(true);
  };

  const handleUpdateSupplier = () => {
    if (!editingSupplier || !editSupplierName) {
      toast({ title: "Error", description: "El nombre es obligatorio.", variant: "destructive" }); return;
    }
    setIsSubmitting(true);
    const updatedSuppliers = initialSuppliersData.map(s => 
      s.id === editingSupplier.id 
      ? { ...s, name: editSupplierName, contactPerson: editContactPerson, phone: editPhone, email: editEmail, address: editAddress,
          priceList: editPriceList.filter(item => item.rawMaterialName && item.priceHistory.length > 0 && item.unit),
          priceListUSDCash: editPriceListUSDCash.filter(item => item.rawMaterialName && item.priceHistory.length > 0 && item.unit)
        }
      : s
    );
    saveSuppliersData(updatedSuppliers);
    toast({ title: "Éxito", description: "Proveedor actualizado." });
    setIsEditSupplierDialogOpen(false); setEditingSupplier(null); setIsSubmitting(false);
  };

  const handleOpenDeleteDialog = (supplierId: string) => { setSupplierToDeleteId(supplierId); setIsDeleteConfirmDialogOpen(true); };
  const handleConfirmDelete = () => {
    if (supplierToDeleteId) {
      setIsSubmitting(true);
      saveSuppliersData(initialSuppliersData.filter(s => s.id !== supplierToDeleteId));
      toast({ title: "Éxito", description: "Proveedor eliminado." });
      setIsDeleteConfirmDialogOpen(false); setSupplierToDeleteId(null); setIsSubmitting(false);
    }
  };

  const handleOpenViewPriceListDialog = (supplier: Supplier) => {
    setSupplierForPriceListView(supplier);
    setEditingPriceHistoryFor(null);
    setActivePriceListTab('default'); // Reset to default tab
    setIsViewPriceListDialogOpen(true);
  };
  
  const handleOpenEditPriceHistoryDialog = (supplierId: string, itemId: string, materialName: string, unit: string, history: PriceHistoryEntry[], listType: 'default' | 'usdCash') => {
    setEditingPriceHistoryFor({ supplierId, itemId, materialName, unit, listType });
    const historyToSet = Array.isArray(history) ? history : [];
    setCurrentPriceHistory(JSON.parse(JSON.stringify(historyToSet.sort((a,b) => compareDesc(parseISO(a.date), parseISO(b.date))))));
    setNewPriceHistoryEntry({ date: new Date(), price: '' });
  };

  const handleSavePriceHistoryChange = () => {
    if (!editingPriceHistoryFor || !supplierForPriceListView) return;
    setIsSubmitting(true);
    const updatedSuppliers = currentSuppliers.map(s => {
      if (s.id === supplierForPriceListView.id) {
        const listNameToUpdate = editingPriceHistoryFor.listType === 'usdCash' ? 'priceListUSDCash' : 'priceList';
        const currentList = s[listNameToUpdate] || [];
        const updatedPriceList = currentList.map(item => {
          if (item.id === editingPriceHistoryFor.itemId) {
            return { ...item, priceHistory: currentPriceHistory.sort((a,b) => compareDesc(parseISO(a.date), parseISO(b.date))) };
          }
          return item;
        });
        return { ...s, [listNameToUpdate]: updatedPriceList };
      }
      return s;
    });
    saveSuppliersData(updatedSuppliers);
    setSupplierForPriceListView(updatedSuppliers.find(s => s.id === supplierForPriceListView.id) || null); // Refresh view data
    toast({ title: "Éxito", description: "Historial de precios actualizado." });
    setIsSubmitting(false);
    // No cerrar el sub-dialogo de historial aquí, permitir más ediciones.
  };
  
  const handleAddNewPriceToHistory = () => {
    if (!newPriceHistoryEntry.date || !newPriceHistoryEntry.price || !isValid(newPriceHistoryEntry.date)) {
      toast({ title: "Error", description: "Fecha válida y precio son requeridos.", variant: "destructive"});
      return;
    }
    const price = parseFloat(newPriceHistoryEntry.price);
    if (isNaN(price) || price < 0) {
      toast({ title: "Error", description: "Precio inválido.", variant: "destructive"});
      return;
    }
    const newEntry: PriceHistoryEntry = { date: format(newPriceHistoryEntry.date, "yyyy-MM-dd"), price };
    const updatedHistory = [...currentPriceHistory, newEntry].sort((a,b) => compareDesc(parseISO(a.date), parseISO(b.date)));
    setCurrentPriceHistory(updatedHistory);
    setNewPriceHistoryEntry({ date: new Date(), price: '' }); 
  };

  const handleRemovePriceFromHistory = (dateToRemove: string) => {
    setCurrentPriceHistory(prev => prev.filter(ph => ph.date !== dateToRemove).sort((a,b) => compareDesc(parseISO(a.date), parseISO(b.date))));
  };

  const renderPriceListSection = (
    priceList: SupplierPriceListItem[], 
    listType: 'default' | 'usdCash',
    formType: 'new' | 'edit'
  ) => (
    <div className="space-y-3 border p-3 rounded-md">
      <Label className="text-base font-medium">
        {listType === 'default' ? 'Lista de Precios Estándar' : 'Lista de Precios (USD Efectivo)'}
      </Label>
      {priceList.map((item, index) => {
        const currentPriceEntry = getCurrentPriceFromHistory(item.priceHistory);
        const displayPrice = currentPriceEntry ? parseFloat(currentPriceEntry.price.toFixed(4)).toString() : '';
        return (
        <div key={item.id || `item-${listType}-${formType}-${index}`} className="grid grid-cols-12 gap-2 items-end border-b pb-2 mb-2 last:border-b-0 last:pb-0 last:mb-0">
          <div className="col-span-12 sm:col-span-4 space-y-1">
            {index === 0 && <Label htmlFor={`pl_material_${listType}_${formType}_${index}`} className="text-xs">Materia Prima</Label>}
            <Select 
              value={item.rawMaterialName} 
              onValueChange={(value) => handlePriceListItemChange(index, 'rawMaterialName', value, listType, formType)} 
              disabled={isSubmitting || availableRawMaterials.length === 0}
            >
              <SelectTrigger id={`pl_material_${listType}_${formType}_${index}`} className="h-9"><SelectValue placeholder="Material" /></SelectTrigger>
              <SelectContent>
                {availableRawMaterials.length > 0 ?
                  availableRawMaterials.map(option => <SelectItem key={option} value={option}>{option}</SelectItem>) :
                  <SelectItem value="no-options" disabled>No hay materias primas</SelectItem>
                }
              </SelectContent>
            </Select>
          </div>
          <div className="col-span-6 sm:col-span-3 space-y-1">
            {index === 0 && <Label htmlFor={`pl_price_${listType}_${formType}_${index}`} className="text-xs">Precio Actual (USD)</Label>}
            <Input 
              id={`pl_price_${listType}_${formType}_${index}`} 
              type="number" 
              placeholder="Precio" 
              value={displayPrice} 
              onChange={(e) => handlePriceListItemChange(index, 'currentPrice', e.target.value, listType, formType)} 
              disabled={isSubmitting}
              className="h-9" min="0" step="0.0001"
            />
          </div>
          <div className="col-span-6 sm:col-span-3 space-y-1">
            {index === 0 && <Label htmlFor={`pl_unit_${listType}_${formType}_${index}`} className="text-xs">Unidad</Label>}
            <Select 
              value={item.unit} 
              onValueChange={(value) => handlePriceListItemChange(index, 'unit', value, listType, formType)}
              disabled={isSubmitting}
            >
              <SelectTrigger id={`pl_unit_${listType}_${formType}_${index}`} className="h-9"><SelectValue placeholder="Unidad" /></SelectTrigger>
              <SelectContent>{commonUnitOptions.map(option => <SelectItem key={option} value={option}>{option}</SelectItem>)}</SelectContent>
            </Select>
          </div>
          <div className="col-span-12 sm:col-span-2 flex items-end justify-end">
            <Button type="button" variant="ghost" size="icon" onClick={() => handleRemovePriceListItem(index, listType, formType)} className="h-9 w-9 text-destructive hover:bg-destructive/10" disabled={isSubmitting}>
              <Trash className="h-4 w-4" />
            </Button>
          </div>
        </div>
      )})}
      <Button type="button" variant="outline" size="sm" onClick={() => handleAddPriceListItem(listType, formType)} className="mt-2" disabled={isSubmitting || availableRawMaterials.length === 0}>
        <ListPlus className="mr-2 h-4 w-4" /> Añadir Artículo
      </Button>
      {availableRawMaterials.length === 0 && <p className="text-xs text-destructive pt-1">Añada materias primas en Órdenes de Compra.</p>}
    </div>
  );

  if (isLoading) return (<div className="flex items-center justify-center min-h-[calc(100vh-10rem)]"><Loader2 className="h-12 w-12 animate-spin text-primary" /><p className="ml-4 text-lg">Cargando...</p></div>);

  return (
    <div className="space-y-6">
      <PageHeader title="Gestión de Proveedores" description="Administra información y listas de precios estándar y para pagos en USD Efectivo." icon={Building}
        actions={<Button onClick={() => { resetAddForm(); setIsAddSupplierDialogOpen(true); }} disabled={isSubmitting}><PlusCircle className="mr-2 h-4 w-4" />Añadir Proveedor</Button>}
      />
      <Card className="shadow-lg">
        <CardHeader><CardTitle>Lista de Proveedores</CardTitle><CardDescription>Contacto y precios.</CardDescription></CardHeader>
        <CardContent>
          <Table>
            <TableHeader><TableRow><TableHead>Proveedor</TableHead><TableHead>Contacto</TableHead><TableHead>Teléfono</TableHead><TableHead>Email</TableHead><TableHead>Dirección</TableHead><TableHead className="text-right">Acciones</TableHead></TableRow></TableHeader>
            <TableBody>
              {currentSuppliers.map((s) => (
                <TableRow key={s.id}>
                  <TableCell className="font-medium">{s.name}</TableCell><TableCell>{s.contactPerson||'-'}</TableCell><TableCell>{s.phone||'-'}</TableCell><TableCell>{s.email||'-'}</TableCell><TableCell>{s.address||'-'}</TableCell>
                  <TableCell className="text-right">
                    <DropdownMenu><DropdownMenuTrigger asChild><Button variant="ghost" size="icon" disabled={isSubmitting}><MoreHorizontal className="h-4 w-4"/></Button></DropdownMenuTrigger>
                      <DropdownMenuContent align="end">
                        <DropdownMenuItem onClick={()=>handleOpenViewPriceListDialog(s)} disabled={isSubmitting}><Eye className="mr-2 h-4 w-4"/>Ver Listas Precios</DropdownMenuItem>
                        <DropdownMenuItem onClick={()=>handleOpenEditDialog(s)} disabled={isSubmitting}><Edit className="mr-2 h-4 w-4"/>Editar</DropdownMenuItem>
                        <DropdownMenuItem onClick={()=>handleOpenDeleteDialog(s.id)} className="text-destructive focus:text-destructive-foreground focus:bg-destructive" disabled={isSubmitting}><Trash2 className="mr-2 h-4 w-4"/>Eliminar</DropdownMenuItem>
                      </DropdownMenuContent>
                    </DropdownMenu>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
          {currentSuppliers.length===0 && !isLoading && <p className="text-center text-muted-foreground py-8">No hay proveedores.</p>}
        </CardContent>
      </Card>

      <Dialog open={isAddSupplierDialogOpen} onOpenChange={(isOpen) => { if(!isSubmitting) setIsAddSupplierDialogOpen(isOpen); }}>
        <DialogContent className="sm:max-w-3xl">
          <DialogHeader><DialogTitle>Añadir Proveedor</DialogTitle><DialogDescription>Detalles y listas de precios.</DialogDescription></DialogHeader>
          <ScrollArea className="max-h-[calc(80vh-220px)] p-1 pr-3">
            <div className="grid gap-4 py-4">
              <div className="space-y-1"><Label htmlFor="new_supplier_name">Nombre</Label><Input id="new_supplier_name" value={newSupplierName} onChange={(e)=>setNewSupplierName(e.target.value)} placeholder="Harinas S.A." disabled={isSubmitting}/></div>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="space-y-1"><Label htmlFor="new_contact_person">Contacto</Label><Input id="new_contact_person" value={newContactPerson} onChange={(e)=>setNewContactPerson(e.target.value)} placeholder="Ana R." disabled={isSubmitting}/></div>
                <div className="space-y-1"><Label htmlFor="new_phone">Teléfono</Label><Input id="new_phone" type="tel" value={newPhone} onChange={(e)=>setNewPhone(e.target.value)} placeholder="555-1234" disabled={isSubmitting}/></div>
              </div>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="space-y-1"><Label htmlFor="new_email">Email</Label><Input id="new_email" type="email" value={newEmail} onChange={(e)=>setNewEmail(e.target.value)} placeholder="contacto@a.com" disabled={isSubmitting}/></div>
                <div className="space-y-1"><Label htmlFor="new_address">Dirección</Label><Input id="new_address" value={newAddress} onChange={(e)=>setNewAddress(e.target.value)} placeholder="Av. Principal" disabled={isSubmitting}/></div>
              </div>
              <Tabs defaultValue="defaultPrices" className="w-full">
                <TabsList className="grid w-full grid-cols-2">
                  <TabsTrigger value="defaultPrices">Precios Estándar</TabsTrigger>
                  <TabsTrigger value="usdCashPrices">Precios USD Efectivo</TabsTrigger>
                </TabsList>
                <TabsContent value="defaultPrices" className="mt-2">{renderPriceListSection(newPriceList, 'default', 'new')}</TabsContent>
                <TabsContent value="usdCashPrices" className="mt-2">{renderPriceListSection(newPriceListUSDCash, 'usdCash', 'new')}</TabsContent>
              </Tabs>
            </div>
          </ScrollArea>
          <DialogFooter className="pt-4 border-t"><DialogClose asChild><Button variant="outline" disabled={isSubmitting}>Cancelar</Button></DialogClose><Button onClick={handleAddSupplier} disabled={isSubmitting}>{isSubmitting?<Loader2 className="mr-2 h-4 w-4 animate-spin"/>:<PlusCircle className="mr-2 h-4 w-4"/>}{isSubmitting?'Guardando...':'Guardar'}</Button></DialogFooter>
        </DialogContent>
      </Dialog>

      <Dialog open={isEditSupplierDialogOpen} onOpenChange={(isOpen) => { if(!isSubmitting) setIsEditSupplierDialogOpen(isOpen); }}>
        <DialogContent className="sm:max-w-3xl">
          <DialogHeader><DialogTitle>Editar Proveedor</DialogTitle><DialogDescription>Actualizar detalles y listas de precios.</DialogDescription></DialogHeader>
          <ScrollArea className="max-h-[calc(80vh-220px)] p-1 pr-3">
            <div className="grid gap-4 py-4">
              <div className="space-y-1"><Label htmlFor="edit_supplier_name">Nombre</Label><Input id="edit_supplier_name" value={editSupplierName} onChange={(e)=>setEditSupplierName(e.target.value)} disabled={isSubmitting}/></div>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="space-y-1"><Label htmlFor="edit_contact_person">Contacto</Label><Input id="edit_contact_person" value={editContactPerson} onChange={(e)=>setEditContactPerson(e.target.value)} disabled={isSubmitting}/></div>
                <div className="space-y-1"><Label htmlFor="edit_phone">Teléfono</Label><Input id="edit_phone" type="tel" value={editPhone} onChange={(e)=>setEditPhone(e.target.value)} disabled={isSubmitting}/></div>
              </div>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="space-y-1"><Label htmlFor="edit_email">Email</Label><Input id="edit_email" type="email" value={editEmail} onChange={(e)=>setEditEmail(e.target.value)} disabled={isSubmitting}/></div>
                <div className="space-y-1"><Label htmlFor="edit_address">Dirección</Label><Input id="edit_address" value={editAddress} onChange={(e)=>setEditAddress(e.target.value)} disabled={isSubmitting}/></div>
              </div>
              <Tabs defaultValue="defaultPrices" className="w-full">
                <TabsList className="grid w-full grid-cols-2">
                  <TabsTrigger value="defaultPrices">Precios Estándar</TabsTrigger>
                  <TabsTrigger value="usdCashPrices">Precios USD Efectivo</TabsTrigger>
                </TabsList>
                <TabsContent value="defaultPrices" className="mt-2">{renderPriceListSection(editPriceList, 'default', 'edit')}</TabsContent>
                <TabsContent value="usdCashPrices" className="mt-2">{renderPriceListSection(editPriceListUSDCash, 'usdCash', 'edit')}</TabsContent>
              </Tabs>
            </div>
          </ScrollArea>
          <DialogFooter className="pt-4 border-t"><DialogClose asChild><Button variant="outline" disabled={isSubmitting}>Cancelar</Button></DialogClose><Button onClick={handleUpdateSupplier} disabled={isSubmitting}>{isSubmitting?<Loader2 className="mr-2 h-4 w-4 animate-spin"/>:<Edit className="mr-2 h-4 w-4"/>}{isSubmitting?'Guardando...':'Guardar Cambios'}</Button></DialogFooter>
        </DialogContent>
      </Dialog>

      <Dialog open={isDeleteConfirmDialogOpen} onOpenChange={(isOpen)=>{if(!isSubmitting)setIsDeleteConfirmDialogOpen(isOpen)}}><DialogContent className="sm:max-w-md"><DialogHeader><DialogTitle>Confirmar Eliminación</DialogTitle><DialogDescription>¿Eliminar este proveedor?</DialogDescription></DialogHeader><DialogFooter className="sm:justify-end"><DialogClose asChild><Button variant="outline" disabled={isSubmitting}>Cancelar</Button></DialogClose><Button variant="destructive" onClick={handleConfirmDelete} disabled={isSubmitting}>{isSubmitting?<Loader2 className="mr-2 h-4 w-4 animate-spin"/>:<Trash2 className="mr-2 h-4 w-4"/>}{isSubmitting?'Eliminando...':'Eliminar'}</Button></DialogFooter></DialogContent></Dialog>
      
      <Dialog open={isViewPriceListDialogOpen} onOpenChange={(isOpen) => { if (!isSubmitting) { setIsViewPriceListDialogOpen(isOpen); if (!isOpen) setEditingPriceHistoryFor(null); } }}>
        <DialogContent className="sm:max-w-3xl flex flex-col max-h-[85vh]">
          <DialogHeader className="flex-shrink-0">
            <DialogTitle>Listas de Precios de: {supplierForPriceListView?.name}</DialogTitle>
          </DialogHeader>
          <Tabs value={activePriceListTab} onValueChange={(value) => setActivePriceListTab(value as 'default' | 'usdCash')} className="w-full mt-2 flex flex-col flex-1 min-h-0">
            <TabsList className="grid w-full grid-cols-2 flex-shrink-0">
              <TabsTrigger value="default">Precios Estándar</TabsTrigger>
              <TabsTrigger value="usdCash">Precios USD Efectivo</TabsTrigger>
            </TabsList>
            <TabsContent value="default" className="flex-1 overflow-y-auto p-4">
                {renderPriceHistoryList(supplierForPriceListView?.priceList || [], 'default')}
            </TabsContent>
            <TabsContent value="usdCash" className="flex-1 overflow-y-auto p-4">
                {renderPriceHistoryList(supplierForPriceListView?.priceListUSDCash || [], 'usdCash')}
            </TabsContent>
          </Tabs>
          <DialogFooter className="pt-4 border-t flex-shrink-0">
            <Button variant="outline" onClick={() => { if(!isSubmitting) { setIsViewPriceListDialogOpen(false); setEditingPriceHistoryFor(null); } }} disabled={isSubmitting}>
              {editingPriceHistoryFor ? "Cerrar Edición de Historial" : "Cerrar Vista de Precios"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );

  function renderPriceHistoryList(priceList: SupplierPriceListItem[], listType: 'default' | 'usdCash') {
    return priceList.length > 0 ? (
      priceList.map(item => (
        <Card key={item.id} className="mb-3">
          <CardHeader className="pb-2 pt-3 px-4">
            <div className="flex justify-between items-center">
              <CardTitle className="text-base">{item.rawMaterialName} <span className="text-sm text-muted-foreground">({item.unit})</span></CardTitle>
              <Button variant="ghost" size="sm" onClick={() => handleOpenEditPriceHistoryDialog(supplierForPriceListView!.id, item.id, item.rawMaterialName, item.unit, item.priceHistory, listType)} disabled={isSubmitting || editingPriceHistoryFor?.itemId === item.id && editingPriceHistoryFor?.listType === listType}>
                 <Edit className="mr-1 h-3 w-3"/> {editingPriceHistoryFor?.itemId === item.id && editingPriceHistoryFor?.listType === listType ? "Editando..." : "Historial"}
              </Button>
            </div>
            <CardDescription>
                Precio Actual: <strong><FormattedNumber value={getCurrentPriceFromHistory(item.priceHistory)?.price} prefix="$" decimalPlaces={4}/></strong> (Actualizado: {getCurrentPriceFromHistory(item.priceHistory)?.date ? format(parseISO(getCurrentPriceFromHistory(item.priceHistory)!.date), "dd/MM/yy", {locale: es}) : 'N/A'})
            </CardDescription>
          </CardHeader>
          {editingPriceHistoryFor?.itemId === item.id && editingPriceHistoryFor?.listType === listType && (
          <CardContent className="px-4 pb-3 pt-1">
            <Label className="text-xs font-semibold">Historial de Precios:</Label>
            <div className="max-h-32 overflow-y-auto border rounded-md p-2 mt-1 text-xs space-y-1">
                {currentPriceHistory.length > 0 ? currentPriceHistory.map((entry, index) => {
                    let comparisonText = null;
                    if (index < currentPriceHistory.length - 1) {
                      const previousEntry = currentPriceHistory[index + 1];
                      const priceDiff = entry.price - previousEntry.price;
                      const percentageDiff = previousEntry.price !== 0 ? (priceDiff / previousEntry.price) * 100 : (entry.price > 0 ? 100 : 0);
                      const timeDiffStr = formatDistanceStrict(parseISO(entry.date), parseISO(previousEntry.date), { locale: es, addSuffix: false });
                      const diffColor = priceDiff > 0 ? "text-red-500 dark:text-red-400" : priceDiff < 0 ? "text-green-500 dark:text-green-400" : "text-muted-foreground";
                      comparisonText = (
                        <span className={cn("text-[0.7rem] ml-1", diffColor)}>
                          (<FormattedNumber value={priceDiff} prefix={priceDiff > 0 ? '+' : ''} decimalPlaces={4} />
                          {` / ${priceDiff > 0 ? '+' : ''}${percentageDiff.toFixed(1)}% tras ${timeDiffStr}`})
                        </span>
                      );
                    }
                    return (
                      <div key={`${entry.date}-${index}`} className="flex justify-between items-center hover:bg-muted/50 p-0.5 rounded-sm">
                        <div>
                          <span className="font-medium">{format(parseISO(entry.date), "dd/MM/yy", {locale: es})}: <FormattedNumber value={entry.price} prefix="$" decimalPlaces={4}/></span>
                          {comparisonText}
                        </div>
                        <Button variant="ghost" size="icon" className="h-5 w-5 text-destructive/70 hover:bg-destructive/10" onClick={() => handleRemovePriceFromHistory(entry.date)} disabled={isSubmitting}><Trash className="h-3 w-3"/></Button>
                      </div>
                    );
                }) : <p className="text-muted-foreground text-center text-xs py-1">Sin historial para este ítem.</p>}
            </div>
            <div className="mt-2 flex items-end space-x-2">
                <div className="flex-grow space-y-0.5">
                    <Label htmlFor="new_ph_date_view" className="text-xs">Fecha</Label>
                    <Popover><PopoverTrigger asChild><Button id="new_ph_date_view" variant="outline" size="sm" className="w-full justify-start text-left font-normal h-8 text-xs" disabled={isSubmitting}><CalendarIcon className="mr-1 h-3 w-3"/>{newPriceHistoryEntry.date ? format(newPriceHistoryEntry.date,"dd/MM/yy", {locale: es}) : "Elige"}</Button></PopoverTrigger><PopoverContent className="w-auto p-0"><Calendar mode="single" selected={newPriceHistoryEntry.date} onSelect={d => setNewPriceHistoryEntry(p=>({...p, date:d}))} initialFocus locale={es} disabled={isSubmitting}/></PopoverContent></Popover>
                </div>
                <div className="space-y-0.5">
                    <Label htmlFor="new_ph_price_view" className="text-xs">Precio (USD)</Label>
                    <Input id="new_ph_price_view" type="number" value={newPriceHistoryEntry.price} onChange={e=>setNewPriceHistoryEntry(p=>({...p,price:e.target.value}))} className="h-8 text-xs" placeholder="Ej: 10.50" disabled={isSubmitting} step="0.0001"/>
                </div>
                <Button size="sm" onClick={handleAddNewPriceToHistory} className="h-8 text-xs" disabled={isSubmitting}><PlusCircle className="mr-1 h-3 w-3"/>Añadir</Button>
            </div>
            <Button size="sm" onClick={handleSavePriceHistoryChange} className="w-full mt-3 h-8 text-xs" disabled={isSubmitting}>{isSubmitting?<Loader2 className="mr-1 h-3 w-3 animate-spin"/>:"Guardar Cambios al Historial"}</Button>
          </CardContent>
          )}
        </Card>
      ))
    ) : (<p className="text-muted-foreground py-4 text-center">No hay precios en esta lista para {supplierForPriceListView?.name}.</p>);
  }
}

// --- user-management ---


"use client";

import React, { useState, useEffect } from 'react';
import { PageHeader } from '@/components/page-header';
// import { Button } from '@/components/ui/button'; // No se usa el botón de añadir
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
// import {
//   Table,
//   TableBody,
//   TableCell,
//   TableHead,
//   TableHeader,
//   TableRow,
// } from "@/components/ui/table";
// import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter, DialogClose } from '@/components/ui/dialog';
// import { Input } from '@/components/ui/input';
// import { Label } from '@/components/ui/label';
// import { Checkbox } from '@/components/ui/checkbox';
// import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { UserCog } from 'lucide-react'; // Solo se usa UserCog
// import { useToast } from "@/hooks/use-toast";
// import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';
// import { Separator } from '@/components/ui/separator';
// import { 
//   type ManagedUser, 
//   type UserPermissions, 
//   availableModulesForPermissions,
// } from '@/lib/data-storage'; // Ya no se gestionan múltiples usuarios aquí


export default function UserManagementPage() {
  // const { toast } = useToast(); // No se usa
  // const [users, setUsers] = useState<ManagedUser[]>([]); // No se usa

  // // Diálogos y estados relacionados eliminados ya que no hay gestión de usuarios múltiples

  // useEffect(() => {
  //   // No se cargan usuarios múltiples
  // }, []);

  return (
    <div className="space-y-6">
      <PageHeader
        title="Gestión de Usuarios"
        description="Este módulo está deshabilitado en la configuración actual de usuario único (admin)."
        icon={UserCog} 
        // actions={ // Botón de añadir eliminado
        //   <Button onClick={() => { resetAddForm(); setIsAddUserDialogOpen(true); }}>
        //     <PlusCircle className="mr-2 h-4 w-4" />
        //     Añadir Nuevo Usuario
        //   </Button>
        // }
      />

      <Card className="shadow-lg">
        <CardHeader>
          <CardTitle>Información</CardTitle>
          <CardDescription>La gestión de múltiples usuarios y roles no está activa.</CardDescription>
        </CardHeader>
        <CardContent>
          <p className="text-muted-foreground">
            La aplicación está configurada para un único usuario administrador con acceso completo.
            Para gestionar múltiples usuarios, roles y permisos detallados, se requeriría una
            configuración de backend y autenticación más avanzada.
          </p>
        </CardContent>
      </Card>

      {/* Diálogos de Añadir, Editar y Eliminar usuario eliminados */}
    </div>
  );
}
