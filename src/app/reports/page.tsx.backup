

"use client";

import React, { useState, useEffect, useMemo } from 'react';
import { PageHeader } from '@/components/page-header';
import { Card, CardContent, CardDescription, CardHeader, CardTitle, CardFooter } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { FileText, Download, CalendarDays, Package, Calendar as CalendarIcon, DollarSign, Archive, Layers, BarChart2 as BarChartIconLucide, PieChart as PieChartIconLucide, Loader2, Shuffle, TrendingDown, Combine, Building, Eye, TrendingUp as TrendingUpIcon, Image as ImageIcon } from 'lucide-react';
import { useToast } from "@/hooks/use-toast";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter as UiDialogFooter, DialogClose } from '@/components/ui/dialog';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Calendar } from "@/components/ui/calendar";
import type { DateRange } from "react-day-picker";
import { format, parseISO, isWithinInterval, startOfDay, endOfDay, isValid, differenceInCalendarWeeks, startOfWeek, endOfWeek, subDays, startOfMonth, endOfMonth, startOfQuarter, endOfQuarter, subMonths } from "date-fns";
import { es } from "date-fns/locale";
import { cn } from "@/lib/utils";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  salesData as initialSalesDataGlobal,
  type Sale,
  type Expense,
  type Product,
  loadExchangeRate,
  type PurchaseOrder,
  type RawMaterialInventoryItem,
  type Recipe,
  calculateDynamicRecipeCost,
  type Employee,
  loadExpenseFixedCategories,
  type ExpenseFixedCategory,
  WEEKS_IN_MONTH,
  getActiveBranchId,
  availableBranches,
  loadFromLocalStorageForBranch,
  loadExpenseVariableCategories,
  KEYS,
  calculatePackagingCost,
  weeklyLossReportsData as initialWeeklyLossReportsData,
  type WeeklyLossReport,
  weeklyProfitReportsData as initialWeeklyProfitReportsData,
  type WeeklyProfitReport,
  type ProductionLogEntry,
  type ProfitEntry
} from '@/lib/data-storage';
import jsPDF from 'jspdf';
import 'jspdf-autotable';
import html2canvas from 'html2canvas';
import {
  Bar,
  BarChart,
  Pie,
  PieChart,
  Cell,
  CartesianGrid,
  XAxis,
  YAxis,
  Tooltip as RechartsTooltip,
  Legend as RechartsLegend,
  ResponsiveContainer
} from "recharts";
import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { ScrollArea } from '@/components/ui/scroll-area';
import { FormattedNumber } from '@/components/ui/formatted-number';


interface jsPDFWithAutoTable extends jsPDF {
  autoTable: (options: any) => jsPDFWithAutoTable;
}

interface ProductSalesQuantityData { name: string; quantity: number; }
interface ProductChangeData { name: string; quantity: number; }
interface ExpenseChartData { category: string; total: number; fill: string; }
interface StockChartData { name: string; stock: number; }
interface PurchaseOrderChartData { supplierName: string; totalCost: number; }

interface ProductWastageData {
  name: string;
  totalExpected: number;
  totalActual: number;
  totalWastageQuantity: number;
  totalWastageCostUSD: number;
  baseUnitPriceForWastage?: number;
}

interface ProductLossItem {
  name: string;
  quantityChanged: number;
  costChangedUSD: number;
  quantityWasted: number;
  costWastedUSD: number;
  quantitySampled: number;
  costSampledUSD: number;
  totalQuantityLost: number;
  totalCostLostUSD: number;
}

// --- Phase 4: Advanced Reports Interfaces ---
interface ProductProfitability {
  id: string;
  name: string;
  totalSold: number;
  totalRevenue: number;
  totalCost: number;
  totalProfit: number;
  marginPercent: number;
}

interface CustomerStats {
  id: string;
  name: string;
  totalOrders: number;
  totalSpent: number;
  lastOrderDate: string;
  averageTicket: number;
}

interface InventoryHealth {
  id: string;
  name: string;
  currentStock: number;
  dailySalesVelocity: number; // Average sales per day (last 30 days)
  daysCoverage: number;
  status: 'Critical' | 'Low' | 'Healthy' | 'Overstock';
  suggestedRestock: number;
}


const PIE_CHART_COLORS = [
  "hsl(var(--chart-1))", "hsl(var(--chart-2))", "hsl(var(--chart-3))",
  "hsl(var(--chart-4))", "hsl(var(--chart-5))",
  "hsl(var(--primary))", "hsl(var(--accent))", "hsl(var(--secondary))"
];
const TOP_N_PRODUCTS_REPORTS = 10;
const TOP_N_CHANGES_REPORTS = 10;
const TOP_N_WASTAGE_PRODUCTS_REPORTS = 10;
const TOP_N_LOSSES_REPORTS = 10;


export default function ReportsPage() {
  const { toast } = useToast();
  const [isDateRangeDialogOpen, setIsDateRangeDialogOpen] = useState(false);
  const [selectedDateRange, setSelectedDateRange] = React.useState<DateRange | undefined>(undefined);
  const [exchangeRate, setExchangeRate] = useState<number>(0);
  const [isLoading, setIsLoading] = useState(true);
  const [activeBranchName, setActiveBranchName] = useState<string>('');
  const [activeBranchIdState, setActiveBranchIdState] = useState<string | null>(null);

  const [weeklyLossReports, setWeeklyLossReports] = useState<WeeklyLossReport[]>([]);
  const [isLossReportDialogOpen, setIsLossReportDialogOpen] = useState(false);
  const [selectedLossReport, setSelectedLossReport] = useState<WeeklyLossReport | null>(null);

  const [weeklyProfitReports, setWeeklyProfitReports] = useState<WeeklyProfitReport[]>([]);
  const [isProfitReportDialogOpen, setIsProfitReportDialogOpen] = useState(false);
  const [selectedProfitReport, setSelectedProfitReport] = useState<WeeklyProfitReport | null>(null);


  useEffect(() => {
    setExchangeRate(loadExchangeRate());
    const currentBranchId = getActiveBranchId();
    setActiveBranchIdState(currentBranchId);
    const branch = availableBranches.find(b => b.id === currentBranchId);
    setActiveBranchName(branch ? branch.name : 'Desconocida');
    setWeeklyLossReports(initialWeeklyLossReportsData);
    setWeeklyProfitReports(initialWeeklyProfitReportsData);
    setIsLoading(false);

    const handleDataUpdate = (event: Event) => {
      const customEvent = event as CustomEvent;
      if (customEvent.detail?.key === KEYS.WEEKLY_LOSS_REPORTS) {
        setWeeklyLossReports([...initialWeeklyLossReportsData]);
      }
      if (customEvent.detail?.key === KEYS.WEEKLY_PROFIT_REPORTS) {
        setWeeklyProfitReports([...initialWeeklyProfitReportsData]);
      }
    };
    window.addEventListener('data-updated', handleDataUpdate);
    return () => {
      window.removeEventListener('data-updated', handleDataUpdate);
    };
  }, []);

  const formatVesPrice = (usdPrice: number): string => {
    if (exchangeRate > 0 && usdPrice) {
      return `Bs. ${(usdPrice * exchangeRate).toFixed(2)}`;
    }
    return "Bs. --";
  };

  const getReportFilename = (baseName: string): string => {
    const today = format(new Date(), "yyyy-MM-dd");
    let branchSuffix = '';
    const currentBranchId = getActiveBranchId();
    if (baseName.includes("gastos") || baseName.includes("stock") || baseName.includes("materia_prima") || baseName.includes("ordenes_compra") || baseName.includes("merma") || baseName.includes("perdidas")) {
      if (currentBranchId) branchSuffix = `_${currentBranchId}`;
    }

    if (selectedDateRange?.from) {
      const from = format(selectedDateRange.from, "yyyy-MM-dd");
      if (selectedDateRange.to) {
        const to = format(selectedDateRange.to, "yyyy-MM-dd");
        return `${baseName}${branchSuffix}_${from}_a_${to}.pdf`;
      }
      return `${baseName}${branchSuffix}_${from}.pdf`;
    }
    return `${baseName}${branchSuffix}_general_${today}.pdf`;
  };

  const productSalesQuantityChartData = useMemo(() => {
    let filteredSales = initialSalesDataGlobal;
    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      filteredSales = initialSalesDataGlobal.filter(sale => {
        const saleDate = parseISO(sale.date);
        return isValid(saleDate) && isWithinInterval(saleDate, { start: from, end: to });
      });
    }

    const productSales: { [productName: string]: number } = {};
    filteredSales.forEach(sale => {
      sale.itemsPerBranch.forEach(branchDetail => {
        branchDetail.items.forEach(item => {
          if (item.productName) {
            productSales[item.productName] = (productSales[item.productName] || 0) + item.quantity;
          }
        });
      });
    });

    return Object.entries(productSales)
      .map(([name, quantity]) => ({ name, quantity }))
      .sort((a, b) => b.quantity - a.quantity)
      .slice(0, TOP_N_PRODUCTS_REPORTS);
  }, [selectedDateRange]);

  const productSalesQuantityChartConfig = {
    quantity: { label: "Cantidad Vendida", color: "hsl(var(--chart-1))" },
  } satisfies ChartConfig;

  const productChangesChartData = useMemo(() => {
    let filteredSales = initialSalesDataGlobal;
    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      filteredSales = initialSalesDataGlobal.filter(sale => {
        const saleDate = parseISO(sale.date);
        return isValid(saleDate) && isWithinInterval(saleDate, { start: from, end: to });
      });
    }

    const productChanges: { [productName: string]: number } = {};
    filteredSales.forEach(sale => {
      if (sale.changes) {
        sale.changes.forEach(item => {
          if (item.productName) {
            productChanges[item.productName] = (productChanges[item.productName] || 0) + item.quantity;
          }
        });
      }
    });

    return Object.entries(productChanges)
      .map(([name, quantity]) => ({ name, quantity }))
      .sort((a, b) => b.quantity - a.quantity)
      .slice(0, TOP_N_CHANGES_REPORTS);
  }, [selectedDateRange]);

  const productChangesChartConfig = {
    quantity: { label: "Cantidad Cambiada/Devuelta", color: "hsl(var(--chart-5))" },
  } satisfies ChartConfig;

  const expensesChartData = useMemo(() => {
    if (!activeBranchIdState) return [];
    let branchExpenses = loadFromLocalStorageForBranch<Expense[]>(KEYS.EXPENSES, activeBranchIdState);
    let filteredExpenses = branchExpenses;

    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      filteredExpenses = branchExpenses.filter(expense => {
        const expenseDate = parseISO(expense.date);
        return isValid(expenseDate) && isWithinInterval(expenseDate, { start: from, end: to });
      });
    }
    const expensesByCategory: { [category: string]: number } = {};
    const fixedCats = loadExpenseFixedCategories(activeBranchIdState);
    const varCats = loadExpenseVariableCategories(activeBranchIdState);
    const allBranchCategories = [...fixedCats.map(fc => fc.name), ...varCats];

    allBranchCategories.forEach(cat => expensesByCategory[cat] = 0);

    filteredExpenses.forEach(expense => {
      if (expensesByCategory.hasOwnProperty(expense.category)) {
        expensesByCategory[expense.category] = (expensesByCategory[expense.category] || 0) + expense.amount;
      } else if (expense.category === 'Compra de Materia Prima') {
        expensesByCategory[expense.category] = (expensesByCategory[expense.category] || 0) + expense.amount;
      }
    });

    return Object.entries(expensesByCategory)
      .filter(([_, total]) => total > 0)
      .map(([category, total], index) => ({
        category,
        total: parseFloat(total.toFixed(2)),
        fill: PIE_CHART_COLORS[index % PIE_CHART_COLORS.length],
      }));
  }, [selectedDateRange, activeBranchIdState]);

  const expensesChartConfig = useMemo(() =>
    expensesChartData.reduce((acc, item) => {
      acc[item.category] = { label: item.category, color: item.fill };
      return acc;
    }, {} as ChartConfig)
    , [expensesChartData]);

  const productStockChartData = useMemo(() => {
    if (!activeBranchIdState) return [];
    const productsForBranch = loadFromLocalStorageForBranch<Product[]>(KEYS.PRODUCTS, activeBranchIdState);
    return productsForBranch
      .filter(p => p.stock > 0)
      .sort((a, b) => b.stock - a.stock)
      .slice(0, 10)
      .map(product => ({
        name: product.name,
        stock: product.stock,
      }));
  }, [activeBranchIdState]);

  const productStockChartConfig = {
    stock: { label: "Stock", color: "hsl(var(--chart-2))" },
  } satisfies ChartConfig;

  const rawMaterialStockChartData = useMemo(() => {
    if (!activeBranchIdState) return [];
    const rawMaterialsForBranch = loadFromLocalStorageForBranch<RawMaterialInventoryItem[]>(KEYS.RAW_MATERIAL_INVENTORY, activeBranchIdState);
    return rawMaterialsForBranch
      .filter(m => m.quantity > 0)
      .sort((a, b) => b.quantity - a.quantity)
      .slice(0, 10)
      .map(material => ({
        name: `${material.name} (${material.unit})`,
        stock: parseFloat(material.quantity.toFixed(2)),
      }));
  }, [activeBranchIdState]);

  const rawMaterialStockChartConfig = {
    stock: { label: "Cantidad", color: "hsl(var(--chart-3))" },
  } satisfies ChartConfig;

  const purchaseOrdersChartData = useMemo(() => {
    if (!activeBranchIdState) return [];
    const ordersForBranch = loadFromLocalStorageForBranch<PurchaseOrder[]>(KEYS.PURCHASE_ORDERS, activeBranchIdState);
    let filteredOrders = ordersForBranch;
    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      filteredOrders = ordersForBranch.filter(po => {
        const orderDate = parseISO(po.orderDate);
        return isValid(orderDate) && isWithinInterval(orderDate, { start: from, end: to });
      });
    }
    const ordersBySupplier: { [supplierName: string]: number } = {};
    filteredOrders.forEach(order => {
      if (order.status === 'Pagado') {
        ordersBySupplier[order.supplierName] = (ordersBySupplier[order.supplierName] || 0) + order.totalCost;
      }
    });
    return Object.entries(ordersBySupplier)
      .map(([supplierName, totalCost]) => ({
        supplierName,
        totalCost: parseFloat(totalCost.toFixed(2)),
      }))
      .sort((a, b) => b.totalCost - a.totalCost)
      .slice(0, 10);
  }, [selectedDateRange, activeBranchIdState]);

  const purchaseOrdersChartConfig = {
    totalCost: { label: "Costo Total (USD)", color: "hsl(var(--chart-4))" },
  } satisfies ChartConfig;

  const wastageReportFullData = useMemo(() => {
    if (!activeBranchIdState) return [];
    const productionLogsForBranch = loadFromLocalStorageForBranch<ProductionLogEntry[]>(KEYS.PRODUCTION_LOG, activeBranchIdState);
    const recipesForBranch = loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, activeBranchIdState);

    let filteredLogs = productionLogsForBranch;
    let reportRangeStart = selectedDateRange?.from ? startOfDay(selectedDateRange.from) : null;
    let reportRangeEnd = selectedDateRange?.to ? endOfDay(selectedDateRange.to) : (selectedDateRange?.from ? endOfDay(selectedDateRange.from) : null);

    if (reportRangeStart && reportRangeEnd) {
      filteredLogs = productionLogsForBranch.filter(log => {
        const logDate = parseISO(log.date);
        return isValid(logDate) && isWithinInterval(logDate, { start: reportRangeStart!, end: reportRangeEnd! });
      });
    }

    let fixedWeeklyCostForPeriod = 0;
    let payrollWeeklyCostForPeriod = 0;
    let numberOfWeeksInPeriod = 1;

    const fixedCategories: ExpenseFixedCategory[] = loadExpenseFixedCategories(activeBranchIdState);
    const employees: Employee[] = loadFromLocalStorageForBranch<Employee[]>(KEYS.EMPLOYEES, activeBranchIdState);

    fixedWeeklyCostForPeriod = fixedCategories
      .filter(cat => cat.name.toLowerCase() !== 'nómina' && cat.monthlyAmount && cat.monthlyAmount > 0)
      .reduce((sum, cat) => sum + (cat.monthlyAmount! / WEEKS_IN_MONTH), 0);

    payrollWeeklyCostForPeriod = employees.reduce((sum, emp) => sum + (emp.salary || 0), 0);

    if (reportRangeStart && reportRangeEnd) {
      numberOfWeeksInPeriod = differenceInCalendarWeeks(reportRangeEnd, reportRangeStart, { weekStartsOn: 1 }) + 1;
      if (numberOfWeeksInPeriod <= 0) numberOfWeeksInPeriod = 1;
    }
    const totalOperatingCostForPeriod = (fixedWeeklyCostForPeriod + payrollWeeklyCostForPeriod) * numberOfWeeksInPeriod;


    const totalSacksProducedInPeriod = filteredLogs.reduce((sum, log) => {
      const recipeDetails = recipesForBranch.find(r => r.name === log.product);
      if (recipeDetails && !recipeDetails.isIntermediate) {
        return sum + (log.batchSizeMultiplier || 0);
      }
      return sum;
    }, 0);

    const costPerSackForPeriod = totalSacksProducedInPeriod > 0 && totalOperatingCostForPeriod >= 0 ? totalOperatingCostForPeriod / totalSacksProducedInPeriod : 0;

    const productWastageMap: { [productName: string]: ProductWastageData; } = {};
    filteredLogs.forEach(log => {
      const recipe = recipesForBranch.find(r => r.name === log.product);
      if (recipe && !recipe.isIntermediate) {
        const wastageQuantityInThisLog = log.expectedQuantity - log.actualQuantity;
        if (wastageQuantityInThisLog > 0) {
          const costoIngredientesPorTanda = calculateDynamicRecipeCost(recipe.id, 'highest', recipesForBranch);
          const costoIngredientesPorUnidad = (recipe.expectedYield && recipe.expectedYield > 0) ? costoIngredientesPorTanda / recipe.expectedYield : 0;

          let costoOperativoPorUnidad = 0;
          if (recipe.expectedYield && recipe.expectedYield > 0 && costPerSackForPeriod >= 0) {
            costoOperativoPorUnidad = costPerSackForPeriod / recipe.expectedYield;
          }
          const costoTotalPorUnidadParaMerma = costoIngredientesPorUnidad + costoOperativoPorUnidad;
          const wastageCostInThisLog = wastageQuantityInThisLog * costoTotalPorUnidadParaMerma;

          if (!productWastageMap[log.product]) {
            productWastageMap[log.product] = {
              name: log.product, totalExpected: 0, totalActual: 0,
              totalWastageQuantity: 0, totalWastageCostUSD: 0,
              baseUnitPriceForWastage: costoTotalPorUnidadParaMerma
            };
          }
          productWastageMap[log.product].totalExpected += log.expectedQuantity;
          productWastageMap[log.product].totalActual += log.actualQuantity;
          productWastageMap[log.product].totalWastageQuantity += wastageQuantityInThisLog;
          productWastageMap[log.product].totalWastageCostUSD += wastageCostInThisLog;
          if (productWastageMap[log.product].baseUnitPriceForWastage === undefined) {
            productWastageMap[log.product].baseUnitPriceForWastage = costoTotalPorUnidadParaMerma;
          }
        }
      }
    });

    return Object.values(productWastageMap)
      .sort((a, b) => b.totalWastageCostUSD - a.totalWastageCostUSD);
  }, [selectedDateRange, activeBranchIdState]);

  const productWastageChartData = useMemo(() => {
    return wastageReportFullData.slice(0, TOP_N_WASTAGE_PRODUCTS_REPORTS).map(item => ({
      name: item.name,
      wastageCostUSD: parseFloat(item.totalWastageCostUSD.toFixed(2)),
      wastageQuantity: item.totalWastageQuantity
    }));
  }, [wastageReportFullData]);

  const productWastageChartConfig = {
    wastageCostUSD: { label: "Costo Merma (USD)", color: "hsl(var(--destructive))" },
    wastageQuantity: { label: "Cantidad Mermada", color: "hsl(var(--chart-2))" }
  } satisfies ChartConfig;

  const productLossesData = useMemo(() => {
    const lossesMap: { [productName: string]: ProductLossItem } = {};
    let filteredSales = initialSalesDataGlobal;
    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      filteredSales = initialSalesDataGlobal.filter(sale => {
        const saleDate = parseISO(sale.date);
        return isValid(saleDate) && isWithinInterval(saleDate, { start: from, end: to });
      });
    }

    if (!activeBranchIdState) return [];
    const recipesForBranch = loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, activeBranchIdState);
    const productionLogsForBranch = loadFromLocalStorageForBranch<ProductionLogEntry[]>(KEYS.PRODUCTION_LOG, activeBranchIdState);

    let fixedWeeklyCostForPeriod = 0;
    let payrollWeeklyCostForPeriod = 0;
    let numberOfWeeksInPeriod = 1;
    const fixedCategories: ExpenseFixedCategory[] = loadExpenseFixedCategories(activeBranchIdState);
    const employees: Employee[] = loadFromLocalStorageForBranch<Employee[]>(KEYS.EMPLOYEES, activeBranchIdState);
    fixedWeeklyCostForPeriod = fixedCategories
      .filter(cat => cat.name.toLowerCase() !== 'nómina' && cat.monthlyAmount && cat.monthlyAmount > 0)
      .reduce((sum, cat) => sum + (cat.monthlyAmount! / WEEKS_IN_MONTH), 0);
    payrollWeeklyCostForPeriod = employees.reduce((sum, emp) => sum + (emp.salary || 0), 0);
    if (selectedDateRange?.from && selectedDateRange.to) {
      numberOfWeeksInPeriod = differenceInCalendarWeeks(selectedDateRange.to, selectedDateRange.from, { weekStartsOn: 1 }) + 1;
      if (numberOfWeeksInPeriod <= 0) numberOfWeeksInPeriod = 1;
    }
    const totalOperatingCostForPeriod = (fixedWeeklyCostForPeriod + payrollWeeklyCostForPeriod) * numberOfWeeksInPeriod;
    const totalSacksProducedInPeriod = productionLogsForBranch
      .filter(log => {
        if (!selectedDateRange?.from || !selectedDateRange.to) return true;
        const logDate = parseISO(log.date);
        return isValid(logDate) && isWithinInterval(logDate, { start: startOfDay(selectedDateRange.from), end: endOfDay(selectedDateRange.to) });
      })
      .reduce((sum, log) => {
        const recipeDetails = recipesForBranch.find(r => r.name === log.product);
        if (recipeDetails && !recipeDetails.isIntermediate) return sum + (log.batchSizeMultiplier || 0);
        return sum;
      }, 0);
    const costPerSackForPeriod = totalSacksProducedInPeriod > 0 && totalOperatingCostForPeriod >= 0 ? totalOperatingCostForPeriod / totalSacksProducedInPeriod : 0;


    filteredSales.forEach(sale => {
      if (sale.changes) {
        sale.changes.forEach(item => {
          if (item.productName && item.sourceBranchId === activeBranchIdState) {
            if (!lossesMap[item.productName]) {
              lossesMap[item.productName] = { name: item.productName, quantityChanged: 0, costChangedUSD: 0, quantityWasted: 0, costWastedUSD: 0, quantitySampled: 0, costSampledUSD: 0, totalQuantityLost: 0, totalCostLostUSD: 0 };
            }
            lossesMap[item.productName].quantityChanged += item.quantity;
            const recipe = recipesForBranch.find(r => r.name === item.productName);
            if (recipe && recipe.name.toLowerCase().startsWith('no despachable')) {
              const lossCostPerUnit = recipe.costPerUnit || 0;
              lossesMap[item.productName].costChangedUSD += item.quantity * lossCostPerUnit;
            }
          }
        });
      }
      if (sale.samples) {
        sale.samples.forEach(sample => {
          if (sample.productName && sample.sourceBranchId === activeBranchIdState) {
            if (!lossesMap[sample.productName]) {
              lossesMap[sample.productName] = { name: sample.productName, quantityChanged: 0, costChangedUSD: 0, quantityWasted: 0, costWastedUSD: 0, quantitySampled: 0, costSampledUSD: 0, totalQuantityLost: 0, totalCostLostUSD: 0 };
            }
            lossesMap[sample.productName].quantitySampled += sample.quantity;
            const recipe = recipesForBranch.find(r => r.name === sample.productName);
            if (recipe) {
              const costOfIngredientsPerTanda = calculateDynamicRecipeCost(recipe.id, 'highest', recipesForBranch);
              const costOfIngredientsPerUnit = (recipe.expectedYield && recipe.expectedYield > 0) ? costOfIngredientsPerTanda / recipe.expectedYield : 0;
              const operatingCostPerUnit = (recipe.expectedYield && recipe.expectedYield > 0 && costPerSackForPeriod >= 0) ? costPerSackForPeriod / recipe.expectedYield : 0;
              const packagingCostPerUnit = calculatePackagingCost(1).maxCost;
              const totalCostPerUnitSampled = costOfIngredientsPerUnit + operatingCostPerUnit + packagingCostPerUnit;
              lossesMap[sample.productName].costSampledUSD += sample.quantity * totalCostPerUnitSampled;
            }
          }
        });
      }
    });

    wastageReportFullData.forEach(wastageItem => {
      if (!lossesMap[wastageItem.name]) {
        lossesMap[wastageItem.name] = { name: wastageItem.name, quantityChanged: 0, costChangedUSD: 0, quantityWasted: 0, costWastedUSD: 0, quantitySampled: 0, costSampledUSD: 0, totalQuantityLost: 0, totalCostLostUSD: 0 };
      }
      lossesMap[wastageItem.name].quantityWasted += wastageItem.totalWastageQuantity;
      lossesMap[wastageItem.name].costWastedUSD += wastageItem.totalWastageCostUSD;
    });

    return Object.values(lossesMap).map(item => ({
      ...item,
      totalQuantityLost: item.quantityChanged + item.quantityWasted + item.quantitySampled,
      totalCostLostUSD: item.costChangedUSD + item.costWastedUSD + item.costSampledUSD,
    }))
      .sort((a, b) => b.totalCostLostUSD - a.totalCostLostUSD)
      .slice(0, TOP_N_LOSSES_REPORTS);

  }, [selectedDateRange, wastageReportFullData, activeBranchIdState]);

  const productLossesChartConfig = {
    totalQuantityLost: { label: "Cantidad Perdida", color: "hsl(var(--chart-2))" },
    totalCostLostUSD: { label: "Costo Pérdida (USD)", color: "hsl(var(--destructive))" },
  } satisfies ChartConfig;


  const handleExportChartAsImage = async (chartId: string, fileName: string) => {
    const element = document.getElementById(chartId);
    if (!element) {
      toast({ title: "Error", description: "No se encontró el gráfico para exportar.", variant: "destructive" });
      return;
    }
    try {
      const canvas = await html2canvas(element, { backgroundColor: '#ffffff' });
      const image = canvas.toDataURL("image/png");
      const link = document.createElement('a');
      link.href = image;
      link.download = `${fileName}.png`;
      link.click();
      toast({ title: "Imagen Exportada", description: "El gráfico se ha guardado como imagen.", duration: 3000 });
    } catch (error) {
      console.error("Error exporting chart:", error);
      toast({ title: "Error", description: "Hubo un problema al exportar el gráfico.", variant: "destructive" });
    }
  };

  const handleDownloadSalesReport = () => {
    let filteredSales = initialSalesDataGlobal;
    let reportPeriod = "General";

    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      filteredSales = initialSalesDataGlobal.filter(sale => {
        const saleDate = parseISO(sale.date);
        return isValid(saleDate) && isWithinInterval(saleDate, { start: from, end: to });
      });
      reportPeriod = `${format(from, "dd/MM/yyyy", { locale: es })}${selectedDateRange.to ? ` - ${format(to, "dd/MM/yyyy", { locale: es })}` : ''}`;
    }

    if (filteredSales.length === 0) {
      toast({ title: "Sin Datos", description: "No hay ventas para el período seleccionado.", variant: "default" });
      return;
    }

    const doc = new jsPDF() as jsPDFWithAutoTable;
    doc.setFontSize(18);
    doc.text("Panificadora Valladares", 14, 22);
    doc.setFontSize(12);
    doc.text("Reporte de Ventas (Global)", 14, 30);
    doc.setFontSize(10);
    doc.text(`Período: ${reportPeriod}`, 14, 38);
    doc.text(`Tasa de Cambio (USD/VES): ${exchangeRate > 0 ? exchangeRate.toFixed(2) : 'No establecida'}`, 14, 44);

    const head = [["ID Venta", "Fecha", "Cliente", "Total (USD)", "Total (VES)", "Método Pago", "Estado"]];
    const body = filteredSales.map(sale => [
      sale.id,
      format(parseISO(sale.date), "dd/MM/yyyy", { locale: es }),
      sale.customerName || 'N/A',
      `$${sale.totalAmount.toFixed(2)}`,
      formatVesPrice(sale.totalAmount),
      sale.paymentMethod,
      sale.status
    ]);

    doc.autoTable({
      startY: 52, head: head, body: body, theme: 'striped', headStyles: { fillColor: [224, 122, 95], fontSize: 10 }, bodyStyles: { fontSize: 9 },
    });

    doc.save(getReportFilename("reporte_ventas_global"));
    toast({
      title: "Reporte de Ventas Generado",
      description: `Se generó un PDF con ${filteredSales.length} registros de ventas.`,
      duration: 5000,
    });
  };

  const handleDownloadProductChangesReport = () => {
    let filteredSales = initialSalesDataGlobal;
    let reportPeriod = "General";

    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      filteredSales = initialSalesDataGlobal.filter(sale => {
        const saleDate = parseISO(sale.date);
        return isValid(saleDate) && isWithinInterval(saleDate, { start: from, end: to });
      });
      reportPeriod = `${format(from, "dd/MM/yyyy", { locale: es })}${selectedDateRange.to ? ` - ${format(to, "dd/MM/yyyy", { locale: es })}` : ''}`;
    }

    const productChangesAggregated: { name: string; quantity: number; costUSD: number }[] = [];
    const productChangesMap: { [productName: string]: { quantity: number; costUSD: number } } = {};

    const activeBranchRecipes = activeBranchIdState ? loadFromLocalStorageForBranch<Recipe[]>(KEYS.RECIPES, activeBranchIdState) : [];

    filteredSales.forEach(sale => {
      if (sale.changes) {
        sale.changes.forEach(item => {
          if (item.productName) {
            if (!productChangesMap[item.productName]) {
              productChangesMap[item.productName] = { quantity: 0, costUSD: 0 };
            }
            productChangesMap[item.productName].quantity += item.quantity;
            const recipe = activeBranchRecipes.find(r => r.name === item.productName);
            if (recipe && recipe.name.toLowerCase().startsWith('no despachable')) {
              const lossCostPerUnit = recipe.costPerUnit || 0;
              productChangesMap[item.productName].costUSD += item.quantity * lossCostPerUnit;
            }
          }
        });
      }
    });

    for (const name in productChangesMap) {
      productChangesAggregated.push({ name, quantity: productChangesMap[name].quantity, costUSD: productChangesMap[name].costUSD });
    }
    const productChangesList = productChangesAggregated.sort((a, b) => b.costUSD - a.costUSD);

    if (productChangesList.length === 0) {
      toast({ title: "Sin Datos", description: "No hay cambios/devoluciones de productos para el período seleccionado.", variant: "default" });
      return;
    }

    const doc = new jsPDF() as jsPDFWithAutoTable;
    doc.setFontSize(18);
    doc.text("Panificadora Valladares", 14, 22);
    doc.setFontSize(12);
    doc.text("Reporte de Cambios/Devoluciones de Productos (Global)", 14, 30);
    doc.setFontSize(10);
    doc.text(`Período: ${reportPeriod}`, 14, 38);
    doc.text(`Tasa de Cambio (USD/VES): ${exchangeRate > 0 ? exchangeRate.toFixed(2) : 'No establecida'}`, 14, 44);
    doc.text(`Nota: El costo se basa en el costo de "No despachable" (recetas sede: ${activeBranchName}).`, 14, 50);

    const head = [["Producto", "Cantidad Cambiada/Devuelta", "Costo Total Cambio (USD)", "Costo Total Cambio (VES)"]];
    const body = productChangesList.map(item => [
      item.name,
      item.quantity,
      `$${item.costUSD.toFixed(2)}`,
      formatVesPrice(item.costUSD)
    ]);
    const totalQuantity = productChangesList.reduce((sum, item) => sum + item.quantity, 0);
    const totalCost = productChangesList.reduce((sum, item) => sum + item.costUSD, 0);
    body.push([
      { content: "TOTALES", styles: { fontStyle: 'bold', halign: 'right' } },
      { content: totalQuantity, styles: { fontStyle: 'bold' } },
      { content: `$${totalCost.toFixed(2)}`, styles: { fontStyle: 'bold' } },
      { content: formatVesPrice(totalCost), styles: { fontStyle: 'bold' } },
    ]);

    doc.autoTable({
      startY: 58, head: head, body: body, theme: 'striped', headStyles: { fillColor: [224, 122, 95], fontSize: 10 }, bodyStyles: { fontSize: 9 },
    });
    doc.save(getReportFilename("reporte_cambios_productos_global"));
    toast({ title: "Reporte de Cambios Generado", description: `Se generó un PDF con ${productChangesList.length} productos cambiados/devueltos.`, duration: 5000, });
  };

  const handleDownloadExpenseReport = () => {
    if (!activeBranchIdState) {
      toast({ title: "Error de Sede", description: "Selecciona una sede activa primero.", variant: "destructive" });
      return;
    }
    let branchExpenses = loadFromLocalStorageForBranch<Expense[]>(KEYS.EXPENSES, activeBranchIdState);
    let filteredExpenses = branchExpenses;
    let reportPeriod = "General";

    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      filteredExpenses = branchExpenses.filter(expense => {
        const expenseDate = parseISO(expense.date);
        return isValid(expenseDate) && isWithinInterval(expenseDate, { start: from, end: to });
      });
      reportPeriod = `${format(from, "dd/MM/yyyy", { locale: es })}${selectedDateRange.to ? ` - ${format(to, "dd/MM/yyyy", { locale: es })}` : ''}`;
    }

    if (filteredExpenses.length === 0) {
      toast({ title: "Sin Datos", description: `No hay gastos para el período y sede ${activeBranchName}.`, variant: "default" });
      return;
    }

    const doc = new jsPDF() as jsPDFWithAutoTable;
    doc.setFontSize(18);
    doc.text("Panificadora Valladares", 14, 22);
    doc.setFontSize(12);
    doc.text(`Reporte de Gastos (Sede: ${activeBranchName})`, 14, 30);
    doc.setFontSize(10);
    doc.text(`Período: ${reportPeriod}`, 14, 38);
    doc.text(`Tasa de Cambio (USD/VES): ${exchangeRate > 0 ? exchangeRate.toFixed(2) : 'No establecida'}`, 14, 44);

    const head = [["ID Gasto", "Fecha", "Categoría", "Descripción", "Monto (USD)", "Monto (VES)", "Pagado A"]];
    const body = filteredExpenses.map(expense => [
      expense.id,
      format(parseISO(expense.date), "dd/MM/yyyy", { locale: es }),
      expense.category,
      expense.description,
      `$${expense.amount.toFixed(2)}`,
      formatVesPrice(expense.amount),
      expense.paidTo
    ]);

    doc.autoTable({
      startY: 52, head: head, body: body, theme: 'striped', headStyles: { fillColor: [224, 122, 95], fontSize: 10 }, bodyStyles: { fontSize: 9 },
    });
    doc.save(getReportFilename("reporte_gastos"));
    toast({ title: "Reporte de Gastos Generado", description: `Se generó un PDF con ${filteredExpenses.length} registros de gastos de la sede ${activeBranchName}.`, duration: 5000, });
  };

  const handleDownloadInventoryReport = () => {
    if (!activeBranchIdState) {
      toast({ title: "Error de Sede", description: "Selecciona una sede activa primero.", variant: "destructive" });
      return;
    }
    const productsForReport = loadFromLocalStorageForBranch<Product[]>(KEYS.PRODUCTS, activeBranchIdState);
    if (productsForReport.length === 0) {
      toast({ title: "Sin Datos", description: `No hay productos en el stock de producción de la sede ${activeBranchName}.`, variant: "default" });
      return;
    }
    const doc = new jsPDF() as jsPDFWithAutoTable;
    doc.setFontSize(18);
    doc.text("Panificadora Valladares", 14, 22);
    doc.setFontSize(12);
    doc.text(`Reporte de Stock de Producción (Sede: ${activeBranchName})`, 14, 30);
    doc.setFontSize(10);
    doc.text(`Fecha del Reporte: ${format(new Date(), "dd/MM/yyyy HH:mm", { locale: es })}`, 14, 38);
    doc.text(`Tasa de Cambio (USD/VES): ${exchangeRate > 0 ? exchangeRate.toFixed(2) : 'No establecida'}`, 14, 44);

    const head = [["ID Producto", "Nombre", "Categoría", "Stock", "P.Unit(USD)", "P.Unit(VES)", "Últ. Actualización"]];
    const body = productsForReport.map(product => [
      product.id, product.name, product.category, product.stock,
      `$${product.unitPrice.toFixed(2)}`, formatVesPrice(product.unitPrice),
      product.lastUpdated ? format(parseISO(product.lastUpdated), "dd/MM/yyyy", { locale: es }) : '-'
    ]);

    doc.autoTable({
      startY: 52, head: head, body: body, theme: 'striped', headStyles: { fillColor: [224, 122, 95], fontSize: 10 }, bodyStyles: { fontSize: 9 },
    });
    doc.save(getReportFilename("reporte_stock_produccion"));
    toast({ title: "Reporte de Stock de Producción Generado", description: `Se generó un PDF con ${productsForReport.length} productos de la sede ${activeBranchName}.`, duration: 5000, });
  };

  const handleDownloadRawMaterialInventoryReport = () => {
    if (!activeBranchIdState) {
      toast({ title: "Error de Sede", description: "Selecciona una sede activa primero.", variant: "destructive" });
      return;
    }
    const rawMaterialsForReport = loadFromLocalStorageForBranch<RawMaterialInventoryItem[]>(KEYS.RAW_MATERIAL_INVENTORY, activeBranchIdState);
    if (rawMaterialsForReport.length === 0) {
      toast({ title: "Sin Datos", description: `No hay materia prima en el inventario de la sede ${activeBranchName}.`, variant: "default" });
      return;
    }
    const doc = new jsPDF() as jsPDFWithAutoTable;
    doc.setFontSize(18);
    doc.text("Panificadora Valladares", 14, 22);
    doc.setFontSize(12);
    doc.text(`Reporte de Inventario de Materia Prima (Sede: ${activeBranchName})`, 14, 30);
    doc.setFontSize(10);
    doc.text(`Fecha del Reporte: ${format(new Date(), "dd/MM/yyyy HH:mm", { locale: es })}`, 14, 38);

    const head = [["Ingrediente", "Cantidad Total", "Unidad (Base)"]];
    const body = rawMaterialsForReport.map(material => [
      material.name, material.quantity.toFixed(3), material.unit
    ]);

    doc.autoTable({
      startY: 46, head: head, body: body, theme: 'striped', headStyles: { fillColor: [224, 122, 95], fontSize: 10 }, bodyStyles: { fontSize: 9 },
    });
    doc.save(getReportFilename("reporte_materia_prima"));
    toast({ title: "Reporte de Materia Prima Generado", description: `Se generó un PDF con ${rawMaterialsForReport.length} ítems de la sede ${activeBranchName}.`, duration: 5000, });
  };

  const handleDownloadPurchaseOrdersReport = () => {
    if (!activeBranchIdState) {
      toast({ title: "Error de Sede", description: "Selecciona una sede activa primero.", variant: "destructive" });
      return;
    }
    const ordersForBranch = loadFromLocalStorageForBranch<PurchaseOrder[]>(KEYS.PURCHASE_ORDERS, activeBranchIdState);
    let filteredOrders = ordersForBranch;
    let reportPeriod = "General";

    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      filteredOrders = ordersForBranch.filter(po => {
        const orderDate = parseISO(po.orderDate);
        return isValid(orderDate) && isWithinInterval(orderDate, { start: from, end: to });
      });
      reportPeriod = `${format(from, "dd/MM/yyyy", { locale: es })}${selectedDateRange.to ? ` - ${format(to, "dd/MM/yyyy", { locale: es })}` : ''}`;
    }

    if (filteredOrders.length === 0) {
      toast({ title: "Sin Datos", description: `No hay órdenes de compra para el período y sede ${activeBranchName}.`, variant: "default" });
      return;
    }

    const doc = new jsPDF("landscape") as jsPDFWithAutoTable;
    doc.setFontSize(18);
    doc.text("Panificadora Valladares", 14, 20);
    doc.setFontSize(12);
    doc.text(`Reporte de Órdenes de Compra (Sede: ${activeBranchName})`, 14, 28);
    doc.setFontSize(10);
    doc.text(`Período: ${reportPeriod}`, 14, 36);
    doc.text(`Tasa de Cambio (USD/VES): ${exchangeRate > 0 ? exchangeRate.toFixed(2) : 'No establecida'}`, 14, 42);

    const head = [["ID OC", "Proveedor", "Fecha Pedido", "Entrega Esperada", "Artículos (Resumen)", "Costo Total (USD)", "Costo Total (VES)", "Estado"]];
    const body = filteredOrders.map(po => [
      po.id, po.supplierName, format(parseISO(po.orderDate), "dd/MM/yyyy", { locale: es }),
      format(parseISO(po.expectedDelivery), "dd/MM/yyyy", { locale: es }),
      po.items.map(item => `${item.rawMaterialName} (${item.quantity} ${item.unit})`).join('; '),
      `$${po.totalCost.toFixed(2)}`, formatVesPrice(po.totalCost), po.status
    ]);

    doc.autoTable({
      startY: 50, head: head, body: body, theme: 'striped', headStyles: { fillColor: [224, 122, 95], fontSize: 10 }, bodyStyles: { fontSize: 9 },
      columnStyles: { 4: { cellWidth: 'auto' } }
    });
    doc.save(getReportFilename("reporte_ordenes_compra"));
    toast({ title: "Reporte de Órdenes de Compra Generado", description: `Se generó un PDF con ${filteredOrders.length} órdenes de la sede ${activeBranchName}.`, duration: 5000, });
  };

  const handleDownloadWastageReport = () => {
    if (wastageReportFullData.length === 0) {
      toast({ title: "Sin Datos", description: `No hay datos de merma para el período y sede ${activeBranchName}.`, variant: "default" });
      return;
    }
    let reportPeriod = "General";
    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      reportPeriod = `${format(from, "dd/MM/yyyy", { locale: es })}${selectedDateRange.to ? ` - ${format(to, "dd/MM/yyyy", { locale: es })}` : ''}`;
    }

    const doc = new jsPDF("landscape") as jsPDFWithAutoTable;
    doc.setFontSize(18);
    doc.text("Panificadora Valladares", 14, 20);
    doc.setFontSize(12);
    doc.text(`Reporte de Merma de Producción (Sede: ${activeBranchName})`, 14, 28);
    doc.setFontSize(10);
    doc.text(`Período: ${reportPeriod}`, 14, 36);
    doc.text(`Tasa de Cambio (USD/VES): ${exchangeRate > 0 ? exchangeRate.toFixed(2) : 'No establecida'}`, 14, 42);
    doc.text("Nota: Costo de merma incluye costo de ingredientes y operativos (basados en sede actual).", 14, 48);

    const head = [["Producto", "Esperado", "Real", "Mermado", "Costo Unit. Merma (USD)", "Costo Merma (USD)", "Costo Merma (VES)"]];
    const body = wastageReportFullData.map(item => [
      item.name, item.totalExpected, item.totalActual, item.totalWastageQuantity,
      `$${(item.baseUnitPriceForWastage || 0).toFixed(2)}`, `$${item.totalWastageCostUSD.toFixed(2)}`, formatVesPrice(item.totalWastageCostUSD)
    ]);
    const totalWastageQty = wastageReportFullData.reduce((sum, item) => sum + item.totalWastageQuantity, 0);
    const totalWastageCost = wastageReportFullData.reduce((sum, item) => sum + item.totalWastageCostUSD, 0);
    body.push([
      { content: "TOTALES", colSpan: 3, styles: { fontStyle: 'bold', halign: 'right' } },
      { content: totalWastageQty, styles: { fontStyle: 'bold' } },
      { content: "", styles: { fontStyle: 'bold' } }, // Empty for unit cost
      { content: `$${totalWastageCost.toFixed(2)}`, styles: { fontStyle: 'bold' } },
      { content: formatVesPrice(totalWastageCost), styles: { fontStyle: 'bold' } },
    ]);

    doc.autoTable({
      startY: 56, head: head, body: body, theme: 'striped', headStyles: { fillColor: [224, 122, 95], fontSize: 10 }, bodyStyles: { fontSize: 9 },
    });
    doc.save(getReportFilename("reporte_merma_produccion"));
    toast({ title: "Reporte de Merma Generado", description: `Se generó un PDF para la sede ${activeBranchName}.`, duration: 5000, });
  };

  const handleDownloadLossesReport = () => {
    if (productLossesData.length === 0 && wastageReportFullData.length === 0 && productChangesChartData.length === 0) {
      toast({ title: "Sin Datos", description: "No hay datos de pérdidas (merma, cambios o muestras) para el período y sede actual.", variant: "default" });
      return;
    }
    let reportPeriod = "General";
    if (selectedDateRange?.from) {
      const from = startOfDay(selectedDateRange.from);
      const to = selectedDateRange.to ? endOfDay(selectedDateRange.to) : endOfDay(selectedDateRange.from);
      reportPeriod = `${format(from, "dd/MM/yyyy", { locale: es })}${selectedDateRange.to ? ` - ${format(to, "dd/MM/yyyy", { locale: es })}` : ''}`;
    }

    const doc = new jsPDF("landscape") as jsPDFWithAutoTable;
    doc.setFontSize(18);
    doc.text("Panificadora Valladares", 14, 20);
    doc.setFontSize(12);
    doc.text(`Reporte de Pérdidas Totales (Sede: ${activeBranchName})`, 14, 28);
    doc.setFontSize(10);
                <CardTitle className="flex items-center gap-2"><Package className="h-5 w-5 text-primary" /> Stock de Producción (Sede: {activeBranchName})</CardTitle>
                <CardDescription>Top 10 productos con más stock en la sede actual.</CardDescription>
              </CardHeader >
              <CardContent className="h-[300px]">
                {productStockChartData.length > 0 ? (
                  <ChartContainer config={productStockChartConfig} className="h-full w-full" id="chart-stock-produccion">
                    <ResponsiveContainer width="100%" height="100%">
                      <BarChart data={productStockChartData} layout="vertical" margin={{ top: 5, right: 20, left: 30, bottom: 5 }}>
                        <CartesianGrid strokeDasharray="3 3" stroke="hsl(var(--muted))" opacity={0.3} />
                        <XAxis type="number" tickLine={false} axisLine={false} tickMargin={10} fontSize={12} />
                        <YAxis dataKey="name" type="category" tickLine={false} axisLine={false} tickMargin={5} fontSize={12} width={120} interval={0} />
                        <ChartTooltip content={<ChartTooltipContent className="text-sm" />} />
                        <Bar dataKey="stock" fill="var(--color-stock)" radius={[0, 8, 8, 0]} isAnimationActive={true} animationDuration={800} animationBegin={400} />
                      </BarChart>
                    </ResponsiveContainer>
                  </ChartContainer>
                ) : (<p className="text-center text-muted-foreground py-8">No hay productos en stock en la sede actual.</p>)}
              </CardContent>
              <CardFooter className="flex gap-2">
                <Button className="flex-1" onClick={handleDownloadInventoryReport}><Download className="mr-2 h-4 w-4" /> Descargar Reporte</Button>
                <Button variant="outline" size="icon" onClick={() => handleExportChartAsImage("chart-stock-produccion", "stock_produccion")} title="Exportar Imagen"><ImageIcon className="h-4 w-4" /></Button>
              </CardFooter>
            </Card >

            <Card className="shadow-lg hover:shadow-xl transition-shadow duration-300">
              <CardHeader>
                <CardTitle className="flex items-center gap-2"><Archive className="h-5 w-5 text-primary" /> Inventario Materia Prima (Sede: {activeBranchName})</CardTitle>
                <CardDescription>Top 10 materias primas con más stock en la sede actual (en unidad base).</CardDescription>
              </CardHeader>
              <CardContent className="h-[300px]">
                {rawMaterialStockChartData.length > 0 ? (
                  <ChartContainer config={rawMaterialStockChartConfig} className="h-full w-full" id="chart-inventario-mp">
                    <ResponsiveContainer width="100%" height="100%">
                      <BarChart data={rawMaterialStockChartData} layout="vertical" margin={{ top: 5, right: 20, left: 30, bottom: 5 }}>
                        <CartesianGrid strokeDasharray="3 3" stroke="hsl(var(--muted))" opacity={0.3} />
                        <XAxis type="number" tickLine={false} axisLine={false} tickMargin={10} fontSize={12} />
                        <YAxis dataKey="name" type="category" tickLine={false} axisLine={false} tickMargin={5} fontSize={12} width={120} interval={0} />
                        <ChartTooltip content={<ChartTooltipContent className="text-sm" />} />
                        <Bar dataKey="stock" fill="var(--color-stock)" radius={[0, 8, 8, 0]} isAnimationActive={true} animationDuration={800} animationBegin={500} />
                      </BarChart>
                    </ResponsiveContainer>
                  </ChartContainer>
                ) : (<p className="text-center text-muted-foreground py-8">No hay materia prima en inventario en la sede actual.</p>)}
              </CardContent>
              <CardFooter className="flex gap-2">
                <Button className="flex-1" onClick={handleDownloadRawMaterialInventoryReport}><Download className="mr-2 h-4 w-4" /> Descargar Reporte</Button>
                <Button variant="outline" size="icon" onClick={() => handleExportChartAsImage("chart-inventario-mp", "inventario_materia_prima")} title="Exportar Imagen"><ImageIcon className="h-4 w-4" /></Button>
              </CardFooter>
            </Card>

            <Card className="col-span-1 md:col-span-2 lg:col-span-3 shadow-lg border-t-4 border-t-blue-500">
              <CardHeader>
                <CardTitle className="flex items-center gap-2"><BrainCircuit className="h-6 w-6 text-blue-500" /> Inventario Inteligente: Alertas y Recomendaciones</CardTitle>
                <CardDescription>Análisis de stock basado en velocidad de ventas (últimos 30 días).</CardDescription>
              </CardHeader>
              <CardContent>
                <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4 mb-6">
                  <Card className="bg-red-50 border-red-200">
                    <CardHeader className="pb-2"><CardTitle className="text-sm font-medium text-red-800">Críticos (Stock &lt; 3 días)</CardTitle></CardHeader>
                    <CardContent><div className="text-2xl font-bold text-red-600">{inventoryHealthData.filter(i => i.status === 'Critical').length}</div></CardContent>
                  </Card>
                  <Card className="bg-orange-50 border-orange-200">
                    <CardHeader className="pb-2"><CardTitle className="text-sm font-medium text-orange-800">Bajos (Stock &lt; 7 días)</CardTitle></CardHeader>
                    <CardContent><div className="text-2xl font-bold text-orange-600">{inventoryHealthData.filter(i => i.status === 'Low').length}</div></CardContent>
                  </Card>
                  <Card className="bg-green-50 border-green-200">
                    <CardHeader className="pb-2"><CardTitle className="text-sm font-medium text-green-800">Saludables</CardTitle></CardHeader>
                    <CardContent><div className="text-2xl font-bold text-green-600">{inventoryHealthData.filter(i => i.status === 'Healthy').length}</div></CardContent>
                  </Card>
                  <Card className="bg-blue-50 border-blue-200">
                    <CardHeader className="pb-2"><CardTitle className="text-sm font-medium text-blue-800">Exceso (Stock &gt; 30 días)</CardTitle></CardHeader>
                    <CardContent><div className="text-2xl font-bold text-blue-600">{inventoryHealthData.filter(i => i.status === 'Overstock').length}</div></CardContent>
                  </Card>
                </div>

                <ScrollArea className="h-[300px]">
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead>Producto</TableHead>
                        <TableHead className="text-right">Stock Actual</TableHead>
                        <TableHead className="text-right">Venta Diaria Prom.</TableHead>
                        <TableHead className="text-right">Días Cobertura</TableHead>
                        <TableHead>Estado</TableHead>
                        <TableHead className="text-right">Sugerencia Reorden</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {inventoryHealthData.length > 0 ? (
                        inventoryHealthData.sort((a, b) => a.daysCoverage - b.daysCoverage).map((item) => (
                          <TableRow key={item.id}>
                            <TableCell className="font-medium">{item.name}</TableCell>
                            <TableCell className="text-right">{item.currentStock}</TableCell>
                            <TableCell className="text-right">{item.dailySalesVelocity.toFixed(1)}/día</TableCell>
                            <TableCell className="text-right">{item.daysCoverage === Infinity ? '> 999' : item.daysCoverage.toFixed(1)} días</TableCell>
                            <TableCell>
                              <Badge variant={item.status === 'Critical' ? 'destructive' : item.status === 'Low' ? 'secondary' : item.status === 'Overstock' ? 'outline' : 'default'} className={item.status === 'Low' ? 'bg-orange-100 text-orange-800 hover:bg-orange-200' : ''}>
                                {item.status === 'Critical' ? 'Crítico' : item.status === 'Low' ? 'Bajo' : item.status === 'Overstock' ? 'Exceso' : 'Saludable'}
                              </Badge>
                            </TableCell>
                            <TableCell className="text-right font-semibold">
                              {item.suggestedRestock > 0 ? `+${item.suggestedRestock} unid` : '-'}
                            </TableCell>
                          </TableRow>
                        ))
                      ) : (
                        <TableRow>
                          <TableCell colSpan={6} className="text-center py-4 text-muted-foreground">
                            No hay datos suficientes para calcular inventario inteligente (se requieren ventas y stock).
                          </TableCell>
                        </TableRow>
                      )}
                    </TableBody>
                  </Table>
                </ScrollArea>
              </CardContent>
            </Card>

            <Card className="shadow-lg hover:shadow-xl transition-shadow duration-300 border-l-4 border-l-destructive">
              <CardHeader>
                <CardTitle className="flex items-center gap-2"><TrendingDown className="h-5 w-5 text-destructive" /> Top {TOP_N_WASTAGE_PRODUCTS_REPORTS} Merma (Costo - Sede: {activeBranchName})</CardTitle>
                <CardDescription>Costo total de merma (USD, ingr. + oper. sede actual) por producto en el período.</CardDescription>
              </CardHeader>
              <CardContent className="h-[300px]">
                {productWastageChartData.length > 0 ? (
                  <ChartContainer config={productWastageChartConfig} className="h-full w-full" id="chart-merma">
                    <ResponsiveContainer width="100%" height="100%">
                      <BarChart data={productWastageChartData} layout="vertical" margin={{ top: 5, right: 20, left: 30, bottom: 5 }}>
                        <CartesianGrid strokeDasharray="3 3" stroke="hsl(var(--muted))" opacity={0.3} />
                        <XAxis type="number" tickFormatter={(value) => `$${value}`} tickLine={false} axisLine={false} tickMargin={10} fontSize={12} />
                        <YAxis dataKey="name" type="category" tickLine={false} axisLine={false} tickMargin={5} width={120} interval={0} fontSize={12} />
                        <ChartTooltip content={({ active, payload }) => { if (active && payload && payload.length) { const data = payload[0].payload; return (<div className="rounded-lg border bg-background p-2 shadow-sm text-sm"><div className="grid grid-cols-1 gap-1.5"><span className="font-medium">{data.name}</span><span className="text-muted-foreground">Costo Merma: <span className="font-semibold text-destructive">${data.wastageCostUSD.toFixed(2)}</span></span><span className="text-muted-foreground">Cant. Mermada: <span className="font-semibold">{data.wastageQuantity} unid.</span></span></div></div>); } return null; }} />
                        <Bar dataKey="wastageCostUSD" fill="var(--color-wastageCostUSD)" radius={[0, 8, 8, 0]} isAnimationActive={true} animationDuration={800} animationBegin={200} />
                      </BarChart>
                    </ResponsiveContainer>
                  </ChartContainer>
                ) : (<p className="text-center text-muted-foreground py-8">No hay datos de merma para el período y sede actual.</p>)}
              </CardContent>
              <CardFooter className="flex gap-2">
                <Button className="flex-1" onClick={handleDownloadWastageReport}><Download className="mr-2 h-4 w-4" /> Descargar Reporte</Button>
                <Button variant="outline" size="icon" onClick={() => handleExportChartAsImage("chart-merma", "merma_produccion")} title="Exportar Imagen"><ImageIcon className="h-4 w-4" /></Button>
              </CardFooter>
            </Card>
          </div >
        </TabsContent >

        <TabsContent value="rentabilidad" className="space-y-4">
          <div className="grid gap-6 md:grid-cols-2">
            <Card className="shadow-lg hover:shadow-xl transition-shadow duration-300">
              <CardHeader>
                <CardTitle className="flex items-center gap-2"><DollarSign className="h-5 w-5 text-green-600" /> Top 10 Productos Más Rentables (Total $)</CardTitle>
                <CardDescription>Productos que generan mayor ganancia neta total en el período.</CardDescription>
              </CardHeader>
              <CardContent className="h-[300px]">
                <ResponsiveContainer width="100%" height="100%">
                  <BarChart data={[...productProfitabilityData].sort((a, b) => b.totalProfit - a.totalProfit).slice(0, 10)} layout="vertical" margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
                    <CartesianGrid strokeDasharray="3 3" horizontal={true} vertical={false} />
                    <XAxis type="number" tickFormatter={(value) => `$${value}`} />
                    <YAxis dataKey="name" type="category" width={100} tick={{ fontSize: 11 }} />
                    <ChartTooltip content={<ChartTooltipContent />} />
                    <Bar dataKey="totalProfit" fill="#16a34a" radius={[0, 4, 4, 0]} name="Ganancia Total" />
                  </BarChart>
                </ResponsiveContainer>
              </CardContent>
            </Card>

            <Card className="shadow-lg hover:shadow-xl transition-shadow duration-300">
              <CardHeader>
                <CardTitle className="flex items-center gap-2"><Percent className="h-5 w-5 text-blue-600" /> Top 10 Mayor Margen (%)</CardTitle>
                <CardDescription>Productos con mayor porcentaje de margen de ganancia.</CardDescription>
              </CardHeader>
              <CardContent className="h-[300px]">
                <ResponsiveContainer width="100%" height="100%">
                  <BarChart data={[...productProfitabilityData].sort((a, b) => b.marginPercent - a.marginPercent).slice(0, 10)} layout="vertical" margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
                    <CartesianGrid strokeDasharray="3 3" horizontal={true} vertical={false} />
                    <XAxis type="number" tickFormatter={(value) => `${value}%`} />
                    <YAxis dataKey="name" type="category" width={100} tick={{ fontSize: 11 }} />
                    <ChartTooltip content={<ChartTooltipContent />} />
                    <Bar dataKey="marginPercent" fill="#2563eb" radius={[0, 4, 4, 0]} name="Margen %" />
                  </BarChart>
                </ResponsiveContainer>
              </CardContent>
            </Card>

            <Card className="col-span-1 md:col-span-2 shadow-lg">
              <CardHeader>
                <CardTitle>Detalle de Rentabilidad por Producto</CardTitle>
              </CardHeader>
              <CardContent>
                <ScrollArea className="h-[400px]">
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead>Producto</TableHead>
                        <TableHead className="text-right">Vendidos</TableHead>
                        <TableHead className="text-right">Ingresos</TableHead>
                        <TableHead className="text-right">Costo Total</TableHead>
                        <TableHead className="text-right">Ganancia</TableHead>
                        <TableHead className="text-right">Margen %</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {productProfitabilityData.map((item) => (
                        <TableRow key={item.id}>
                          <TableCell className="font-medium">{item.name}</TableCell>
                          <TableCell className="text-right">{item.totalSold}</TableCell>
                          <TableCell className="text-right text-green-600">${item.totalRevenue.toFixed(2)}</TableCell>
                          <TableCell className="text-right text-red-500">${item.totalCost.toFixed(2)}</TableCell>
                          <TableCell className="text-right font-bold text-primary">${item.totalProfit.toFixed(2)}</TableCell>
                          <TableCell className="text-right">{item.marginPercent.toFixed(1)}%</TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </ScrollArea>
              </CardContent>
            </Card>
          </div>
        </TabsContent>

        <TabsContent value="clientes" className="space-y-4">
          <div className="grid gap-6 md:grid-cols-2">
            <Card className="shadow-lg hover:shadow-xl transition-shadow duration-300 col-span-1 md:col-span-2">
              <CardHeader>
                <CardTitle className="flex items-center gap-2"><Users className="h-5 w-5 text-purple-600" /> Top 10 Clientes por Compras ($)</CardTitle>
                <CardDescription>Clientes que más han gastado en el período seleccionado.</CardDescription>
              </CardHeader>
              <CardContent className="h-[300px]">
                <ResponsiveContainer width="100%" height="100%">
                  <BarChart data={[...customerStatsData].sort((a, b) => b.totalSpent - a.totalSpent).slice(0, 10)} margin={{ top: 20, right: 30, left: 20, bottom: 5 }}>
                    <CartesianGrid strokeDasharray="3 3" vertical={false} />
                    <XAxis dataKey="name" tick={{ fontSize: 11 }} />
                    <YAxis tickFormatter={(value) => `$${value}`} />
                    <ChartTooltip content={<ChartTooltipContent />} />
                    <Bar dataKey="totalSpent" fill="#9333ea" radius={[4, 4, 0, 0]} name="Total Gastado" />
                  </BarChart>
                </ResponsiveContainer>
              </CardContent>
            </Card>

            <Card className="col-span-1 md:col-span-2 shadow-lg">
              <CardHeader>
                <CardTitle>Análisis Detallado de Clientes</CardTitle>
              </CardHeader>
              <CardContent>
                <ScrollArea className="h-[400px]">
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead>Cliente</TableHead>
                        <TableHead className="text-right">Total Órdenes</TableHead>
                        <TableHead className="text-right">Total Gastado</TableHead>
                        <TableHead className="text-right">Ticket Promedio</TableHead>
                        <TableHead className="text-right">Última Compra</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {customerStatsData.map((customer) => (
                        <TableRow key={customer.id}>
                          <TableCell className="font-medium">{customer.name}</TableCell>
                          <TableCell className="text-right">{customer.totalOrders}</TableCell>
                          <TableCell className="text-right text-green-600">${customer.totalSpent.toFixed(2)}</TableCell>
                          <TableCell className="text-right">${customer.averageTicket.toFixed(2)}</TableCell>
                          <TableCell className="text-right">{customer.lastOrderDate ? format(parseISO(customer.lastOrderDate), "dd/MM/yyyy", { locale: es }) : '-'}</TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </ScrollArea>
              </CardContent>
            </Card>
          </div>
        </TabsContent>

        <TabsContent value="finanzas" className="space-y-4">
          <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
            <Card className="shadow-lg hover:shadow-xl transition-shadow duration-300">
              <CardHeader>
                <CardTitle className="flex items-center gap-2"><PieChartIconLucide className="h-5 w-5 text-primary" /> Desglose de Gastos (Sede: {activeBranchName})</CardTitle>
                <CardDescription>Distribución de gastos por categoría en el período para la sede actual.</CardDescription>
              </CardHeader>
              <CardContent className="h-[300px]">
                {expensesChartData.length > 0 ? (
                  <ChartContainer config={expensesChartConfig} className="h-full w-full" id="chart-gastos">
                    <ResponsiveContainer width="100%" height="100%">
                      <PieChart>
                        <ChartTooltip content={<ChartTooltipContent nameKey="category" hideLabel className="text-sm" />} />
                        <Pie data={expensesChartData} dataKey="total" nameKey="category" cx="50%" cy="50%" outerRadius={80} labelLine={false} isAnimationActive={true} animationDuration={800} animationBegin={0} label={({ cx, cy, midAngle, innerRadius, outerRadius, percent }) => { const RADIAN = Math.PI / 180; const radius = innerRadius + (outerRadius - innerRadius) * 0.5; const x = cx + radius * Math.cos(-midAngle * RADIAN); const y = cy + radius * Math.sin(-midAngle * RADIAN); return (percent || 0) * 100 > 5 ? (<text x={x} y={y} fill="white" textAnchor={x > cx ? 'start' : 'end'} dominantBaseline="central" fontSize={12}>{`${((percent || 0) * 100).toFixed(0)}%`}</text>) : null; }}>
                          {expensesChartData.map((entry, index) => (<Cell key={`cell-${index}`} fill={entry.fill} />))}
                        </Pie>
                        <ChartLegend content={<ChartLegendContent nameKey="category" className="text-sm" />} />
                      </PieChart>
                    </ResponsiveContainer>
                  </ChartContainer>
                ) : (<p className="text-center text-muted-foreground py-8">No hay datos de gastos para el período y sede actual.</p>)}
              </CardContent>
              <CardFooter className="flex gap-2">
                <Button className="flex-1" onClick={handleDownloadExpenseReport}><Download className="mr-2 h-4 w-4" /> Descargar Reporte</Button>
                <Button variant="outline" size="icon" onClick={() => handleExportChartAsImage("chart-gastos", "desglose_gastos")} title="Exportar Imagen"><ImageIcon className="h-4 w-4" /></Button>
              </CardFooter>
            </Card>

            <Card className="shadow-lg hover:shadow-xl transition-shadow duration-300 border-l-4 border-l-destructive">
              <CardHeader>
                <CardTitle className="flex items-center gap-2"><Combine className="h-5 w-5 text-destructive" /> Top {TOP_N_LOSSES_REPORTS} Pérdidas Totales (Costo - Sede: {activeBranchName})</CardTitle>
                <CardDescription>Suma de costo merma, cambios y muestras (todos costos basados en sede actual).</CardDescription>
              </CardHeader>
              <CardContent className="h-[300px]">
                {productLossesData.length > 0 ? (
                  <ChartContainer config={productLossesChartConfig} className="h-full w-full" id="chart-perdidas-totales">
                    <ResponsiveContainer width="100%" height="100%">
                      <BarChart data={productLossesData} layout="vertical" margin={{ top: 5, right: 20, left: 30, bottom: 5 }}>
                        <CartesianGrid strokeDasharray="3 3" stroke="hsl(var(--muted))" opacity={0.3} />
                        <XAxis type="number" tickFormatter={(value) => `$${value}`} tickLine={false} axisLine={false} tickMargin={10} fontSize={12} />
                        <YAxis dataKey="name" type="category" tickLine={false} axisLine={false} tickMargin={5} width={120} interval={0} fontSize={12} />
                        <ChartTooltip content={({ active, payload }) => {
                          if (active && payload && payload.length) {
                            const data = payload[0].payload;
                            return (
                              <div className="rounded-lg border bg-background p-2 shadow-sm text-sm">
                                <div className="grid grid-cols-1 gap-1.5">
                                  <span className="font-medium">{data.name}</span>
                                  <span className="text-muted-foreground">Costo Total Perdido: <span className="font-semibold text-destructive">${data.totalCostLostUSD.toFixed(2)}</span></span>
                                  <span className="text-muted-foreground">Cant. Total Perdida: <span className="font-semibold">{data.totalQuantityLost} unid.</span></span>
                                  <span className="text-xs text-muted-foreground">(Cambios: {data.quantityChanged} unid, ${data.costChangedUSD.toFixed(2)})</span>
                                  <span className="text-xs text-muted-foreground">(Merma: {data.quantityWasted} unid, ${data.costWastedUSD.toFixed(2)})</span>
                                  <span className="text-xs text-muted-foreground">(Muestras: {data.quantitySampled} unid, ${data.costSampledUSD.toFixed(2)})</span>
                                </div>
                              </div>
                            );
                          }
                          return null;
                        }} />
                        <Bar dataKey="totalCostLostUSD" fill="var(--color-totalCostLostUSD)" radius={[0, 8, 8, 0]} isAnimationActive={true} animationDuration={800} animationBegin={300} />
                      </BarChart>
                    </ResponsiveContainer>
                  </ChartContainer>
                ) : (<p className="text-center text-muted-foreground py-8">No hay datos consolidados de pérdidas para el período y sede actual.</p>)}
              </CardContent>
              <CardFooter className="flex gap-2">
                <Button className="flex-1" onClick={handleDownloadLossesReport}><Download className="mr-2 h-4 w-4" /> Descargar Reporte</Button>
                <Button variant="outline" size="icon" onClick={() => handleExportChartAsImage("chart-perdidas-totales", "perdidas_totales")} title="Exportar Imagen"><ImageIcon className="h-4 w-4" /></Button>
              </CardFooter>
            </Card>

            <Card className="shadow-lg hover:shadow-xl transition-shadow duration-300 col-span-1 md:col-span-2 lg:col-span-1">
              <CardHeader>
                <CardTitle className="flex items-center gap-2"><Layers className="h-5 w-5 text-primary" /> Órdenes de Compra (Pagadas - Sede: {activeBranchName})</CardTitle>
                <CardDescription>Top 10 proveedores por costo total (USD) en el período para la sede actual.</CardDescription>
              </CardHeader>
              <CardContent className="h-[300px]">
                {purchaseOrdersChartData.length > 0 ? (
                  <ChartContainer config={purchaseOrdersChartConfig} className="h-full w-full" id="chart-ordenes-compra">
                    <ResponsiveContainer width="100%" height="100%">
                      <BarChart data={purchaseOrdersChartData} layout="vertical" margin={{ top: 5, right: 20, left: 30, bottom: 5 }}>
                        <CartesianGrid strokeDasharray="3 3" stroke="hsl(var(--muted))" opacity={0.3} />
                        <XAxis type="number" tickFormatter={(value) => `$${value}`} tickLine={false} axisLine={false} tickMargin={10} fontSize={12} />
                        <YAxis dataKey="supplierName" type="category" tickLine={false} axisLine={false} tickMargin={5} fontSize={12} width={120} interval={0} />
                        <ChartTooltip content={<ChartTooltipContent className="text-sm" />} />
                        <Bar dataKey="totalCost" fill="var(--color-totalCost)" radius={[0, 8, 8, 0]} isAnimationActive={true} animationDuration={800} animationBegin={600} />
                      </BarChart>
                    </ResponsiveContainer>
                  </ChartContainer>
                ) : (<p className="text-center text-muted-foreground py-8">No hay órdenes de compra pagadas para el período y sede actual.</p>)}
              </CardContent>
              <CardFooter className="flex gap-2">
                <Button className="flex-1" onClick={handleDownloadPurchaseOrdersReport}><Download className="mr-2 h-4 w-4" /> Descargar Reporte</Button>
                <Button variant="outline" size="icon" onClick={() => handleExportChartAsImage("chart-ordenes-compra", "ordenes_compra")} title="Exportar Imagen"><ImageIcon className="h-4 w-4" /></Button>
              </CardFooter>
            </Card>
          </div>
        </TabsContent>
      </Tabs >

      <Dialog open={isDateRangeDialogOpen} onOpenChange={setIsDateRangeDialogOpen}>
        <DialogContent className="sm:max-w-2xl">
          <DialogHeader>
            <DialogTitle>Seleccionar Rango de Fechas para Reportes</DialogTitle>
            <DialogDescription>Elige un rango para reportes. Los de Inventarios y Stock siempre muestran el estado actual.</DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4 justify-center">
            <Calendar mode="range" selected={selectedDateRange} onSelect={setSelectedDateRange} locale={es} numberOfMonths={2} />
            {selectedDateRange?.from && (<p className="text-center text-sm text-muted-foreground">Rango: {format(selectedDateRange.from, "dd/MM/yyyy", { locale: es })}{selectedDateRange.to && ` - ${format(selectedDateRange.to, "dd/MM/yyyy", { locale: es })}`}</p>)}
          </div>
          <UiDialogFooter>
            <Button variant="outline" onClick={() => setSelectedDateRange(undefined)}>Limpiar Rango</Button>
            <DialogClose asChild><Button onClick={() => { setIsDateRangeDialogOpen(false); if (selectedDateRange?.from) { toast({ title: "Rango Aplicado", description: `Reportes usarán este rango.` }); } else { toast({ title: "Rango Limpiado", description: `Reportes mostrarán todos los datos.` }); } }}>Aplicar y Cerrar</Button></DialogClose>
          </UiDialogFooter>
        </DialogContent>
      </Dialog>

      <Dialog open={isLossReportDialogOpen} onOpenChange={setIsLossReportDialogOpen}>
        <DialogContent className="sm:max-w-4xl max-h-[90vh]">
          <DialogHeader>
            <DialogTitle>Detalle del Reporte de Pérdida Semanal</DialogTitle>
            {selectedLossReport && (
              <DialogDescription>
                Semana del {format(parseISO(selectedLossReport.weekStartDate), "dd MMM yyyy", { locale: es })} al {format(parseISO(selectedLossReport.weekEndDate), "dd MMM yyyy", { locale: es })}.
                Pérdida Total: <span className="font-bold text-destructive">${selectedLossReport.totalLossUSD.toFixed(2)}</span>.
              </DialogDescription>
            )}
          </DialogHeader>
          <div className="flex-1 min-h-0">
            <ScrollArea className="h-[60vh]">
              <Table className="text-base">
                <TableHeader>
                  <TableRow>
                    <TableHead>Fecha</TableHead>
                    <TableHead>Sede</TableHead>
                    <TableHead>Tipo Pérdida</TableHead>
                    <TableHead>Producto</TableHead>
                    <TableHead>Cliente</TableHead>
                    <TableHead className="text-right">Cant.</TableHead>
                    <TableHead className="text-right">Costo Unit. (USD)</TableHead>
                    <TableHead className="text-right">Costo Total (USD)</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {selectedLossReport?.entries.map((entry, index) => (
                    <TableRow key={`${entry.date}-${entry.productName}-${index}`}>
                      <TableCell>{format(parseISO(entry.date), "dd/MM/yy", { locale: es })}</TableCell>
                      <TableCell>{entry.sourceBranchName}</TableCell>
                      <TableCell>{entry.type}</TableCell>
                      <TableCell>{entry.productName}</TableCell>
                      <TableCell>{entry.customerName || '-'}</TableCell>
                      <TableCell className="text-right">{entry.quantity}</TableCell>
                      <TableCell className="text-right">${entry.costPerUnitUSD.toFixed(3)}</TableCell>
                      <TableCell className="text-right text-destructive">${entry.totalCostUSD.toFixed(2)}</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </ScrollArea>
          </div>
          <UiDialogFooter>
            <Button variant="outline" onClick={() => setIsLossReportDialogOpen(false)}>Cerrar</Button>
            <Button onClick={() => selectedLossReport && handleDownloadDetailedLossReportPDF(selectedLossReport)} disabled={!selectedLossReport}>
              <Download className="mr-2 h-4 w-4" /> Descargar PDF
            </Button>
          </UiDialogFooter>
        </DialogContent>
      </Dialog>

      <Dialog open={isProfitReportDialogOpen} onOpenChange={setIsProfitReportDialogOpen}>
        <DialogContent className="sm:max-w-4xl max-h-[90vh]">
          <DialogHeader>
            <DialogTitle>Detalle del Reporte de Ganancia Semanal</DialogTitle>
            {selectedProfitReport && (
              <DialogDescription>
                <p>Semana del {format(parseISO(selectedProfitReport.weekStartDate), "dd MMM yyyy", { locale: es })} al {format(parseISO(selectedProfitReport.weekEndDate), "dd MMM yyyy", { locale: es })}.</p>
                <p>
                  <span className="font-semibold">Ingresos Totales:</span> <span className="text-green-600">${selectedProfitReport.totalRevenueUSD.toFixed(2)}</span> |
                  <span className="font-semibold"> Costos Totales:</span> <span className="text-destructive">${selectedProfitReport.totalCostsUSD.toFixed(2)}</span> |
                  <span className="font-semibold"> Ganancia Neta:</span> <span className="font-bold text-primary">${selectedProfitReport.totalProfitUSD.toFixed(2)}</span>
                </p>
              </DialogDescription>
            )}
          </DialogHeader>
          <div className="flex-1 min-h-0">
            <ScrollArea className="h-[60vh]">
              <Table className="text-base">
                <TableHeader>
                  <TableRow>
                    <TableHead>Fecha</TableHead>
                    <TableHead>Sede</TableHead>
                    <TableHead>Producto</TableHead>
                    <TableHead className="text-right">Cant. Vendida</TableHead>
                    <TableHead className="text-right">P. Venta (USD)</TableHead>
                    <TableHead className="text-right">Costo Prod. (USD)</TableHead>
                    <TableHead className="text-right">Ganancia Unit. (USD)</TableHead>
                    <TableHead className="text-right">Ganancia Total (USD)</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {selectedProfitReport?.entries.map((entry, index) => (
                    <TableRow key={`${entry.date}-${entry.productName}-${index}`}>
                      <TableCell>{format(parseISO(entry.date), "dd/MM/yy", { locale: es })}</TableCell>
                      <TableCell>{entry.sourceBranchName}</TableCell>
                      <TableCell>{entry.productName}</TableCell>
                      <TableCell className="text-right">{entry.quantitySold}</TableCell>
                      <TableCell className="text-right">${entry.salePricePerUnitUSD.toFixed(2)}</TableCell>
                      <TableCell className="text-right">${entry.costPerUnitUSD.toFixed(3)}</TableCell>
                      <TableCell className="text-right text-green-600">${entry.profitPerUnitUSD.toFixed(3)}</TableCell>
                      <TableCell className="text-right text-green-600 font-semibold">${entry.totalProfitUSD.toFixed(2)}</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </ScrollArea>
          </div>
          <UiDialogFooter>
            <Button variant="outline" onClick={() => setIsProfitReportDialogOpen(false)}>Cerrar</Button>
            <Button onClick={() => selectedProfitReport && handleDownloadDetailedProfitReportPDF(selectedProfitReport)} disabled={!selectedProfitReport}>
              <Download className="mr-2 h-4 w-4" /> Descargar PDF
            </Button>
          </UiDialogFooter>
        </DialogContent>
      </Dialog>
    </div >
  );
}

